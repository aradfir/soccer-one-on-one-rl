// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_service_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_service_2eproto;
namespace protos {
class AddArc;
struct AddArcDefaultTypeInternal;
extern AddArcDefaultTypeInternal _AddArc_default_instance_;
class AddCircle;
struct AddCircleDefaultTypeInternal;
extern AddCircleDefaultTypeInternal _AddCircle_default_instance_;
class AddLine;
struct AddLineDefaultTypeInternal;
extern AddLineDefaultTypeInternal _AddLine_default_instance_;
class AddMessage;
struct AddMessageDefaultTypeInternal;
extern AddMessageDefaultTypeInternal _AddMessage_default_instance_;
class AddPoint;
struct AddPointDefaultTypeInternal;
extern AddPointDefaultTypeInternal _AddPoint_default_instance_;
class AddRectangle;
struct AddRectangleDefaultTypeInternal;
extern AddRectangleDefaultTypeInternal _AddRectangle_default_instance_;
class AddSector;
struct AddSectorDefaultTypeInternal;
extern AddSectorDefaultTypeInternal _AddSector_default_instance_;
class AddText;
struct AddTextDefaultTypeInternal;
extern AddTextDefaultTypeInternal _AddText_default_instance_;
class AddTriangle;
struct AddTriangleDefaultTypeInternal;
extern AddTriangleDefaultTypeInternal _AddTriangle_default_instance_;
class AttentionTo;
struct AttentionToDefaultTypeInternal;
extern AttentionToDefaultTypeInternal _AttentionTo_default_instance_;
class AttentionToOf;
struct AttentionToOfDefaultTypeInternal;
extern AttentionToOfDefaultTypeInternal _AttentionToOf_default_instance_;
class Ball;
struct BallDefaultTypeInternal;
extern BallDefaultTypeInternal _Ball_default_instance_;
class BallGoalieMessage;
struct BallGoalieMessageDefaultTypeInternal;
extern BallGoalieMessageDefaultTypeInternal _BallGoalieMessage_default_instance_;
class BallMessage;
struct BallMessageDefaultTypeInternal;
extern BallMessageDefaultTypeInternal _BallMessage_default_instance_;
class BallPlayerMessage;
struct BallPlayerMessageDefaultTypeInternal;
extern BallPlayerMessageDefaultTypeInternal _BallPlayerMessage_default_instance_;
class Bhv_BeforeKickOff;
struct Bhv_BeforeKickOffDefaultTypeInternal;
extern Bhv_BeforeKickOffDefaultTypeInternal _Bhv_BeforeKickOff_default_instance_;
class Bhv_BodyNeckToBall;
struct Bhv_BodyNeckToBallDefaultTypeInternal;
extern Bhv_BodyNeckToBallDefaultTypeInternal _Bhv_BodyNeckToBall_default_instance_;
class Bhv_BodyNeckToPoint;
struct Bhv_BodyNeckToPointDefaultTypeInternal;
extern Bhv_BodyNeckToPointDefaultTypeInternal _Bhv_BodyNeckToPoint_default_instance_;
class Bhv_Emergency;
struct Bhv_EmergencyDefaultTypeInternal;
extern Bhv_EmergencyDefaultTypeInternal _Bhv_Emergency_default_instance_;
class Bhv_GoToPointLookBall;
struct Bhv_GoToPointLookBallDefaultTypeInternal;
extern Bhv_GoToPointLookBallDefaultTypeInternal _Bhv_GoToPointLookBall_default_instance_;
class Bhv_NeckBodyToBall;
struct Bhv_NeckBodyToBallDefaultTypeInternal;
extern Bhv_NeckBodyToBallDefaultTypeInternal _Bhv_NeckBodyToBall_default_instance_;
class Bhv_NeckBodyToPoint;
struct Bhv_NeckBodyToPointDefaultTypeInternal;
extern Bhv_NeckBodyToPointDefaultTypeInternal _Bhv_NeckBodyToPoint_default_instance_;
class Bhv_ScanField;
struct Bhv_ScanFieldDefaultTypeInternal;
extern Bhv_ScanFieldDefaultTypeInternal _Bhv_ScanField_default_instance_;
class Body_AdvanceBall;
struct Body_AdvanceBallDefaultTypeInternal;
extern Body_AdvanceBallDefaultTypeInternal _Body_AdvanceBall_default_instance_;
class Body_ClearBall;
struct Body_ClearBallDefaultTypeInternal;
extern Body_ClearBallDefaultTypeInternal _Body_ClearBall_default_instance_;
class Body_Dribble;
struct Body_DribbleDefaultTypeInternal;
extern Body_DribbleDefaultTypeInternal _Body_Dribble_default_instance_;
class Body_GoToPoint;
struct Body_GoToPointDefaultTypeInternal;
extern Body_GoToPointDefaultTypeInternal _Body_GoToPoint_default_instance_;
class Body_GoToPointDodge;
struct Body_GoToPointDodgeDefaultTypeInternal;
extern Body_GoToPointDodgeDefaultTypeInternal _Body_GoToPointDodge_default_instance_;
class Body_HoldBall;
struct Body_HoldBallDefaultTypeInternal;
extern Body_HoldBallDefaultTypeInternal _Body_HoldBall_default_instance_;
class Body_Intercept;
struct Body_InterceptDefaultTypeInternal;
extern Body_InterceptDefaultTypeInternal _Body_Intercept_default_instance_;
class Body_KickOneStep;
struct Body_KickOneStepDefaultTypeInternal;
extern Body_KickOneStepDefaultTypeInternal _Body_KickOneStep_default_instance_;
class Body_SmartKick;
struct Body_SmartKickDefaultTypeInternal;
extern Body_SmartKickDefaultTypeInternal _Body_SmartKick_default_instance_;
class Body_StopBall;
struct Body_StopBallDefaultTypeInternal;
extern Body_StopBallDefaultTypeInternal _Body_StopBall_default_instance_;
class Body_StopDash;
struct Body_StopDashDefaultTypeInternal;
extern Body_StopDashDefaultTypeInternal _Body_StopDash_default_instance_;
class Body_TackleToPoint;
struct Body_TackleToPointDefaultTypeInternal;
extern Body_TackleToPointDefaultTypeInternal _Body_TackleToPoint_default_instance_;
class Body_TurnToAngle;
struct Body_TurnToAngleDefaultTypeInternal;
extern Body_TurnToAngleDefaultTypeInternal _Body_TurnToAngle_default_instance_;
class Body_TurnToBall;
struct Body_TurnToBallDefaultTypeInternal;
extern Body_TurnToBallDefaultTypeInternal _Body_TurnToBall_default_instance_;
class Body_TurnToPoint;
struct Body_TurnToPointDefaultTypeInternal;
extern Body_TurnToPointDefaultTypeInternal _Body_TurnToPoint_default_instance_;
class Catch;
struct CatchDefaultTypeInternal;
extern CatchDefaultTypeInternal _Catch_default_instance_;
class ChangePlayerType;
struct ChangePlayerTypeDefaultTypeInternal;
extern ChangePlayerTypeDefaultTypeInternal _ChangePlayerType_default_instance_;
class ChangeView;
struct ChangeViewDefaultTypeInternal;
extern ChangeViewDefaultTypeInternal _ChangeView_default_instance_;
class CoachAction;
struct CoachActionDefaultTypeInternal;
extern CoachActionDefaultTypeInternal _CoachAction_default_instance_;
class CoachActions;
struct CoachActionsDefaultTypeInternal;
extern CoachActionsDefaultTypeInternal _CoachActions_default_instance_;
class Dash;
struct DashDefaultTypeInternal;
extern DashDefaultTypeInternal _Dash_default_instance_;
class DebugClient;
struct DebugClientDefaultTypeInternal;
extern DebugClientDefaultTypeInternal _DebugClient_default_instance_;
class DefenseLineMessage;
struct DefenseLineMessageDefaultTypeInternal;
extern DefenseLineMessageDefaultTypeInternal _DefenseLineMessage_default_instance_;
class DoChangeMode;
struct DoChangeModeDefaultTypeInternal;
extern DoChangeModeDefaultTypeInternal _DoChangeMode_default_instance_;
class DoChangePlayerType;
struct DoChangePlayerTypeDefaultTypeInternal;
extern DoChangePlayerTypeDefaultTypeInternal _DoChangePlayerType_default_instance_;
class DoHeliosSayPlayerTypes;
struct DoHeliosSayPlayerTypesDefaultTypeInternal;
extern DoHeliosSayPlayerTypesDefaultTypeInternal _DoHeliosSayPlayerTypes_default_instance_;
class DoHeliosSubstitute;
struct DoHeliosSubstituteDefaultTypeInternal;
extern DoHeliosSubstituteDefaultTypeInternal _DoHeliosSubstitute_default_instance_;
class DoKickOff;
struct DoKickOffDefaultTypeInternal;
extern DoKickOffDefaultTypeInternal _DoKickOff_default_instance_;
class DoMoveBall;
struct DoMoveBallDefaultTypeInternal;
extern DoMoveBallDefaultTypeInternal _DoMoveBall_default_instance_;
class DoMovePlayer;
struct DoMovePlayerDefaultTypeInternal;
extern DoMovePlayerDefaultTypeInternal _DoMovePlayer_default_instance_;
class DoRecover;
struct DoRecoverDefaultTypeInternal;
extern DoRecoverDefaultTypeInternal _DoRecover_default_instance_;
class DribbleMessage;
struct DribbleMessageDefaultTypeInternal;
extern DribbleMessageDefaultTypeInternal _DribbleMessage_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Focus_MoveToPoint;
struct Focus_MoveToPointDefaultTypeInternal;
extern Focus_MoveToPointDefaultTypeInternal _Focus_MoveToPoint_default_instance_;
class Focus_Reset;
struct Focus_ResetDefaultTypeInternal;
extern Focus_ResetDefaultTypeInternal _Focus_Reset_default_instance_;
class GoalieAndPlayerMessage;
struct GoalieAndPlayerMessageDefaultTypeInternal;
extern GoalieAndPlayerMessageDefaultTypeInternal _GoalieAndPlayerMessage_default_instance_;
class GoalieMessage;
struct GoalieMessageDefaultTypeInternal;
extern GoalieMessageDefaultTypeInternal _GoalieMessage_default_instance_;
class HeliosBasicMove;
struct HeliosBasicMoveDefaultTypeInternal;
extern HeliosBasicMoveDefaultTypeInternal _HeliosBasicMove_default_instance_;
class HeliosBasicOffensive;
struct HeliosBasicOffensiveDefaultTypeInternal;
extern HeliosBasicOffensiveDefaultTypeInternal _HeliosBasicOffensive_default_instance_;
class HeliosChainAction;
struct HeliosChainActionDefaultTypeInternal;
extern HeliosChainActionDefaultTypeInternal _HeliosChainAction_default_instance_;
class HeliosCommunicaion;
struct HeliosCommunicaionDefaultTypeInternal;
extern HeliosCommunicaionDefaultTypeInternal _HeliosCommunicaion_default_instance_;
class HeliosGoalie;
struct HeliosGoalieDefaultTypeInternal;
extern HeliosGoalieDefaultTypeInternal _HeliosGoalie_default_instance_;
class HeliosGoalieKick;
struct HeliosGoalieKickDefaultTypeInternal;
extern HeliosGoalieKickDefaultTypeInternal _HeliosGoalieKick_default_instance_;
class HeliosGoalieMove;
struct HeliosGoalieMoveDefaultTypeInternal;
extern HeliosGoalieMoveDefaultTypeInternal _HeliosGoalieMove_default_instance_;
class HeliosPenalty;
struct HeliosPenaltyDefaultTypeInternal;
extern HeliosPenaltyDefaultTypeInternal _HeliosPenalty_default_instance_;
class HeliosSetPlay;
struct HeliosSetPlayDefaultTypeInternal;
extern HeliosSetPlayDefaultTypeInternal _HeliosSetPlay_default_instance_;
class HeliosShoot;
struct HeliosShootDefaultTypeInternal;
extern HeliosShootDefaultTypeInternal _HeliosShoot_default_instance_;
class InitMessage;
struct InitMessageDefaultTypeInternal;
extern InitMessageDefaultTypeInternal _InitMessage_default_instance_;
class InterceptInfo;
struct InterceptInfoDefaultTypeInternal;
extern InterceptInfoDefaultTypeInternal _InterceptInfo_default_instance_;
class InterceptMessage;
struct InterceptMessageDefaultTypeInternal;
extern InterceptMessageDefaultTypeInternal _InterceptMessage_default_instance_;
class InterceptTable;
struct InterceptTableDefaultTypeInternal;
extern InterceptTableDefaultTypeInternal _InterceptTable_default_instance_;
class Kick;
struct KickDefaultTypeInternal;
extern KickDefaultTypeInternal _Kick_default_instance_;
class Log;
struct LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class Move;
struct MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class Neck_ScanField;
struct Neck_ScanFieldDefaultTypeInternal;
extern Neck_ScanFieldDefaultTypeInternal _Neck_ScanField_default_instance_;
class Neck_ScanPlayers;
struct Neck_ScanPlayersDefaultTypeInternal;
extern Neck_ScanPlayersDefaultTypeInternal _Neck_ScanPlayers_default_instance_;
class Neck_TurnToBall;
struct Neck_TurnToBallDefaultTypeInternal;
extern Neck_TurnToBallDefaultTypeInternal _Neck_TurnToBall_default_instance_;
class Neck_TurnToBallAndPlayer;
struct Neck_TurnToBallAndPlayerDefaultTypeInternal;
extern Neck_TurnToBallAndPlayerDefaultTypeInternal _Neck_TurnToBallAndPlayer_default_instance_;
class Neck_TurnToBallOrScan;
struct Neck_TurnToBallOrScanDefaultTypeInternal;
extern Neck_TurnToBallOrScanDefaultTypeInternal _Neck_TurnToBallOrScan_default_instance_;
class Neck_TurnToGoalieOrScan;
struct Neck_TurnToGoalieOrScanDefaultTypeInternal;
extern Neck_TurnToGoalieOrScanDefaultTypeInternal _Neck_TurnToGoalieOrScan_default_instance_;
class Neck_TurnToLowConfTeammate;
struct Neck_TurnToLowConfTeammateDefaultTypeInternal;
extern Neck_TurnToLowConfTeammateDefaultTypeInternal _Neck_TurnToLowConfTeammate_default_instance_;
class Neck_TurnToPlayerOrScan;
struct Neck_TurnToPlayerOrScanDefaultTypeInternal;
extern Neck_TurnToPlayerOrScanDefaultTypeInternal _Neck_TurnToPlayerOrScan_default_instance_;
class Neck_TurnToPoint;
struct Neck_TurnToPointDefaultTypeInternal;
extern Neck_TurnToPointDefaultTypeInternal _Neck_TurnToPoint_default_instance_;
class Neck_TurnToRelative;
struct Neck_TurnToRelativeDefaultTypeInternal;
extern Neck_TurnToRelativeDefaultTypeInternal _Neck_TurnToRelative_default_instance_;
class OffsideLineMessage;
struct OffsideLineMessageDefaultTypeInternal;
extern OffsideLineMessageDefaultTypeInternal _OffsideLineMessage_default_instance_;
class OnePlayerMessage;
struct OnePlayerMessageDefaultTypeInternal;
extern OnePlayerMessageDefaultTypeInternal _OnePlayerMessage_default_instance_;
class OpponentMessage;
struct OpponentMessageDefaultTypeInternal;
extern OpponentMessageDefaultTypeInternal _OpponentMessage_default_instance_;
class PassMessage;
struct PassMessageDefaultTypeInternal;
extern PassMessageDefaultTypeInternal _PassMessage_default_instance_;
class PassRequestMessage;
struct PassRequestMessageDefaultTypeInternal;
extern PassRequestMessageDefaultTypeInternal _PassRequestMessage_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PlayerAction;
struct PlayerActionDefaultTypeInternal;
extern PlayerActionDefaultTypeInternal _PlayerAction_default_instance_;
class PlayerActions;
struct PlayerActionsDefaultTypeInternal;
extern PlayerActionsDefaultTypeInternal _PlayerActions_default_instance_;
class PlayerParam;
struct PlayerParamDefaultTypeInternal;
extern PlayerParamDefaultTypeInternal _PlayerParam_default_instance_;
class PlayerType;
struct PlayerTypeDefaultTypeInternal;
extern PlayerTypeDefaultTypeInternal _PlayerType_default_instance_;
class PointTo;
struct PointToDefaultTypeInternal;
extern PointToDefaultTypeInternal _PointTo_default_instance_;
class PointToOf;
struct PointToOfDefaultTypeInternal;
extern PointToOfDefaultTypeInternal _PointToOf_default_instance_;
class RecoveryMessage;
struct RecoveryMessageDefaultTypeInternal;
extern RecoveryMessageDefaultTypeInternal _RecoveryMessage_default_instance_;
class Say;
struct SayDefaultTypeInternal;
extern SayDefaultTypeInternal _Say_default_instance_;
class Self;
struct SelfDefaultTypeInternal;
extern SelfDefaultTypeInternal _Self_default_instance_;
class SelfMessage;
struct SelfMessageDefaultTypeInternal;
extern SelfMessageDefaultTypeInternal _SelfMessage_default_instance_;
class ServerParam;
struct ServerParamDefaultTypeInternal;
extern ServerParamDefaultTypeInternal _ServerParam_default_instance_;
class SetplayMessage;
struct SetplayMessageDefaultTypeInternal;
extern SetplayMessageDefaultTypeInternal _SetplayMessage_default_instance_;
class StaminaCapacityMessage;
struct StaminaCapacityMessageDefaultTypeInternal;
extern StaminaCapacityMessageDefaultTypeInternal _StaminaCapacityMessage_default_instance_;
class StaminaMessage;
struct StaminaMessageDefaultTypeInternal;
extern StaminaMessageDefaultTypeInternal _StaminaMessage_default_instance_;
class State;
struct StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class Tackle;
struct TackleDefaultTypeInternal;
extern TackleDefaultTypeInternal _Tackle_default_instance_;
class TeammateMessage;
struct TeammateMessageDefaultTypeInternal;
extern TeammateMessageDefaultTypeInternal _TeammateMessage_default_instance_;
class ThreePlayerMessage;
struct ThreePlayerMessageDefaultTypeInternal;
extern ThreePlayerMessageDefaultTypeInternal _ThreePlayerMessage_default_instance_;
class TrainerAction;
struct TrainerActionDefaultTypeInternal;
extern TrainerActionDefaultTypeInternal _TrainerAction_default_instance_;
class TrainerActions;
struct TrainerActionsDefaultTypeInternal;
extern TrainerActionsDefaultTypeInternal _TrainerActions_default_instance_;
class Turn;
struct TurnDefaultTypeInternal;
extern TurnDefaultTypeInternal _Turn_default_instance_;
class TurnNeck;
struct TurnNeckDefaultTypeInternal;
extern TurnNeckDefaultTypeInternal _TurnNeck_default_instance_;
class TwoPlayerMessage;
struct TwoPlayerMessageDefaultTypeInternal;
extern TwoPlayerMessageDefaultTypeInternal _TwoPlayerMessage_default_instance_;
class Vector2D;
struct Vector2DDefaultTypeInternal;
extern Vector2DDefaultTypeInternal _Vector2D_default_instance_;
class View_ChangeWidth;
struct View_ChangeWidthDefaultTypeInternal;
extern View_ChangeWidthDefaultTypeInternal _View_ChangeWidth_default_instance_;
class View_Normal;
struct View_NormalDefaultTypeInternal;
extern View_NormalDefaultTypeInternal _View_Normal_default_instance_;
class View_Synch;
struct View_SynchDefaultTypeInternal;
extern View_SynchDefaultTypeInternal _View_Synch_default_instance_;
class View_Wide;
struct View_WideDefaultTypeInternal;
extern View_WideDefaultTypeInternal _View_Wide_default_instance_;
class WaitRequestMessage;
struct WaitRequestMessageDefaultTypeInternal;
extern WaitRequestMessageDefaultTypeInternal _WaitRequestMessage_default_instance_;
class WorldModel;
struct WorldModelDefaultTypeInternal;
extern WorldModelDefaultTypeInternal _WorldModel_default_instance_;
class WorldModel_HeliosHomePositionsEntry_DoNotUse;
struct WorldModel_HeliosHomePositionsEntry_DoNotUseDefaultTypeInternal;
extern WorldModel_HeliosHomePositionsEntry_DoNotUseDefaultTypeInternal _WorldModel_HeliosHomePositionsEntry_DoNotUse_default_instance_;
class WorldModel_OurPlayersDictEntry_DoNotUse;
struct WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal;
extern WorldModel_OurPlayersDictEntry_DoNotUseDefaultTypeInternal _WorldModel_OurPlayersDictEntry_DoNotUse_default_instance_;
class WorldModel_TheirPlayersDictEntry_DoNotUse;
struct WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal;
extern WorldModel_TheirPlayersDictEntry_DoNotUseDefaultTypeInternal _WorldModel_TheirPlayersDictEntry_DoNotUse_default_instance_;
}  // namespace protos
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace protos {
enum ViewWidth : int {
  NARROW = 0,
  NORMAL = 1,
  WIDE = 2,
  ViewWidth_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ViewWidth_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ViewWidth_IsValid(int value);
extern const uint32_t ViewWidth_internal_data_[];
constexpr ViewWidth ViewWidth_MIN = static_cast<ViewWidth>(0);
constexpr ViewWidth ViewWidth_MAX = static_cast<ViewWidth>(2);
constexpr int ViewWidth_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ViewWidth_descriptor();
template <typename T>
const std::string& ViewWidth_Name(T value) {
  static_assert(std::is_same<T, ViewWidth>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ViewWidth_Name().");
  return ViewWidth_Name(static_cast<ViewWidth>(value));
}
template <>
inline const std::string& ViewWidth_Name(ViewWidth value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ViewWidth_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ViewWidth_Parse(absl::string_view name, ViewWidth* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ViewWidth>(
      ViewWidth_descriptor(), name, value);
}
enum Side : int {
  UNKNOWN = 0,
  LEFT = 1,
  RIGHT = 2,
  Side_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Side_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Side_IsValid(int value);
extern const uint32_t Side_internal_data_[];
constexpr Side Side_MIN = static_cast<Side>(0);
constexpr Side Side_MAX = static_cast<Side>(2);
constexpr int Side_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Side_descriptor();
template <typename T>
const std::string& Side_Name(T value) {
  static_assert(std::is_same<T, Side>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Side_Name().");
  return Side_Name(static_cast<Side>(value));
}
template <>
inline const std::string& Side_Name(Side value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Side_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Side_Parse(absl::string_view name, Side* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Side>(
      Side_descriptor(), name, value);
}
enum LoggerLevel : int {
  None = 0,
  SYSTEM = 1,
  SENSOR = 2,
  WORLD = 4,
  ACTION = 8,
  INTERCEPT = 16,
  KICK = 32,
  HOLD = 64,
  DRIBBLE = 128,
  PASS = 256,
  CROSS = 512,
  SHOOT = 1024,
  CLEAR = 2048,
  BLOCK = 4096,
  MARK = 8192,
  POSITIONING = 16384,
  ROLE = 32768,
  TEAM = 65536,
  COMMUNICATION = 131072,
  ANALYZER = 262144,
  ACTION_CHAIN = 524288,
  PLAN = 1048576,
  LoggerLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LoggerLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LoggerLevel_IsValid(int value);
extern const uint32_t LoggerLevel_internal_data_[];
constexpr LoggerLevel LoggerLevel_MIN = static_cast<LoggerLevel>(0);
constexpr LoggerLevel LoggerLevel_MAX = static_cast<LoggerLevel>(1048576);
constexpr int LoggerLevel_ARRAYSIZE = 1048576 + 1;
const ::google::protobuf::EnumDescriptor*
LoggerLevel_descriptor();
template <typename T>
const std::string& LoggerLevel_Name(T value) {
  static_assert(std::is_same<T, LoggerLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LoggerLevel_Name().");
  return ::google::protobuf::internal::NameOfEnum(LoggerLevel_descriptor(), value);
}
inline bool LoggerLevel_Parse(absl::string_view name, LoggerLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoggerLevel>(
      LoggerLevel_descriptor(), name, value);
}
enum InterceptActionType : int {
  UNKNOWN_Intercept_Action_Type = 0,
  OMNI_DASH = 1,
  TURN_FORWARD_DASH = 2,
  TURN_BACKWARD_DASH = 3,
  InterceptActionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  InterceptActionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool InterceptActionType_IsValid(int value);
extern const uint32_t InterceptActionType_internal_data_[];
constexpr InterceptActionType InterceptActionType_MIN = static_cast<InterceptActionType>(0);
constexpr InterceptActionType InterceptActionType_MAX = static_cast<InterceptActionType>(3);
constexpr int InterceptActionType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
InterceptActionType_descriptor();
template <typename T>
const std::string& InterceptActionType_Name(T value) {
  static_assert(std::is_same<T, InterceptActionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InterceptActionType_Name().");
  return InterceptActionType_Name(static_cast<InterceptActionType>(value));
}
template <>
inline const std::string& InterceptActionType_Name(InterceptActionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InterceptActionType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool InterceptActionType_Parse(absl::string_view name, InterceptActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InterceptActionType>(
      InterceptActionType_descriptor(), name, value);
}
enum GameModeType : int {
  BeforeKickOff = 0,
  TimeOver = 1,
  PlayOn = 2,
  KickOff_ = 3,
  KickIn_ = 4,
  FreeKick_ = 5,
  CornerKick_ = 6,
  GoalKick_ = 7,
  AfterGoal_ = 8,
  OffSide_ = 9,
  PenaltyKick_ = 10,
  FirstHalfOver = 11,
  Pause = 12,
  Human = 13,
  FoulCharge_ = 14,
  FoulPush_ = 15,
  FoulMultipleAttacker_ = 16,
  FoulBallOut_ = 17,
  BackPass_ = 18,
  FreeKickFault_ = 19,
  CatchFault_ = 20,
  IndFreeKick_ = 21,
  PenaltySetup_ = 22,
  PenaltyReady_ = 23,
  PenaltyTaken_ = 24,
  PenaltyMiss_ = 25,
  PenaltyScore_ = 26,
  IllegalDefense_ = 27,
  PenaltyOnfield_ = 28,
  PenaltyFoul_ = 29,
  GoalieCatch_ = 30,
  ExtendHalf = 31,
  MODE_MAX = 32,
  GameModeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GameModeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GameModeType_IsValid(int value);
extern const uint32_t GameModeType_internal_data_[];
constexpr GameModeType GameModeType_MIN = static_cast<GameModeType>(0);
constexpr GameModeType GameModeType_MAX = static_cast<GameModeType>(32);
constexpr int GameModeType_ARRAYSIZE = 32 + 1;
const ::google::protobuf::EnumDescriptor*
GameModeType_descriptor();
template <typename T>
const std::string& GameModeType_Name(T value) {
  static_assert(std::is_same<T, GameModeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GameModeType_Name().");
  return GameModeType_Name(static_cast<GameModeType>(value));
}
template <>
inline const std::string& GameModeType_Name(GameModeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GameModeType_descriptor,
                                                 0, 32>(
      static_cast<int>(value));
}
inline bool GameModeType_Parse(absl::string_view name, GameModeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameModeType>(
      GameModeType_descriptor(), name, value);
}
enum AgentType : int {
  PlayerT = 0,
  CoachT = 1,
  TrainerT = 2,
  AgentType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AgentType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AgentType_IsValid(int value);
extern const uint32_t AgentType_internal_data_[];
constexpr AgentType AgentType_MIN = static_cast<AgentType>(0);
constexpr AgentType AgentType_MAX = static_cast<AgentType>(2);
constexpr int AgentType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
AgentType_descriptor();
template <typename T>
const std::string& AgentType_Name(T value) {
  static_assert(std::is_same<T, AgentType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AgentType_Name().");
  return AgentType_Name(static_cast<AgentType>(value));
}
template <>
inline const std::string& AgentType_Name(AgentType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AgentType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AgentType_Parse(absl::string_view name, AgentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AgentType>(
      AgentType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class WaitRequestMessage final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.WaitRequestMessage) */ {
 public:
  inline WaitRequestMessage() : WaitRequestMessage(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WaitRequestMessage(::google::protobuf::internal::ConstantInitialized);

  inline WaitRequestMessage(const WaitRequestMessage& from)
      : WaitRequestMessage(nullptr, from) {}
  WaitRequestMessage(WaitRequestMessage&& from) noexcept
    : WaitRequestMessage() {
    *this = ::std::move(from);
  }

  inline WaitRequestMessage& operator=(const WaitRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitRequestMessage& operator=(WaitRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaitRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitRequestMessage* internal_default_instance() {
    return reinterpret_cast<const WaitRequestMessage*>(
               &_WaitRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(WaitRequestMessage& a, WaitRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(WaitRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitRequestMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitRequestMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitRequestMessage>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const WaitRequestMessage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const WaitRequestMessage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.WaitRequestMessage";
  }
  protected:
  explicit WaitRequestMessage(::google::protobuf::Arena* arena);
  WaitRequestMessage(::google::protobuf::Arena* arena, const WaitRequestMessage& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.WaitRequestMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class View_Wide final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.View_Wide) */ {
 public:
  inline View_Wide() : View_Wide(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR View_Wide(::google::protobuf::internal::ConstantInitialized);

  inline View_Wide(const View_Wide& from)
      : View_Wide(nullptr, from) {}
  View_Wide(View_Wide&& from) noexcept
    : View_Wide() {
    *this = ::std::move(from);
  }

  inline View_Wide& operator=(const View_Wide& from) {
    CopyFrom(from);
    return *this;
  }
  inline View_Wide& operator=(View_Wide&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const View_Wide& default_instance() {
    return *internal_default_instance();
  }
  static inline const View_Wide* internal_default_instance() {
    return reinterpret_cast<const View_Wide*>(
               &_View_Wide_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(View_Wide& a, View_Wide& b) {
    a.Swap(&b);
  }
  inline void Swap(View_Wide* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(View_Wide* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  View_Wide* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<View_Wide>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const View_Wide& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const View_Wide& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.View_Wide";
  }
  protected:
  explicit View_Wide(::google::protobuf::Arena* arena);
  View_Wide(::google::protobuf::Arena* arena, const View_Wide& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.View_Wide)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class View_Synch final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.View_Synch) */ {
 public:
  inline View_Synch() : View_Synch(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR View_Synch(::google::protobuf::internal::ConstantInitialized);

  inline View_Synch(const View_Synch& from)
      : View_Synch(nullptr, from) {}
  View_Synch(View_Synch&& from) noexcept
    : View_Synch() {
    *this = ::std::move(from);
  }

  inline View_Synch& operator=(const View_Synch& from) {
    CopyFrom(from);
    return *this;
  }
  inline View_Synch& operator=(View_Synch&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const View_Synch& default_instance() {
    return *internal_default_instance();
  }
  static inline const View_Synch* internal_default_instance() {
    return reinterpret_cast<const View_Synch*>(
               &_View_Synch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(View_Synch& a, View_Synch& b) {
    a.Swap(&b);
  }
  inline void Swap(View_Synch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(View_Synch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  View_Synch* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<View_Synch>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const View_Synch& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const View_Synch& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.View_Synch";
  }
  protected:
  explicit View_Synch(::google::protobuf::Arena* arena);
  View_Synch(::google::protobuf::Arena* arena, const View_Synch& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.View_Synch)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class View_Normal final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.View_Normal) */ {
 public:
  inline View_Normal() : View_Normal(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR View_Normal(::google::protobuf::internal::ConstantInitialized);

  inline View_Normal(const View_Normal& from)
      : View_Normal(nullptr, from) {}
  View_Normal(View_Normal&& from) noexcept
    : View_Normal() {
    *this = ::std::move(from);
  }

  inline View_Normal& operator=(const View_Normal& from) {
    CopyFrom(from);
    return *this;
  }
  inline View_Normal& operator=(View_Normal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const View_Normal& default_instance() {
    return *internal_default_instance();
  }
  static inline const View_Normal* internal_default_instance() {
    return reinterpret_cast<const View_Normal*>(
               &_View_Normal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(View_Normal& a, View_Normal& b) {
    a.Swap(&b);
  }
  inline void Swap(View_Normal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(View_Normal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  View_Normal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<View_Normal>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const View_Normal& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const View_Normal& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.View_Normal";
  }
  protected:
  explicit View_Normal(::google::protobuf::Arena* arena);
  View_Normal(::google::protobuf::Arena* arena, const View_Normal& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.View_Normal)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class View_ChangeWidth final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.View_ChangeWidth) */ {
 public:
  inline View_ChangeWidth() : View_ChangeWidth(nullptr) {}
  ~View_ChangeWidth() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR View_ChangeWidth(::google::protobuf::internal::ConstantInitialized);

  inline View_ChangeWidth(const View_ChangeWidth& from)
      : View_ChangeWidth(nullptr, from) {}
  View_ChangeWidth(View_ChangeWidth&& from) noexcept
    : View_ChangeWidth() {
    *this = ::std::move(from);
  }

  inline View_ChangeWidth& operator=(const View_ChangeWidth& from) {
    CopyFrom(from);
    return *this;
  }
  inline View_ChangeWidth& operator=(View_ChangeWidth&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const View_ChangeWidth& default_instance() {
    return *internal_default_instance();
  }
  static inline const View_ChangeWidth* internal_default_instance() {
    return reinterpret_cast<const View_ChangeWidth*>(
               &_View_ChangeWidth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(View_ChangeWidth& a, View_ChangeWidth& b) {
    a.Swap(&b);
  }
  inline void Swap(View_ChangeWidth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(View_ChangeWidth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  View_ChangeWidth* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<View_ChangeWidth>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const View_ChangeWidth& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const View_ChangeWidth& from) {
    View_ChangeWidth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(View_ChangeWidth* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.View_ChangeWidth";
  }
  protected:
  explicit View_ChangeWidth(::google::protobuf::Arena* arena);
  View_ChangeWidth(::google::protobuf::Arena* arena, const View_ChangeWidth& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewWidthFieldNumber = 1,
  };
  // .protos.ViewWidth view_width = 1;
  void clear_view_width() ;
  ::protos::ViewWidth view_width() const;
  void set_view_width(::protos::ViewWidth value);

  private:
  ::protos::ViewWidth _internal_view_width() const;
  void _internal_set_view_width(::protos::ViewWidth value);

  public:
  // @@protoc_insertion_point(class_scope:protos.View_ChangeWidth)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int view_width_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Vector2D final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Vector2D) */ {
 public:
  inline Vector2D() : Vector2D(nullptr) {}
  ~Vector2D() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vector2D(::google::protobuf::internal::ConstantInitialized);

  inline Vector2D(const Vector2D& from)
      : Vector2D(nullptr, from) {}
  Vector2D(Vector2D&& from) noexcept
    : Vector2D() {
    *this = ::std::move(from);
  }

  inline Vector2D& operator=(const Vector2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2D& operator=(Vector2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector2D* internal_default_instance() {
    return reinterpret_cast<const Vector2D*>(
               &_Vector2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector2D& a, Vector2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2D* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector2D* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector2D>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector2D& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vector2D& from) {
    Vector2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vector2D* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Vector2D";
  }
  protected:
  explicit Vector2D(::google::protobuf::Arena* arena);
  Vector2D(::google::protobuf::Arena* arena, const Vector2D& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kDistFieldNumber = 3,
    kAngleFieldNumber = 4,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float dist = 3;
  void clear_dist() ;
  float dist() const;
  void set_dist(float value);

  private:
  float _internal_dist() const;
  void _internal_set_dist(float value);

  public:
  // float angle = 4;
  void clear_angle() ;
  float angle() const;
  void set_angle(float value);

  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Vector2D)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float x_;
    float y_;
    float dist_;
    float angle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class TurnNeck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.TurnNeck) */ {
 public:
  inline TurnNeck() : TurnNeck(nullptr) {}
  ~TurnNeck() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TurnNeck(::google::protobuf::internal::ConstantInitialized);

  inline TurnNeck(const TurnNeck& from)
      : TurnNeck(nullptr, from) {}
  TurnNeck(TurnNeck&& from) noexcept
    : TurnNeck() {
    *this = ::std::move(from);
  }

  inline TurnNeck& operator=(const TurnNeck& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnNeck& operator=(TurnNeck&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TurnNeck& default_instance() {
    return *internal_default_instance();
  }
  static inline const TurnNeck* internal_default_instance() {
    return reinterpret_cast<const TurnNeck*>(
               &_TurnNeck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TurnNeck& a, TurnNeck& b) {
    a.Swap(&b);
  }
  inline void Swap(TurnNeck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnNeck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnNeck* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TurnNeck>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TurnNeck& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TurnNeck& from) {
    TurnNeck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TurnNeck* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.TurnNeck";
  }
  protected:
  explicit TurnNeck(::google::protobuf::Arena* arena);
  TurnNeck(::google::protobuf::Arena* arena, const TurnNeck& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMomentFieldNumber = 1,
  };
  // float moment = 1;
  void clear_moment() ;
  float moment() const;
  void set_moment(float value);

  private:
  float _internal_moment() const;
  void _internal_set_moment(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.TurnNeck)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float moment_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Turn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Turn) */ {
 public:
  inline Turn() : Turn(nullptr) {}
  ~Turn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Turn(::google::protobuf::internal::ConstantInitialized);

  inline Turn(const Turn& from)
      : Turn(nullptr, from) {}
  Turn(Turn&& from) noexcept
    : Turn() {
    *this = ::std::move(from);
  }

  inline Turn& operator=(const Turn& from) {
    CopyFrom(from);
    return *this;
  }
  inline Turn& operator=(Turn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Turn& default_instance() {
    return *internal_default_instance();
  }
  static inline const Turn* internal_default_instance() {
    return reinterpret_cast<const Turn*>(
               &_Turn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Turn& a, Turn& b) {
    a.Swap(&b);
  }
  inline void Swap(Turn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Turn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Turn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Turn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Turn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Turn& from) {
    Turn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Turn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Turn";
  }
  protected:
  explicit Turn(::google::protobuf::Arena* arena);
  Turn(::google::protobuf::Arena* arena, const Turn& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelativeDirectionFieldNumber = 1,
  };
  // float relative_direction = 1;
  void clear_relative_direction() ;
  float relative_direction() const;
  void set_relative_direction(float value);

  private:
  float _internal_relative_direction() const;
  void _internal_set_relative_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Turn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float relative_direction_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Tackle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Tackle) */ {
 public:
  inline Tackle() : Tackle(nullptr) {}
  ~Tackle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Tackle(::google::protobuf::internal::ConstantInitialized);

  inline Tackle(const Tackle& from)
      : Tackle(nullptr, from) {}
  Tackle(Tackle&& from) noexcept
    : Tackle() {
    *this = ::std::move(from);
  }

  inline Tackle& operator=(const Tackle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tackle& operator=(Tackle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tackle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tackle* internal_default_instance() {
    return reinterpret_cast<const Tackle*>(
               &_Tackle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Tackle& a, Tackle& b) {
    a.Swap(&b);
  }
  inline void Swap(Tackle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tackle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tackle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tackle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Tackle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Tackle& from) {
    Tackle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Tackle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Tackle";
  }
  protected:
  explicit Tackle(::google::protobuf::Arena* arena);
  Tackle(::google::protobuf::Arena* arena, const Tackle& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerOrDirFieldNumber = 1,
    kFoulFieldNumber = 2,
  };
  // float power_or_dir = 1;
  void clear_power_or_dir() ;
  float power_or_dir() const;
  void set_power_or_dir(float value);

  private:
  float _internal_power_or_dir() const;
  void _internal_set_power_or_dir(float value);

  public:
  // bool foul = 2;
  void clear_foul() ;
  bool foul() const;
  void set_foul(bool value);

  private:
  bool _internal_foul() const;
  void _internal_set_foul(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Tackle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float power_or_dir_;
    bool foul_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class StaminaMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.StaminaMessage) */ {
 public:
  inline StaminaMessage() : StaminaMessage(nullptr) {}
  ~StaminaMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StaminaMessage(::google::protobuf::internal::ConstantInitialized);

  inline StaminaMessage(const StaminaMessage& from)
      : StaminaMessage(nullptr, from) {}
  StaminaMessage(StaminaMessage&& from) noexcept
    : StaminaMessage() {
    *this = ::std::move(from);
  }

  inline StaminaMessage& operator=(const StaminaMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaminaMessage& operator=(StaminaMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaminaMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaminaMessage* internal_default_instance() {
    return reinterpret_cast<const StaminaMessage*>(
               &_StaminaMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(StaminaMessage& a, StaminaMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StaminaMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaminaMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaminaMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaminaMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StaminaMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StaminaMessage& from) {
    StaminaMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StaminaMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.StaminaMessage";
  }
  protected:
  explicit StaminaMessage(::google::protobuf::Arena* arena);
  StaminaMessage(::google::protobuf::Arena* arena, const StaminaMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStaminaFieldNumber = 1,
  };
  // float stamina = 1;
  void clear_stamina() ;
  float stamina() const;
  void set_stamina(float value);

  private:
  float _internal_stamina() const;
  void _internal_set_stamina(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.StaminaMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float stamina_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class StaminaCapacityMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.StaminaCapacityMessage) */ {
 public:
  inline StaminaCapacityMessage() : StaminaCapacityMessage(nullptr) {}
  ~StaminaCapacityMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StaminaCapacityMessage(::google::protobuf::internal::ConstantInitialized);

  inline StaminaCapacityMessage(const StaminaCapacityMessage& from)
      : StaminaCapacityMessage(nullptr, from) {}
  StaminaCapacityMessage(StaminaCapacityMessage&& from) noexcept
    : StaminaCapacityMessage() {
    *this = ::std::move(from);
  }

  inline StaminaCapacityMessage& operator=(const StaminaCapacityMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaminaCapacityMessage& operator=(StaminaCapacityMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StaminaCapacityMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StaminaCapacityMessage* internal_default_instance() {
    return reinterpret_cast<const StaminaCapacityMessage*>(
               &_StaminaCapacityMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(StaminaCapacityMessage& a, StaminaCapacityMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StaminaCapacityMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaminaCapacityMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaminaCapacityMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaminaCapacityMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StaminaCapacityMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StaminaCapacityMessage& from) {
    StaminaCapacityMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StaminaCapacityMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.StaminaCapacityMessage";
  }
  protected:
  explicit StaminaCapacityMessage(::google::protobuf::Arena* arena);
  StaminaCapacityMessage(::google::protobuf::Arena* arena, const StaminaCapacityMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStaminaCapacityFieldNumber = 1,
  };
  // float stamina_capacity = 1;
  void clear_stamina_capacity() ;
  float stamina_capacity() const;
  void set_stamina_capacity(float value);

  private:
  float _internal_stamina_capacity() const;
  void _internal_set_stamina_capacity(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.StaminaCapacityMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float stamina_capacity_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class SetplayMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.SetplayMessage) */ {
 public:
  inline SetplayMessage() : SetplayMessage(nullptr) {}
  ~SetplayMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetplayMessage(::google::protobuf::internal::ConstantInitialized);

  inline SetplayMessage(const SetplayMessage& from)
      : SetplayMessage(nullptr, from) {}
  SetplayMessage(SetplayMessage&& from) noexcept
    : SetplayMessage() {
    *this = ::std::move(from);
  }

  inline SetplayMessage& operator=(const SetplayMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetplayMessage& operator=(SetplayMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetplayMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetplayMessage* internal_default_instance() {
    return reinterpret_cast<const SetplayMessage*>(
               &_SetplayMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SetplayMessage& a, SetplayMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SetplayMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetplayMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetplayMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetplayMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetplayMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetplayMessage& from) {
    SetplayMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetplayMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.SetplayMessage";
  }
  protected:
  explicit SetplayMessage(::google::protobuf::Arena* arena);
  SetplayMessage(::google::protobuf::Arena* arena, const SetplayMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWaitStepFieldNumber = 1,
  };
  // int32 wait_step = 1;
  void clear_wait_step() ;
  ::int32_t wait_step() const;
  void set_wait_step(::int32_t value);

  private:
  ::int32_t _internal_wait_step() const;
  void _internal_set_wait_step(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.SetplayMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t wait_step_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class ServerParam final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.ServerParam) */ {
 public:
  inline ServerParam() : ServerParam(nullptr) {}
  ~ServerParam() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ServerParam(::google::protobuf::internal::ConstantInitialized);

  inline ServerParam(const ServerParam& from)
      : ServerParam(nullptr, from) {}
  ServerParam(ServerParam&& from) noexcept
    : ServerParam() {
    *this = ::std::move(from);
  }

  inline ServerParam& operator=(const ServerParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerParam& operator=(ServerParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerParam* internal_default_instance() {
    return reinterpret_cast<const ServerParam*>(
               &_ServerParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(ServerParam& a, ServerParam& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerParam* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerParam* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerParam>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ServerParam& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ServerParam& from) {
    ServerParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ServerParam* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.ServerParam";
  }
  protected:
  explicit ServerParam(::google::protobuf::Arena* arena);
  ServerParam(::google::protobuf::Arena* arena, const ServerParam& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplayFileFieldNumber = 115,
    kLandmarkFileFieldNumber = 116,
    kTextLogDirFieldNumber = 121,
    kGameLogDirFieldNumber = 122,
    kTextLogFixedNameFieldNumber = 123,
    kGameLogFixedNameFieldNumber = 124,
    kLogDateFormatFieldNumber = 129,
    kTeamLStartFieldNumber = 154,
    kTeamRStartFieldNumber = 155,
    kKeepawayLogDirFieldNumber = 160,
    kKeepawayLogFixedNameFieldNumber = 161,
    kModuleDirFieldNumber = 179,
    kCoachMsgFileFieldNumber = 181,
    kFixedTeamnameLFieldNumber = 206,
    kFixedTeamnameRFieldNumber = 207,
    kAgentTypeFieldNumber = 1,
    kInertiaMomentFieldNumber = 2,
    kPlayerSizeFieldNumber = 3,
    kPlayerDecayFieldNumber = 4,
    kPlayerRandFieldNumber = 5,
    kPlayerWeightFieldNumber = 6,
    kPlayerSpeedMaxFieldNumber = 7,
    kPlayerAccelMaxFieldNumber = 8,
    kStaminaMaxFieldNumber = 9,
    kStaminaIncMaxFieldNumber = 10,
    kRecoverInitFieldNumber = 11,
    kRecoverDecThrFieldNumber = 12,
    kRecoverMinFieldNumber = 13,
    kRecoverDecFieldNumber = 14,
    kEffortInitFieldNumber = 15,
    kEffortDecThrFieldNumber = 16,
    kEffortMinFieldNumber = 17,
    kEffortDecFieldNumber = 18,
    kEffortIncThrFieldNumber = 19,
    kEffortIncFieldNumber = 20,
    kKickRandFieldNumber = 21,
    kPlayerRandFactorLFieldNumber = 23,
    kPlayerRandFactorRFieldNumber = 24,
    kKickRandFactorLFieldNumber = 25,
    kKickRandFactorRFieldNumber = 26,
    kBallSizeFieldNumber = 27,
    kBallDecayFieldNumber = 28,
    kBallRandFieldNumber = 29,
    kBallWeightFieldNumber = 30,
    kBallSpeedMaxFieldNumber = 31,
    kBallAccelMaxFieldNumber = 32,
    kDashPowerRateFieldNumber = 33,
    kKickPowerRateFieldNumber = 34,
    kKickableMarginFieldNumber = 35,
    kControlRadiusFieldNumber = 36,
    kControlRadiusWidthFieldNumber = 37,
    kMaxPowerFieldNumber = 38,
    kMinPowerFieldNumber = 39,
    kMaxMomentFieldNumber = 40,
    kMinMomentFieldNumber = 41,
    kMaxNeckMomentFieldNumber = 42,
    kMinNeckMomentFieldNumber = 43,
    kMaxNeckAngleFieldNumber = 44,
    kMinNeckAngleFieldNumber = 45,
    kVisibleAngleFieldNumber = 46,
    kVisibleDistanceFieldNumber = 47,
    kWindDirFieldNumber = 48,
    kWindForceFieldNumber = 49,
    kWindAngleFieldNumber = 50,
    kWindRandFieldNumber = 51,
    kKickableAreaFieldNumber = 52,
    kCatchAreaLFieldNumber = 53,
    kCatchAreaWFieldNumber = 54,
    kCatchProbabilityFieldNumber = 55,
    kTeamActuatorNoiseFieldNumber = 22,
    kWindNoneFieldNumber = 59,
    kUseWindRandomFieldNumber = 60,
    kUseOffsideFieldNumber = 82,
    kGoalieMaxMovesFieldNumber = 56,
    kCornerKickMarginFieldNumber = 57,
    kOffsideActiveAreaSizeFieldNumber = 58,
    kCoachSayCountMaxFieldNumber = 61,
    kCoachSayMsgSizeFieldNumber = 62,
    kClangWinSizeFieldNumber = 63,
    kClangDefineWinFieldNumber = 64,
    kClangMetaWinFieldNumber = 65,
    kClangAdviceWinFieldNumber = 66,
    kClangInfoWinFieldNumber = 67,
    kClangMessDelayFieldNumber = 68,
    kClangMessPerCycleFieldNumber = 69,
    kHalfTimeFieldNumber = 70,
    kSimulatorStepFieldNumber = 71,
    kSendStepFieldNumber = 72,
    kRecvStepFieldNumber = 73,
    kSenseBodyStepFieldNumber = 74,
    kLcmStepFieldNumber = 75,
    kPlayerSayMsgSizeFieldNumber = 76,
    kPlayerHearMaxFieldNumber = 77,
    kPlayerHearIncFieldNumber = 78,
    kPlayerHearDecayFieldNumber = 79,
    kCatchBanCycleFieldNumber = 80,
    kSlowDownFactorFieldNumber = 81,
    kOffsideKickMarginFieldNumber = 84,
    kAudioCutDistFieldNumber = 85,
    kDistQuantizeStepFieldNumber = 86,
    kLandmarkDistQuantizeStepFieldNumber = 87,
    kDirQuantizeStepFieldNumber = 88,
    kDistQuantizeStepLFieldNumber = 89,
    kDistQuantizeStepRFieldNumber = 90,
    kLandmarkDistQuantizeStepLFieldNumber = 91,
    kLandmarkDistQuantizeStepRFieldNumber = 92,
    kKickoffOffsideFieldNumber = 83,
    kCoachModeFieldNumber = 95,
    kCoachWithRefereeModeFieldNumber = 96,
    kUseOldCoachHearFieldNumber = 97,
    kDirQuantizeStepLFieldNumber = 93,
    kDirQuantizeStepRFieldNumber = 94,
    kSlownessOnTopForLeftTeamFieldNumber = 98,
    kSlownessOnTopForRightTeamFieldNumber = 99,
    kStartGoalLFieldNumber = 100,
    kStartGoalRFieldNumber = 101,
    kDropBallTimeFieldNumber = 104,
    kFullstateLFieldNumber = 102,
    kFullstateRFieldNumber = 103,
    kSynchModeFieldNumber = 105,
    kVerboseModeFieldNumber = 113,
    kSynchOffsetFieldNumber = 106,
    kSynchMicroSleepFieldNumber = 107,
    kPointToBanFieldNumber = 108,
    kPointToDurationFieldNumber = 109,
    kPlayerPortFieldNumber = 110,
    kTrainerPortFieldNumber = 111,
    kOnlineCoachPortFieldNumber = 112,
    kCoachSendViStepFieldNumber = 114,
    kSendCommsFieldNumber = 117,
    kTextLoggingFieldNumber = 118,
    kGameLoggingFieldNumber = 119,
    kUseTextLogFixedFieldNumber = 125,
    kGameLogVersionFieldNumber = 120,
    kUseGameLogFixedFieldNumber = 126,
    kUseTextLogDatedFieldNumber = 127,
    kUseGameLogDatedFieldNumber = 128,
    kLogTimesFieldNumber = 130,
    kTextLogCompressionFieldNumber = 132,
    kGameLogCompressionFieldNumber = 133,
    kTackleDistFieldNumber = 135,
    kTackleBackDistFieldNumber = 136,
    kTackleWidthFieldNumber = 137,
    kTackleExponentFieldNumber = 138,
    kRecordMessageFieldNumber = 131,
    kUseProfileFieldNumber = 134,
    kFreeKickFaultsFieldNumber = 143,
    kBackPassesFieldNumber = 144,
    kTackleCyclesFieldNumber = 139,
    kTacklePowerRateFieldNumber = 140,
    kFreeformWaitPeriodFieldNumber = 141,
    kFreeformSendPeriodFieldNumber = 142,
    kStoppedBallVelFieldNumber = 146,
    kMaxGoalKicksFieldNumber = 147,
    kClangDelWinFieldNumber = 148,
    kClangRuleWinFieldNumber = 149,
    kKickOffWaitFieldNumber = 151,
    kConnectWaitFieldNumber = 152,
    kProperGoalKicksFieldNumber = 145,
    kAutoModeFieldNumber = 150,
    kKeepawayModeFieldNumber = 156,
    kKeepawayLoggingFieldNumber = 159,
    kGameOverWaitFieldNumber = 153,
    kKeepawayLengthFieldNumber = 157,
    kKeepawayWidthFieldNumber = 158,
    kKeepawayStartFieldNumber = 164,
    kNrNormalHalfsFieldNumber = 165,
    kNrExtraHalfsFieldNumber = 166,
    kKeepawayLogFixedFieldNumber = 162,
    kKeepawayLogDatedFieldNumber = 163,
    kPenaltyShootOutsFieldNumber = 167,
    kPenRandomWinnerFieldNumber = 175,
    kPenBeforeSetupWaitFieldNumber = 168,
    kPenSetupWaitFieldNumber = 169,
    kPenReadyWaitFieldNumber = 170,
    kPenTakenWaitFieldNumber = 171,
    kPenNrKicksFieldNumber = 172,
    kPenMaxExtraKicksFieldNumber = 173,
    kPenDistXFieldNumber = 174,
    kPenMaxGoalieDistXFieldNumber = 177,
    kBallStuckAreaFieldNumber = 180,
    kMaxTacklePowerFieldNumber = 182,
    kMaxBackTacklePowerFieldNumber = 183,
    kPlayerSpeedMaxMinFieldNumber = 184,
    kPenAllowMultKicksFieldNumber = 176,
    kPenCoachMovesPlayersFieldNumber = 178,
    kGoldenGoalFieldNumber = 200,
    kExtraStaminaFieldNumber = 185,
    kSynchSeeOffsetFieldNumber = 186,
    kExtraHalfTimeFieldNumber = 187,
    kStaminaCapacityFieldNumber = 188,
    kMaxDashAngleFieldNumber = 189,
    kMinDashAngleFieldNumber = 190,
    kDashAngleStepFieldNumber = 191,
    kSideDashRateFieldNumber = 192,
    kBackDashRateFieldNumber = 193,
    kMaxDashPowerFieldNumber = 194,
    kMinDashPowerFieldNumber = 195,
    kTackleRandFactorFieldNumber = 196,
    kFoulDetectProbabilityFieldNumber = 197,
    kFoulExponentFieldNumber = 198,
    kFoulCyclesFieldNumber = 199,
    kRedCardProbabilityFieldNumber = 201,
    kIllegalDefenseDurationFieldNumber = 202,
    kIllegalDefenseNumberFieldNumber = 203,
    kIllegalDefenseDistXFieldNumber = 204,
    kIllegalDefenseWidthFieldNumber = 205,
    kMaxCatchAngleFieldNumber = 208,
    kMinCatchAngleFieldNumber = 209,
    kRandomSeedFieldNumber = 210,
    kLongKickPowerFactorFieldNumber = 211,
    kLongKickDelayFieldNumber = 212,
    kMaxMonitorsFieldNumber = 213,
    kCatchableAreaFieldNumber = 214,
    kRealSpeedMaxFieldNumber = 215,
    kPitchHalfLengthFieldNumber = 216,
    kPitchHalfWidthFieldNumber = 217,
    kOurPenaltyAreaLineXFieldNumber = 218,
    kTheirPenaltyAreaLineXFieldNumber = 219,
    kPenaltyAreaHalfWidthFieldNumber = 220,
    kPenaltyAreaLengthFieldNumber = 221,
    kGoalWidthFieldNumber = 222,
  };
  // string replay_file = 115;
  void clear_replay_file() ;
  const std::string& replay_file() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_replay_file(Arg_&& arg, Args_... args);
  std::string* mutable_replay_file();
  PROTOBUF_NODISCARD std::string* release_replay_file();
  void set_allocated_replay_file(std::string* value);

  private:
  const std::string& _internal_replay_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_replay_file(
      const std::string& value);
  std::string* _internal_mutable_replay_file();

  public:
  // string landmark_file = 116;
  void clear_landmark_file() ;
  const std::string& landmark_file() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_landmark_file(Arg_&& arg, Args_... args);
  std::string* mutable_landmark_file();
  PROTOBUF_NODISCARD std::string* release_landmark_file();
  void set_allocated_landmark_file(std::string* value);

  private:
  const std::string& _internal_landmark_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_landmark_file(
      const std::string& value);
  std::string* _internal_mutable_landmark_file();

  public:
  // string text_log_dir = 121;
  void clear_text_log_dir() ;
  const std::string& text_log_dir() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text_log_dir(Arg_&& arg, Args_... args);
  std::string* mutable_text_log_dir();
  PROTOBUF_NODISCARD std::string* release_text_log_dir();
  void set_allocated_text_log_dir(std::string* value);

  private:
  const std::string& _internal_text_log_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_log_dir(
      const std::string& value);
  std::string* _internal_mutable_text_log_dir();

  public:
  // string game_log_dir = 122;
  void clear_game_log_dir() ;
  const std::string& game_log_dir() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_game_log_dir(Arg_&& arg, Args_... args);
  std::string* mutable_game_log_dir();
  PROTOBUF_NODISCARD std::string* release_game_log_dir();
  void set_allocated_game_log_dir(std::string* value);

  private:
  const std::string& _internal_game_log_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_log_dir(
      const std::string& value);
  std::string* _internal_mutable_game_log_dir();

  public:
  // string text_log_fixed_name = 123;
  void clear_text_log_fixed_name() ;
  const std::string& text_log_fixed_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text_log_fixed_name(Arg_&& arg, Args_... args);
  std::string* mutable_text_log_fixed_name();
  PROTOBUF_NODISCARD std::string* release_text_log_fixed_name();
  void set_allocated_text_log_fixed_name(std::string* value);

  private:
  const std::string& _internal_text_log_fixed_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_log_fixed_name(
      const std::string& value);
  std::string* _internal_mutable_text_log_fixed_name();

  public:
  // string game_log_fixed_name = 124;
  void clear_game_log_fixed_name() ;
  const std::string& game_log_fixed_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_game_log_fixed_name(Arg_&& arg, Args_... args);
  std::string* mutable_game_log_fixed_name();
  PROTOBUF_NODISCARD std::string* release_game_log_fixed_name();
  void set_allocated_game_log_fixed_name(std::string* value);

  private:
  const std::string& _internal_game_log_fixed_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_log_fixed_name(
      const std::string& value);
  std::string* _internal_mutable_game_log_fixed_name();

  public:
  // string log_date_format = 129;
  void clear_log_date_format() ;
  const std::string& log_date_format() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log_date_format(Arg_&& arg, Args_... args);
  std::string* mutable_log_date_format();
  PROTOBUF_NODISCARD std::string* release_log_date_format();
  void set_allocated_log_date_format(std::string* value);

  private:
  const std::string& _internal_log_date_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_date_format(
      const std::string& value);
  std::string* _internal_mutable_log_date_format();

  public:
  // string team_l_start = 154;
  void clear_team_l_start() ;
  const std::string& team_l_start() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_team_l_start(Arg_&& arg, Args_... args);
  std::string* mutable_team_l_start();
  PROTOBUF_NODISCARD std::string* release_team_l_start();
  void set_allocated_team_l_start(std::string* value);

  private:
  const std::string& _internal_team_l_start() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_l_start(
      const std::string& value);
  std::string* _internal_mutable_team_l_start();

  public:
  // string team_r_start = 155;
  void clear_team_r_start() ;
  const std::string& team_r_start() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_team_r_start(Arg_&& arg, Args_... args);
  std::string* mutable_team_r_start();
  PROTOBUF_NODISCARD std::string* release_team_r_start();
  void set_allocated_team_r_start(std::string* value);

  private:
  const std::string& _internal_team_r_start() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_r_start(
      const std::string& value);
  std::string* _internal_mutable_team_r_start();

  public:
  // string keepaway_log_dir = 160;
  void clear_keepaway_log_dir() ;
  const std::string& keepaway_log_dir() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_keepaway_log_dir(Arg_&& arg, Args_... args);
  std::string* mutable_keepaway_log_dir();
  PROTOBUF_NODISCARD std::string* release_keepaway_log_dir();
  void set_allocated_keepaway_log_dir(std::string* value);

  private:
  const std::string& _internal_keepaway_log_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keepaway_log_dir(
      const std::string& value);
  std::string* _internal_mutable_keepaway_log_dir();

  public:
  // string keepaway_log_fixed_name = 161;
  void clear_keepaway_log_fixed_name() ;
  const std::string& keepaway_log_fixed_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_keepaway_log_fixed_name(Arg_&& arg, Args_... args);
  std::string* mutable_keepaway_log_fixed_name();
  PROTOBUF_NODISCARD std::string* release_keepaway_log_fixed_name();
  void set_allocated_keepaway_log_fixed_name(std::string* value);

  private:
  const std::string& _internal_keepaway_log_fixed_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keepaway_log_fixed_name(
      const std::string& value);
  std::string* _internal_mutable_keepaway_log_fixed_name();

  public:
  // string module_dir = 179;
  void clear_module_dir() ;
  const std::string& module_dir() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_module_dir(Arg_&& arg, Args_... args);
  std::string* mutable_module_dir();
  PROTOBUF_NODISCARD std::string* release_module_dir();
  void set_allocated_module_dir(std::string* value);

  private:
  const std::string& _internal_module_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_dir(
      const std::string& value);
  std::string* _internal_mutable_module_dir();

  public:
  // string coach_msg_file = 181;
  void clear_coach_msg_file() ;
  const std::string& coach_msg_file() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_coach_msg_file(Arg_&& arg, Args_... args);
  std::string* mutable_coach_msg_file();
  PROTOBUF_NODISCARD std::string* release_coach_msg_file();
  void set_allocated_coach_msg_file(std::string* value);

  private:
  const std::string& _internal_coach_msg_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coach_msg_file(
      const std::string& value);
  std::string* _internal_mutable_coach_msg_file();

  public:
  // string fixed_teamname_l = 206;
  void clear_fixed_teamname_l() ;
  const std::string& fixed_teamname_l() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fixed_teamname_l(Arg_&& arg, Args_... args);
  std::string* mutable_fixed_teamname_l();
  PROTOBUF_NODISCARD std::string* release_fixed_teamname_l();
  void set_allocated_fixed_teamname_l(std::string* value);

  private:
  const std::string& _internal_fixed_teamname_l() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fixed_teamname_l(
      const std::string& value);
  std::string* _internal_mutable_fixed_teamname_l();

  public:
  // string fixed_teamname_r = 207;
  void clear_fixed_teamname_r() ;
  const std::string& fixed_teamname_r() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fixed_teamname_r(Arg_&& arg, Args_... args);
  std::string* mutable_fixed_teamname_r();
  PROTOBUF_NODISCARD std::string* release_fixed_teamname_r();
  void set_allocated_fixed_teamname_r(std::string* value);

  private:
  const std::string& _internal_fixed_teamname_r() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fixed_teamname_r(
      const std::string& value);
  std::string* _internal_mutable_fixed_teamname_r();

  public:
  // .protos.AgentType agent_type = 1;
  void clear_agent_type() ;
  ::protos::AgentType agent_type() const;
  void set_agent_type(::protos::AgentType value);

  private:
  ::protos::AgentType _internal_agent_type() const;
  void _internal_set_agent_type(::protos::AgentType value);

  public:
  // float inertia_moment = 2;
  void clear_inertia_moment() ;
  float inertia_moment() const;
  void set_inertia_moment(float value);

  private:
  float _internal_inertia_moment() const;
  void _internal_set_inertia_moment(float value);

  public:
  // float player_size = 3;
  void clear_player_size() ;
  float player_size() const;
  void set_player_size(float value);

  private:
  float _internal_player_size() const;
  void _internal_set_player_size(float value);

  public:
  // float player_decay = 4;
  void clear_player_decay() ;
  float player_decay() const;
  void set_player_decay(float value);

  private:
  float _internal_player_decay() const;
  void _internal_set_player_decay(float value);

  public:
  // float player_rand = 5;
  void clear_player_rand() ;
  float player_rand() const;
  void set_player_rand(float value);

  private:
  float _internal_player_rand() const;
  void _internal_set_player_rand(float value);

  public:
  // float player_weight = 6;
  void clear_player_weight() ;
  float player_weight() const;
  void set_player_weight(float value);

  private:
  float _internal_player_weight() const;
  void _internal_set_player_weight(float value);

  public:
  // float player_speed_max = 7;
  void clear_player_speed_max() ;
  float player_speed_max() const;
  void set_player_speed_max(float value);

  private:
  float _internal_player_speed_max() const;
  void _internal_set_player_speed_max(float value);

  public:
  // float player_accel_max = 8;
  void clear_player_accel_max() ;
  float player_accel_max() const;
  void set_player_accel_max(float value);

  private:
  float _internal_player_accel_max() const;
  void _internal_set_player_accel_max(float value);

  public:
  // float stamina_max = 9;
  void clear_stamina_max() ;
  float stamina_max() const;
  void set_stamina_max(float value);

  private:
  float _internal_stamina_max() const;
  void _internal_set_stamina_max(float value);

  public:
  // float stamina_inc_max = 10;
  void clear_stamina_inc_max() ;
  float stamina_inc_max() const;
  void set_stamina_inc_max(float value);

  private:
  float _internal_stamina_inc_max() const;
  void _internal_set_stamina_inc_max(float value);

  public:
  // float recover_init = 11;
  void clear_recover_init() ;
  float recover_init() const;
  void set_recover_init(float value);

  private:
  float _internal_recover_init() const;
  void _internal_set_recover_init(float value);

  public:
  // float recover_dec_thr = 12;
  void clear_recover_dec_thr() ;
  float recover_dec_thr() const;
  void set_recover_dec_thr(float value);

  private:
  float _internal_recover_dec_thr() const;
  void _internal_set_recover_dec_thr(float value);

  public:
  // float recover_min = 13;
  void clear_recover_min() ;
  float recover_min() const;
  void set_recover_min(float value);

  private:
  float _internal_recover_min() const;
  void _internal_set_recover_min(float value);

  public:
  // float recover_dec = 14;
  void clear_recover_dec() ;
  float recover_dec() const;
  void set_recover_dec(float value);

  private:
  float _internal_recover_dec() const;
  void _internal_set_recover_dec(float value);

  public:
  // float effort_init = 15;
  void clear_effort_init() ;
  float effort_init() const;
  void set_effort_init(float value);

  private:
  float _internal_effort_init() const;
  void _internal_set_effort_init(float value);

  public:
  // float effort_dec_thr = 16;
  void clear_effort_dec_thr() ;
  float effort_dec_thr() const;
  void set_effort_dec_thr(float value);

  private:
  float _internal_effort_dec_thr() const;
  void _internal_set_effort_dec_thr(float value);

  public:
  // float effort_min = 17;
  void clear_effort_min() ;
  float effort_min() const;
  void set_effort_min(float value);

  private:
  float _internal_effort_min() const;
  void _internal_set_effort_min(float value);

  public:
  // float effort_dec = 18;
  void clear_effort_dec() ;
  float effort_dec() const;
  void set_effort_dec(float value);

  private:
  float _internal_effort_dec() const;
  void _internal_set_effort_dec(float value);

  public:
  // float effort_inc_thr = 19;
  void clear_effort_inc_thr() ;
  float effort_inc_thr() const;
  void set_effort_inc_thr(float value);

  private:
  float _internal_effort_inc_thr() const;
  void _internal_set_effort_inc_thr(float value);

  public:
  // float effort_inc = 20;
  void clear_effort_inc() ;
  float effort_inc() const;
  void set_effort_inc(float value);

  private:
  float _internal_effort_inc() const;
  void _internal_set_effort_inc(float value);

  public:
  // float kick_rand = 21;
  void clear_kick_rand() ;
  float kick_rand() const;
  void set_kick_rand(float value);

  private:
  float _internal_kick_rand() const;
  void _internal_set_kick_rand(float value);

  public:
  // float player_rand_factor_l = 23;
  void clear_player_rand_factor_l() ;
  float player_rand_factor_l() const;
  void set_player_rand_factor_l(float value);

  private:
  float _internal_player_rand_factor_l() const;
  void _internal_set_player_rand_factor_l(float value);

  public:
  // float player_rand_factor_r = 24;
  void clear_player_rand_factor_r() ;
  float player_rand_factor_r() const;
  void set_player_rand_factor_r(float value);

  private:
  float _internal_player_rand_factor_r() const;
  void _internal_set_player_rand_factor_r(float value);

  public:
  // float kick_rand_factor_l = 25;
  void clear_kick_rand_factor_l() ;
  float kick_rand_factor_l() const;
  void set_kick_rand_factor_l(float value);

  private:
  float _internal_kick_rand_factor_l() const;
  void _internal_set_kick_rand_factor_l(float value);

  public:
  // float kick_rand_factor_r = 26;
  void clear_kick_rand_factor_r() ;
  float kick_rand_factor_r() const;
  void set_kick_rand_factor_r(float value);

  private:
  float _internal_kick_rand_factor_r() const;
  void _internal_set_kick_rand_factor_r(float value);

  public:
  // float ball_size = 27;
  void clear_ball_size() ;
  float ball_size() const;
  void set_ball_size(float value);

  private:
  float _internal_ball_size() const;
  void _internal_set_ball_size(float value);

  public:
  // float ball_decay = 28;
  void clear_ball_decay() ;
  float ball_decay() const;
  void set_ball_decay(float value);

  private:
  float _internal_ball_decay() const;
  void _internal_set_ball_decay(float value);

  public:
  // float ball_rand = 29;
  void clear_ball_rand() ;
  float ball_rand() const;
  void set_ball_rand(float value);

  private:
  float _internal_ball_rand() const;
  void _internal_set_ball_rand(float value);

  public:
  // float ball_weight = 30;
  void clear_ball_weight() ;
  float ball_weight() const;
  void set_ball_weight(float value);

  private:
  float _internal_ball_weight() const;
  void _internal_set_ball_weight(float value);

  public:
  // float ball_speed_max = 31;
  void clear_ball_speed_max() ;
  float ball_speed_max() const;
  void set_ball_speed_max(float value);

  private:
  float _internal_ball_speed_max() const;
  void _internal_set_ball_speed_max(float value);

  public:
  // float ball_accel_max = 32;
  void clear_ball_accel_max() ;
  float ball_accel_max() const;
  void set_ball_accel_max(float value);

  private:
  float _internal_ball_accel_max() const;
  void _internal_set_ball_accel_max(float value);

  public:
  // float dash_power_rate = 33;
  void clear_dash_power_rate() ;
  float dash_power_rate() const;
  void set_dash_power_rate(float value);

  private:
  float _internal_dash_power_rate() const;
  void _internal_set_dash_power_rate(float value);

  public:
  // float kick_power_rate = 34;
  void clear_kick_power_rate() ;
  float kick_power_rate() const;
  void set_kick_power_rate(float value);

  private:
  float _internal_kick_power_rate() const;
  void _internal_set_kick_power_rate(float value);

  public:
  // float kickable_margin = 35;
  void clear_kickable_margin() ;
  float kickable_margin() const;
  void set_kickable_margin(float value);

  private:
  float _internal_kickable_margin() const;
  void _internal_set_kickable_margin(float value);

  public:
  // float control_radius = 36;
  void clear_control_radius() ;
  float control_radius() const;
  void set_control_radius(float value);

  private:
  float _internal_control_radius() const;
  void _internal_set_control_radius(float value);

  public:
  // float control_radius_width = 37;
  void clear_control_radius_width() ;
  float control_radius_width() const;
  void set_control_radius_width(float value);

  private:
  float _internal_control_radius_width() const;
  void _internal_set_control_radius_width(float value);

  public:
  // float max_power = 38;
  void clear_max_power() ;
  float max_power() const;
  void set_max_power(float value);

  private:
  float _internal_max_power() const;
  void _internal_set_max_power(float value);

  public:
  // float min_power = 39;
  void clear_min_power() ;
  float min_power() const;
  void set_min_power(float value);

  private:
  float _internal_min_power() const;
  void _internal_set_min_power(float value);

  public:
  // float max_moment = 40;
  void clear_max_moment() ;
  float max_moment() const;
  void set_max_moment(float value);

  private:
  float _internal_max_moment() const;
  void _internal_set_max_moment(float value);

  public:
  // float min_moment = 41;
  void clear_min_moment() ;
  float min_moment() const;
  void set_min_moment(float value);

  private:
  float _internal_min_moment() const;
  void _internal_set_min_moment(float value);

  public:
  // float max_neck_moment = 42;
  void clear_max_neck_moment() ;
  float max_neck_moment() const;
  void set_max_neck_moment(float value);

  private:
  float _internal_max_neck_moment() const;
  void _internal_set_max_neck_moment(float value);

  public:
  // float min_neck_moment = 43;
  void clear_min_neck_moment() ;
  float min_neck_moment() const;
  void set_min_neck_moment(float value);

  private:
  float _internal_min_neck_moment() const;
  void _internal_set_min_neck_moment(float value);

  public:
  // float max_neck_angle = 44;
  void clear_max_neck_angle() ;
  float max_neck_angle() const;
  void set_max_neck_angle(float value);

  private:
  float _internal_max_neck_angle() const;
  void _internal_set_max_neck_angle(float value);

  public:
  // float min_neck_angle = 45;
  void clear_min_neck_angle() ;
  float min_neck_angle() const;
  void set_min_neck_angle(float value);

  private:
  float _internal_min_neck_angle() const;
  void _internal_set_min_neck_angle(float value);

  public:
  // float visible_angle = 46;
  void clear_visible_angle() ;
  float visible_angle() const;
  void set_visible_angle(float value);

  private:
  float _internal_visible_angle() const;
  void _internal_set_visible_angle(float value);

  public:
  // float visible_distance = 47;
  void clear_visible_distance() ;
  float visible_distance() const;
  void set_visible_distance(float value);

  private:
  float _internal_visible_distance() const;
  void _internal_set_visible_distance(float value);

  public:
  // float wind_dir = 48;
  void clear_wind_dir() ;
  float wind_dir() const;
  void set_wind_dir(float value);

  private:
  float _internal_wind_dir() const;
  void _internal_set_wind_dir(float value);

  public:
  // float wind_force = 49;
  void clear_wind_force() ;
  float wind_force() const;
  void set_wind_force(float value);

  private:
  float _internal_wind_force() const;
  void _internal_set_wind_force(float value);

  public:
  // float wind_angle = 50;
  void clear_wind_angle() ;
  float wind_angle() const;
  void set_wind_angle(float value);

  private:
  float _internal_wind_angle() const;
  void _internal_set_wind_angle(float value);

  public:
  // float wind_rand = 51;
  void clear_wind_rand() ;
  float wind_rand() const;
  void set_wind_rand(float value);

  private:
  float _internal_wind_rand() const;
  void _internal_set_wind_rand(float value);

  public:
  // float kickable_area = 52;
  void clear_kickable_area() ;
  float kickable_area() const;
  void set_kickable_area(float value);

  private:
  float _internal_kickable_area() const;
  void _internal_set_kickable_area(float value);

  public:
  // float catch_area_l = 53;
  void clear_catch_area_l() ;
  float catch_area_l() const;
  void set_catch_area_l(float value);

  private:
  float _internal_catch_area_l() const;
  void _internal_set_catch_area_l(float value);

  public:
  // float catch_area_w = 54;
  void clear_catch_area_w() ;
  float catch_area_w() const;
  void set_catch_area_w(float value);

  private:
  float _internal_catch_area_w() const;
  void _internal_set_catch_area_w(float value);

  public:
  // float catch_probability = 55;
  void clear_catch_probability() ;
  float catch_probability() const;
  void set_catch_probability(float value);

  private:
  float _internal_catch_probability() const;
  void _internal_set_catch_probability(float value);

  public:
  // bool team_actuator_noise = 22;
  void clear_team_actuator_noise() ;
  bool team_actuator_noise() const;
  void set_team_actuator_noise(bool value);

  private:
  bool _internal_team_actuator_noise() const;
  void _internal_set_team_actuator_noise(bool value);

  public:
  // bool wind_none = 59;
  void clear_wind_none() ;
  bool wind_none() const;
  void set_wind_none(bool value);

  private:
  bool _internal_wind_none() const;
  void _internal_set_wind_none(bool value);

  public:
  // bool use_wind_random = 60;
  void clear_use_wind_random() ;
  bool use_wind_random() const;
  void set_use_wind_random(bool value);

  private:
  bool _internal_use_wind_random() const;
  void _internal_set_use_wind_random(bool value);

  public:
  // bool use_offside = 82;
  void clear_use_offside() ;
  bool use_offside() const;
  void set_use_offside(bool value);

  private:
  bool _internal_use_offside() const;
  void _internal_set_use_offside(bool value);

  public:
  // int32 goalie_max_moves = 56;
  void clear_goalie_max_moves() ;
  ::int32_t goalie_max_moves() const;
  void set_goalie_max_moves(::int32_t value);

  private:
  ::int32_t _internal_goalie_max_moves() const;
  void _internal_set_goalie_max_moves(::int32_t value);

  public:
  // float corner_kick_margin = 57;
  void clear_corner_kick_margin() ;
  float corner_kick_margin() const;
  void set_corner_kick_margin(float value);

  private:
  float _internal_corner_kick_margin() const;
  void _internal_set_corner_kick_margin(float value);

  public:
  // float offside_active_area_size = 58;
  void clear_offside_active_area_size() ;
  float offside_active_area_size() const;
  void set_offside_active_area_size(float value);

  private:
  float _internal_offside_active_area_size() const;
  void _internal_set_offside_active_area_size(float value);

  public:
  // int32 coach_say_count_max = 61;
  void clear_coach_say_count_max() ;
  ::int32_t coach_say_count_max() const;
  void set_coach_say_count_max(::int32_t value);

  private:
  ::int32_t _internal_coach_say_count_max() const;
  void _internal_set_coach_say_count_max(::int32_t value);

  public:
  // int32 coach_say_msg_size = 62;
  void clear_coach_say_msg_size() ;
  ::int32_t coach_say_msg_size() const;
  void set_coach_say_msg_size(::int32_t value);

  private:
  ::int32_t _internal_coach_say_msg_size() const;
  void _internal_set_coach_say_msg_size(::int32_t value);

  public:
  // int32 clang_win_size = 63;
  void clear_clang_win_size() ;
  ::int32_t clang_win_size() const;
  void set_clang_win_size(::int32_t value);

  private:
  ::int32_t _internal_clang_win_size() const;
  void _internal_set_clang_win_size(::int32_t value);

  public:
  // int32 clang_define_win = 64;
  void clear_clang_define_win() ;
  ::int32_t clang_define_win() const;
  void set_clang_define_win(::int32_t value);

  private:
  ::int32_t _internal_clang_define_win() const;
  void _internal_set_clang_define_win(::int32_t value);

  public:
  // int32 clang_meta_win = 65;
  void clear_clang_meta_win() ;
  ::int32_t clang_meta_win() const;
  void set_clang_meta_win(::int32_t value);

  private:
  ::int32_t _internal_clang_meta_win() const;
  void _internal_set_clang_meta_win(::int32_t value);

  public:
  // int32 clang_advice_win = 66;
  void clear_clang_advice_win() ;
  ::int32_t clang_advice_win() const;
  void set_clang_advice_win(::int32_t value);

  private:
  ::int32_t _internal_clang_advice_win() const;
  void _internal_set_clang_advice_win(::int32_t value);

  public:
  // int32 clang_info_win = 67;
  void clear_clang_info_win() ;
  ::int32_t clang_info_win() const;
  void set_clang_info_win(::int32_t value);

  private:
  ::int32_t _internal_clang_info_win() const;
  void _internal_set_clang_info_win(::int32_t value);

  public:
  // int32 clang_mess_delay = 68;
  void clear_clang_mess_delay() ;
  ::int32_t clang_mess_delay() const;
  void set_clang_mess_delay(::int32_t value);

  private:
  ::int32_t _internal_clang_mess_delay() const;
  void _internal_set_clang_mess_delay(::int32_t value);

  public:
  // int32 clang_mess_per_cycle = 69;
  void clear_clang_mess_per_cycle() ;
  ::int32_t clang_mess_per_cycle() const;
  void set_clang_mess_per_cycle(::int32_t value);

  private:
  ::int32_t _internal_clang_mess_per_cycle() const;
  void _internal_set_clang_mess_per_cycle(::int32_t value);

  public:
  // int32 half_time = 70;
  void clear_half_time() ;
  ::int32_t half_time() const;
  void set_half_time(::int32_t value);

  private:
  ::int32_t _internal_half_time() const;
  void _internal_set_half_time(::int32_t value);

  public:
  // int32 simulator_step = 71;
  void clear_simulator_step() ;
  ::int32_t simulator_step() const;
  void set_simulator_step(::int32_t value);

  private:
  ::int32_t _internal_simulator_step() const;
  void _internal_set_simulator_step(::int32_t value);

  public:
  // int32 send_step = 72;
  void clear_send_step() ;
  ::int32_t send_step() const;
  void set_send_step(::int32_t value);

  private:
  ::int32_t _internal_send_step() const;
  void _internal_set_send_step(::int32_t value);

  public:
  // int32 recv_step = 73;
  void clear_recv_step() ;
  ::int32_t recv_step() const;
  void set_recv_step(::int32_t value);

  private:
  ::int32_t _internal_recv_step() const;
  void _internal_set_recv_step(::int32_t value);

  public:
  // int32 sense_body_step = 74;
  void clear_sense_body_step() ;
  ::int32_t sense_body_step() const;
  void set_sense_body_step(::int32_t value);

  private:
  ::int32_t _internal_sense_body_step() const;
  void _internal_set_sense_body_step(::int32_t value);

  public:
  // int32 lcm_step = 75;
  void clear_lcm_step() ;
  ::int32_t lcm_step() const;
  void set_lcm_step(::int32_t value);

  private:
  ::int32_t _internal_lcm_step() const;
  void _internal_set_lcm_step(::int32_t value);

  public:
  // int32 player_say_msg_size = 76;
  void clear_player_say_msg_size() ;
  ::int32_t player_say_msg_size() const;
  void set_player_say_msg_size(::int32_t value);

  private:
  ::int32_t _internal_player_say_msg_size() const;
  void _internal_set_player_say_msg_size(::int32_t value);

  public:
  // int32 player_hear_max = 77;
  void clear_player_hear_max() ;
  ::int32_t player_hear_max() const;
  void set_player_hear_max(::int32_t value);

  private:
  ::int32_t _internal_player_hear_max() const;
  void _internal_set_player_hear_max(::int32_t value);

  public:
  // int32 player_hear_inc = 78;
  void clear_player_hear_inc() ;
  ::int32_t player_hear_inc() const;
  void set_player_hear_inc(::int32_t value);

  private:
  ::int32_t _internal_player_hear_inc() const;
  void _internal_set_player_hear_inc(::int32_t value);

  public:
  // int32 player_hear_decay = 79;
  void clear_player_hear_decay() ;
  ::int32_t player_hear_decay() const;
  void set_player_hear_decay(::int32_t value);

  private:
  ::int32_t _internal_player_hear_decay() const;
  void _internal_set_player_hear_decay(::int32_t value);

  public:
  // int32 catch_ban_cycle = 80;
  void clear_catch_ban_cycle() ;
  ::int32_t catch_ban_cycle() const;
  void set_catch_ban_cycle(::int32_t value);

  private:
  ::int32_t _internal_catch_ban_cycle() const;
  void _internal_set_catch_ban_cycle(::int32_t value);

  public:
  // int32 slow_down_factor = 81;
  void clear_slow_down_factor() ;
  ::int32_t slow_down_factor() const;
  void set_slow_down_factor(::int32_t value);

  private:
  ::int32_t _internal_slow_down_factor() const;
  void _internal_set_slow_down_factor(::int32_t value);

  public:
  // float offside_kick_margin = 84;
  void clear_offside_kick_margin() ;
  float offside_kick_margin() const;
  void set_offside_kick_margin(float value);

  private:
  float _internal_offside_kick_margin() const;
  void _internal_set_offside_kick_margin(float value);

  public:
  // float audio_cut_dist = 85;
  void clear_audio_cut_dist() ;
  float audio_cut_dist() const;
  void set_audio_cut_dist(float value);

  private:
  float _internal_audio_cut_dist() const;
  void _internal_set_audio_cut_dist(float value);

  public:
  // float dist_quantize_step = 86;
  void clear_dist_quantize_step() ;
  float dist_quantize_step() const;
  void set_dist_quantize_step(float value);

  private:
  float _internal_dist_quantize_step() const;
  void _internal_set_dist_quantize_step(float value);

  public:
  // float landmark_dist_quantize_step = 87;
  void clear_landmark_dist_quantize_step() ;
  float landmark_dist_quantize_step() const;
  void set_landmark_dist_quantize_step(float value);

  private:
  float _internal_landmark_dist_quantize_step() const;
  void _internal_set_landmark_dist_quantize_step(float value);

  public:
  // float dir_quantize_step = 88;
  void clear_dir_quantize_step() ;
  float dir_quantize_step() const;
  void set_dir_quantize_step(float value);

  private:
  float _internal_dir_quantize_step() const;
  void _internal_set_dir_quantize_step(float value);

  public:
  // float dist_quantize_step_l = 89;
  void clear_dist_quantize_step_l() ;
  float dist_quantize_step_l() const;
  void set_dist_quantize_step_l(float value);

  private:
  float _internal_dist_quantize_step_l() const;
  void _internal_set_dist_quantize_step_l(float value);

  public:
  // float dist_quantize_step_r = 90;
  void clear_dist_quantize_step_r() ;
  float dist_quantize_step_r() const;
  void set_dist_quantize_step_r(float value);

  private:
  float _internal_dist_quantize_step_r() const;
  void _internal_set_dist_quantize_step_r(float value);

  public:
  // float landmark_dist_quantize_step_l = 91;
  void clear_landmark_dist_quantize_step_l() ;
  float landmark_dist_quantize_step_l() const;
  void set_landmark_dist_quantize_step_l(float value);

  private:
  float _internal_landmark_dist_quantize_step_l() const;
  void _internal_set_landmark_dist_quantize_step_l(float value);

  public:
  // float landmark_dist_quantize_step_r = 92;
  void clear_landmark_dist_quantize_step_r() ;
  float landmark_dist_quantize_step_r() const;
  void set_landmark_dist_quantize_step_r(float value);

  private:
  float _internal_landmark_dist_quantize_step_r() const;
  void _internal_set_landmark_dist_quantize_step_r(float value);

  public:
  // bool kickoff_offside = 83;
  void clear_kickoff_offside() ;
  bool kickoff_offside() const;
  void set_kickoff_offside(bool value);

  private:
  bool _internal_kickoff_offside() const;
  void _internal_set_kickoff_offside(bool value);

  public:
  // bool coach_mode = 95;
  void clear_coach_mode() ;
  bool coach_mode() const;
  void set_coach_mode(bool value);

  private:
  bool _internal_coach_mode() const;
  void _internal_set_coach_mode(bool value);

  public:
  // bool coach_with_referee_mode = 96;
  void clear_coach_with_referee_mode() ;
  bool coach_with_referee_mode() const;
  void set_coach_with_referee_mode(bool value);

  private:
  bool _internal_coach_with_referee_mode() const;
  void _internal_set_coach_with_referee_mode(bool value);

  public:
  // bool use_old_coach_hear = 97;
  void clear_use_old_coach_hear() ;
  bool use_old_coach_hear() const;
  void set_use_old_coach_hear(bool value);

  private:
  bool _internal_use_old_coach_hear() const;
  void _internal_set_use_old_coach_hear(bool value);

  public:
  // float dir_quantize_step_l = 93;
  void clear_dir_quantize_step_l() ;
  float dir_quantize_step_l() const;
  void set_dir_quantize_step_l(float value);

  private:
  float _internal_dir_quantize_step_l() const;
  void _internal_set_dir_quantize_step_l(float value);

  public:
  // float dir_quantize_step_r = 94;
  void clear_dir_quantize_step_r() ;
  float dir_quantize_step_r() const;
  void set_dir_quantize_step_r(float value);

  private:
  float _internal_dir_quantize_step_r() const;
  void _internal_set_dir_quantize_step_r(float value);

  public:
  // float slowness_on_top_for_left_team = 98;
  void clear_slowness_on_top_for_left_team() ;
  float slowness_on_top_for_left_team() const;
  void set_slowness_on_top_for_left_team(float value);

  private:
  float _internal_slowness_on_top_for_left_team() const;
  void _internal_set_slowness_on_top_for_left_team(float value);

  public:
  // float slowness_on_top_for_right_team = 99;
  void clear_slowness_on_top_for_right_team() ;
  float slowness_on_top_for_right_team() const;
  void set_slowness_on_top_for_right_team(float value);

  private:
  float _internal_slowness_on_top_for_right_team() const;
  void _internal_set_slowness_on_top_for_right_team(float value);

  public:
  // int32 start_goal_l = 100;
  void clear_start_goal_l() ;
  ::int32_t start_goal_l() const;
  void set_start_goal_l(::int32_t value);

  private:
  ::int32_t _internal_start_goal_l() const;
  void _internal_set_start_goal_l(::int32_t value);

  public:
  // int32 start_goal_r = 101;
  void clear_start_goal_r() ;
  ::int32_t start_goal_r() const;
  void set_start_goal_r(::int32_t value);

  private:
  ::int32_t _internal_start_goal_r() const;
  void _internal_set_start_goal_r(::int32_t value);

  public:
  // int32 drop_ball_time = 104;
  void clear_drop_ball_time() ;
  ::int32_t drop_ball_time() const;
  void set_drop_ball_time(::int32_t value);

  private:
  ::int32_t _internal_drop_ball_time() const;
  void _internal_set_drop_ball_time(::int32_t value);

  public:
  // bool fullstate_l = 102;
  void clear_fullstate_l() ;
  bool fullstate_l() const;
  void set_fullstate_l(bool value);

  private:
  bool _internal_fullstate_l() const;
  void _internal_set_fullstate_l(bool value);

  public:
  // bool fullstate_r = 103;
  void clear_fullstate_r() ;
  bool fullstate_r() const;
  void set_fullstate_r(bool value);

  private:
  bool _internal_fullstate_r() const;
  void _internal_set_fullstate_r(bool value);

  public:
  // bool synch_mode = 105;
  void clear_synch_mode() ;
  bool synch_mode() const;
  void set_synch_mode(bool value);

  private:
  bool _internal_synch_mode() const;
  void _internal_set_synch_mode(bool value);

  public:
  // bool verbose_mode = 113;
  void clear_verbose_mode() ;
  bool verbose_mode() const;
  void set_verbose_mode(bool value);

  private:
  bool _internal_verbose_mode() const;
  void _internal_set_verbose_mode(bool value);

  public:
  // int32 synch_offset = 106;
  void clear_synch_offset() ;
  ::int32_t synch_offset() const;
  void set_synch_offset(::int32_t value);

  private:
  ::int32_t _internal_synch_offset() const;
  void _internal_set_synch_offset(::int32_t value);

  public:
  // int32 synch_micro_sleep = 107;
  void clear_synch_micro_sleep() ;
  ::int32_t synch_micro_sleep() const;
  void set_synch_micro_sleep(::int32_t value);

  private:
  ::int32_t _internal_synch_micro_sleep() const;
  void _internal_set_synch_micro_sleep(::int32_t value);

  public:
  // int32 point_to_ban = 108;
  void clear_point_to_ban() ;
  ::int32_t point_to_ban() const;
  void set_point_to_ban(::int32_t value);

  private:
  ::int32_t _internal_point_to_ban() const;
  void _internal_set_point_to_ban(::int32_t value);

  public:
  // int32 point_to_duration = 109;
  void clear_point_to_duration() ;
  ::int32_t point_to_duration() const;
  void set_point_to_duration(::int32_t value);

  private:
  ::int32_t _internal_point_to_duration() const;
  void _internal_set_point_to_duration(::int32_t value);

  public:
  // int32 player_port = 110;
  void clear_player_port() ;
  ::int32_t player_port() const;
  void set_player_port(::int32_t value);

  private:
  ::int32_t _internal_player_port() const;
  void _internal_set_player_port(::int32_t value);

  public:
  // int32 trainer_port = 111;
  void clear_trainer_port() ;
  ::int32_t trainer_port() const;
  void set_trainer_port(::int32_t value);

  private:
  ::int32_t _internal_trainer_port() const;
  void _internal_set_trainer_port(::int32_t value);

  public:
  // int32 online_coach_port = 112;
  void clear_online_coach_port() ;
  ::int32_t online_coach_port() const;
  void set_online_coach_port(::int32_t value);

  private:
  ::int32_t _internal_online_coach_port() const;
  void _internal_set_online_coach_port(::int32_t value);

  public:
  // int32 coach_send_vi_step = 114;
  void clear_coach_send_vi_step() ;
  ::int32_t coach_send_vi_step() const;
  void set_coach_send_vi_step(::int32_t value);

  private:
  ::int32_t _internal_coach_send_vi_step() const;
  void _internal_set_coach_send_vi_step(::int32_t value);

  public:
  // bool send_comms = 117;
  void clear_send_comms() ;
  bool send_comms() const;
  void set_send_comms(bool value);

  private:
  bool _internal_send_comms() const;
  void _internal_set_send_comms(bool value);

  public:
  // bool text_logging = 118;
  void clear_text_logging() ;
  bool text_logging() const;
  void set_text_logging(bool value);

  private:
  bool _internal_text_logging() const;
  void _internal_set_text_logging(bool value);

  public:
  // bool game_logging = 119;
  void clear_game_logging() ;
  bool game_logging() const;
  void set_game_logging(bool value);

  private:
  bool _internal_game_logging() const;
  void _internal_set_game_logging(bool value);

  public:
  // bool use_text_log_fixed = 125;
  void clear_use_text_log_fixed() ;
  bool use_text_log_fixed() const;
  void set_use_text_log_fixed(bool value);

  private:
  bool _internal_use_text_log_fixed() const;
  void _internal_set_use_text_log_fixed(bool value);

  public:
  // int32 game_log_version = 120;
  void clear_game_log_version() ;
  ::int32_t game_log_version() const;
  void set_game_log_version(::int32_t value);

  private:
  ::int32_t _internal_game_log_version() const;
  void _internal_set_game_log_version(::int32_t value);

  public:
  // bool use_game_log_fixed = 126;
  void clear_use_game_log_fixed() ;
  bool use_game_log_fixed() const;
  void set_use_game_log_fixed(bool value);

  private:
  bool _internal_use_game_log_fixed() const;
  void _internal_set_use_game_log_fixed(bool value);

  public:
  // bool use_text_log_dated = 127;
  void clear_use_text_log_dated() ;
  bool use_text_log_dated() const;
  void set_use_text_log_dated(bool value);

  private:
  bool _internal_use_text_log_dated() const;
  void _internal_set_use_text_log_dated(bool value);

  public:
  // bool use_game_log_dated = 128;
  void clear_use_game_log_dated() ;
  bool use_game_log_dated() const;
  void set_use_game_log_dated(bool value);

  private:
  bool _internal_use_game_log_dated() const;
  void _internal_set_use_game_log_dated(bool value);

  public:
  // bool log_times = 130;
  void clear_log_times() ;
  bool log_times() const;
  void set_log_times(bool value);

  private:
  bool _internal_log_times() const;
  void _internal_set_log_times(bool value);

  public:
  // int32 text_log_compression = 132;
  void clear_text_log_compression() ;
  ::int32_t text_log_compression() const;
  void set_text_log_compression(::int32_t value);

  private:
  ::int32_t _internal_text_log_compression() const;
  void _internal_set_text_log_compression(::int32_t value);

  public:
  // int32 game_log_compression = 133;
  void clear_game_log_compression() ;
  ::int32_t game_log_compression() const;
  void set_game_log_compression(::int32_t value);

  private:
  ::int32_t _internal_game_log_compression() const;
  void _internal_set_game_log_compression(::int32_t value);

  public:
  // float tackle_dist = 135;
  void clear_tackle_dist() ;
  float tackle_dist() const;
  void set_tackle_dist(float value);

  private:
  float _internal_tackle_dist() const;
  void _internal_set_tackle_dist(float value);

  public:
  // float tackle_back_dist = 136;
  void clear_tackle_back_dist() ;
  float tackle_back_dist() const;
  void set_tackle_back_dist(float value);

  private:
  float _internal_tackle_back_dist() const;
  void _internal_set_tackle_back_dist(float value);

  public:
  // float tackle_width = 137;
  void clear_tackle_width() ;
  float tackle_width() const;
  void set_tackle_width(float value);

  private:
  float _internal_tackle_width() const;
  void _internal_set_tackle_width(float value);

  public:
  // float tackle_exponent = 138;
  void clear_tackle_exponent() ;
  float tackle_exponent() const;
  void set_tackle_exponent(float value);

  private:
  float _internal_tackle_exponent() const;
  void _internal_set_tackle_exponent(float value);

  public:
  // bool record_message = 131;
  void clear_record_message() ;
  bool record_message() const;
  void set_record_message(bool value);

  private:
  bool _internal_record_message() const;
  void _internal_set_record_message(bool value);

  public:
  // bool use_profile = 134;
  void clear_use_profile() ;
  bool use_profile() const;
  void set_use_profile(bool value);

  private:
  bool _internal_use_profile() const;
  void _internal_set_use_profile(bool value);

  public:
  // bool free_kick_faults = 143;
  void clear_free_kick_faults() ;
  bool free_kick_faults() const;
  void set_free_kick_faults(bool value);

  private:
  bool _internal_free_kick_faults() const;
  void _internal_set_free_kick_faults(bool value);

  public:
  // bool back_passes = 144;
  void clear_back_passes() ;
  bool back_passes() const;
  void set_back_passes(bool value);

  private:
  bool _internal_back_passes() const;
  void _internal_set_back_passes(bool value);

  public:
  // int32 tackle_cycles = 139;
  void clear_tackle_cycles() ;
  ::int32_t tackle_cycles() const;
  void set_tackle_cycles(::int32_t value);

  private:
  ::int32_t _internal_tackle_cycles() const;
  void _internal_set_tackle_cycles(::int32_t value);

  public:
  // float tackle_power_rate = 140;
  void clear_tackle_power_rate() ;
  float tackle_power_rate() const;
  void set_tackle_power_rate(float value);

  private:
  float _internal_tackle_power_rate() const;
  void _internal_set_tackle_power_rate(float value);

  public:
  // int32 freeform_wait_period = 141;
  void clear_freeform_wait_period() ;
  ::int32_t freeform_wait_period() const;
  void set_freeform_wait_period(::int32_t value);

  private:
  ::int32_t _internal_freeform_wait_period() const;
  void _internal_set_freeform_wait_period(::int32_t value);

  public:
  // int32 freeform_send_period = 142;
  void clear_freeform_send_period() ;
  ::int32_t freeform_send_period() const;
  void set_freeform_send_period(::int32_t value);

  private:
  ::int32_t _internal_freeform_send_period() const;
  void _internal_set_freeform_send_period(::int32_t value);

  public:
  // float stopped_ball_vel = 146;
  void clear_stopped_ball_vel() ;
  float stopped_ball_vel() const;
  void set_stopped_ball_vel(float value);

  private:
  float _internal_stopped_ball_vel() const;
  void _internal_set_stopped_ball_vel(float value);

  public:
  // int32 max_goal_kicks = 147;
  void clear_max_goal_kicks() ;
  ::int32_t max_goal_kicks() const;
  void set_max_goal_kicks(::int32_t value);

  private:
  ::int32_t _internal_max_goal_kicks() const;
  void _internal_set_max_goal_kicks(::int32_t value);

  public:
  // int32 clang_del_win = 148;
  void clear_clang_del_win() ;
  ::int32_t clang_del_win() const;
  void set_clang_del_win(::int32_t value);

  private:
  ::int32_t _internal_clang_del_win() const;
  void _internal_set_clang_del_win(::int32_t value);

  public:
  // int32 clang_rule_win = 149;
  void clear_clang_rule_win() ;
  ::int32_t clang_rule_win() const;
  void set_clang_rule_win(::int32_t value);

  private:
  ::int32_t _internal_clang_rule_win() const;
  void _internal_set_clang_rule_win(::int32_t value);

  public:
  // int32 kick_off_wait = 151;
  void clear_kick_off_wait() ;
  ::int32_t kick_off_wait() const;
  void set_kick_off_wait(::int32_t value);

  private:
  ::int32_t _internal_kick_off_wait() const;
  void _internal_set_kick_off_wait(::int32_t value);

  public:
  // int32 connect_wait = 152;
  void clear_connect_wait() ;
  ::int32_t connect_wait() const;
  void set_connect_wait(::int32_t value);

  private:
  ::int32_t _internal_connect_wait() const;
  void _internal_set_connect_wait(::int32_t value);

  public:
  // bool proper_goal_kicks = 145;
  void clear_proper_goal_kicks() ;
  bool proper_goal_kicks() const;
  void set_proper_goal_kicks(bool value);

  private:
  bool _internal_proper_goal_kicks() const;
  void _internal_set_proper_goal_kicks(bool value);

  public:
  // bool auto_mode = 150;
  void clear_auto_mode() ;
  bool auto_mode() const;
  void set_auto_mode(bool value);

  private:
  bool _internal_auto_mode() const;
  void _internal_set_auto_mode(bool value);

  public:
  // bool keepaway_mode = 156;
  void clear_keepaway_mode() ;
  bool keepaway_mode() const;
  void set_keepaway_mode(bool value);

  private:
  bool _internal_keepaway_mode() const;
  void _internal_set_keepaway_mode(bool value);

  public:
  // bool keepaway_logging = 159;
  void clear_keepaway_logging() ;
  bool keepaway_logging() const;
  void set_keepaway_logging(bool value);

  private:
  bool _internal_keepaway_logging() const;
  void _internal_set_keepaway_logging(bool value);

  public:
  // int32 game_over_wait = 153;
  void clear_game_over_wait() ;
  ::int32_t game_over_wait() const;
  void set_game_over_wait(::int32_t value);

  private:
  ::int32_t _internal_game_over_wait() const;
  void _internal_set_game_over_wait(::int32_t value);

  public:
  // float keepaway_length = 157;
  void clear_keepaway_length() ;
  float keepaway_length() const;
  void set_keepaway_length(float value);

  private:
  float _internal_keepaway_length() const;
  void _internal_set_keepaway_length(float value);

  public:
  // float keepaway_width = 158;
  void clear_keepaway_width() ;
  float keepaway_width() const;
  void set_keepaway_width(float value);

  private:
  float _internal_keepaway_width() const;
  void _internal_set_keepaway_width(float value);

  public:
  // int32 keepaway_start = 164;
  void clear_keepaway_start() ;
  ::int32_t keepaway_start() const;
  void set_keepaway_start(::int32_t value);

  private:
  ::int32_t _internal_keepaway_start() const;
  void _internal_set_keepaway_start(::int32_t value);

  public:
  // int32 nr_normal_halfs = 165;
  void clear_nr_normal_halfs() ;
  ::int32_t nr_normal_halfs() const;
  void set_nr_normal_halfs(::int32_t value);

  private:
  ::int32_t _internal_nr_normal_halfs() const;
  void _internal_set_nr_normal_halfs(::int32_t value);

  public:
  // int32 nr_extra_halfs = 166;
  void clear_nr_extra_halfs() ;
  ::int32_t nr_extra_halfs() const;
  void set_nr_extra_halfs(::int32_t value);

  private:
  ::int32_t _internal_nr_extra_halfs() const;
  void _internal_set_nr_extra_halfs(::int32_t value);

  public:
  // bool keepaway_log_fixed = 162;
  void clear_keepaway_log_fixed() ;
  bool keepaway_log_fixed() const;
  void set_keepaway_log_fixed(bool value);

  private:
  bool _internal_keepaway_log_fixed() const;
  void _internal_set_keepaway_log_fixed(bool value);

  public:
  // bool keepaway_log_dated = 163;
  void clear_keepaway_log_dated() ;
  bool keepaway_log_dated() const;
  void set_keepaway_log_dated(bool value);

  private:
  bool _internal_keepaway_log_dated() const;
  void _internal_set_keepaway_log_dated(bool value);

  public:
  // bool penalty_shoot_outs = 167;
  void clear_penalty_shoot_outs() ;
  bool penalty_shoot_outs() const;
  void set_penalty_shoot_outs(bool value);

  private:
  bool _internal_penalty_shoot_outs() const;
  void _internal_set_penalty_shoot_outs(bool value);

  public:
  // bool pen_random_winner = 175;
  void clear_pen_random_winner() ;
  bool pen_random_winner() const;
  void set_pen_random_winner(bool value);

  private:
  bool _internal_pen_random_winner() const;
  void _internal_set_pen_random_winner(bool value);

  public:
  // int32 pen_before_setup_wait = 168;
  void clear_pen_before_setup_wait() ;
  ::int32_t pen_before_setup_wait() const;
  void set_pen_before_setup_wait(::int32_t value);

  private:
  ::int32_t _internal_pen_before_setup_wait() const;
  void _internal_set_pen_before_setup_wait(::int32_t value);

  public:
  // int32 pen_setup_wait = 169;
  void clear_pen_setup_wait() ;
  ::int32_t pen_setup_wait() const;
  void set_pen_setup_wait(::int32_t value);

  private:
  ::int32_t _internal_pen_setup_wait() const;
  void _internal_set_pen_setup_wait(::int32_t value);

  public:
  // int32 pen_ready_wait = 170;
  void clear_pen_ready_wait() ;
  ::int32_t pen_ready_wait() const;
  void set_pen_ready_wait(::int32_t value);

  private:
  ::int32_t _internal_pen_ready_wait() const;
  void _internal_set_pen_ready_wait(::int32_t value);

  public:
  // int32 pen_taken_wait = 171;
  void clear_pen_taken_wait() ;
  ::int32_t pen_taken_wait() const;
  void set_pen_taken_wait(::int32_t value);

  private:
  ::int32_t _internal_pen_taken_wait() const;
  void _internal_set_pen_taken_wait(::int32_t value);

  public:
  // int32 pen_nr_kicks = 172;
  void clear_pen_nr_kicks() ;
  ::int32_t pen_nr_kicks() const;
  void set_pen_nr_kicks(::int32_t value);

  private:
  ::int32_t _internal_pen_nr_kicks() const;
  void _internal_set_pen_nr_kicks(::int32_t value);

  public:
  // int32 pen_max_extra_kicks = 173;
  void clear_pen_max_extra_kicks() ;
  ::int32_t pen_max_extra_kicks() const;
  void set_pen_max_extra_kicks(::int32_t value);

  private:
  ::int32_t _internal_pen_max_extra_kicks() const;
  void _internal_set_pen_max_extra_kicks(::int32_t value);

  public:
  // float pen_dist_x = 174;
  void clear_pen_dist_x() ;
  float pen_dist_x() const;
  void set_pen_dist_x(float value);

  private:
  float _internal_pen_dist_x() const;
  void _internal_set_pen_dist_x(float value);

  public:
  // float pen_max_goalie_dist_x = 177;
  void clear_pen_max_goalie_dist_x() ;
  float pen_max_goalie_dist_x() const;
  void set_pen_max_goalie_dist_x(float value);

  private:
  float _internal_pen_max_goalie_dist_x() const;
  void _internal_set_pen_max_goalie_dist_x(float value);

  public:
  // float ball_stuck_area = 180;
  void clear_ball_stuck_area() ;
  float ball_stuck_area() const;
  void set_ball_stuck_area(float value);

  private:
  float _internal_ball_stuck_area() const;
  void _internal_set_ball_stuck_area(float value);

  public:
  // float max_tackle_power = 182;
  void clear_max_tackle_power() ;
  float max_tackle_power() const;
  void set_max_tackle_power(float value);

  private:
  float _internal_max_tackle_power() const;
  void _internal_set_max_tackle_power(float value);

  public:
  // float max_back_tackle_power = 183;
  void clear_max_back_tackle_power() ;
  float max_back_tackle_power() const;
  void set_max_back_tackle_power(float value);

  private:
  float _internal_max_back_tackle_power() const;
  void _internal_set_max_back_tackle_power(float value);

  public:
  // float player_speed_max_min = 184;
  void clear_player_speed_max_min() ;
  float player_speed_max_min() const;
  void set_player_speed_max_min(float value);

  private:
  float _internal_player_speed_max_min() const;
  void _internal_set_player_speed_max_min(float value);

  public:
  // bool pen_allow_mult_kicks = 176;
  void clear_pen_allow_mult_kicks() ;
  bool pen_allow_mult_kicks() const;
  void set_pen_allow_mult_kicks(bool value);

  private:
  bool _internal_pen_allow_mult_kicks() const;
  void _internal_set_pen_allow_mult_kicks(bool value);

  public:
  // bool pen_coach_moves_players = 178;
  void clear_pen_coach_moves_players() ;
  bool pen_coach_moves_players() const;
  void set_pen_coach_moves_players(bool value);

  private:
  bool _internal_pen_coach_moves_players() const;
  void _internal_set_pen_coach_moves_players(bool value);

  public:
  // bool golden_goal = 200;
  void clear_golden_goal() ;
  bool golden_goal() const;
  void set_golden_goal(bool value);

  private:
  bool _internal_golden_goal() const;
  void _internal_set_golden_goal(bool value);

  public:
  // float extra_stamina = 185;
  void clear_extra_stamina() ;
  float extra_stamina() const;
  void set_extra_stamina(float value);

  private:
  float _internal_extra_stamina() const;
  void _internal_set_extra_stamina(float value);

  public:
  // int32 synch_see_offset = 186;
  void clear_synch_see_offset() ;
  ::int32_t synch_see_offset() const;
  void set_synch_see_offset(::int32_t value);

  private:
  ::int32_t _internal_synch_see_offset() const;
  void _internal_set_synch_see_offset(::int32_t value);

  public:
  // int32 extra_half_time = 187;
  void clear_extra_half_time() ;
  ::int32_t extra_half_time() const;
  void set_extra_half_time(::int32_t value);

  private:
  ::int32_t _internal_extra_half_time() const;
  void _internal_set_extra_half_time(::int32_t value);

  public:
  // float stamina_capacity = 188;
  void clear_stamina_capacity() ;
  float stamina_capacity() const;
  void set_stamina_capacity(float value);

  private:
  float _internal_stamina_capacity() const;
  void _internal_set_stamina_capacity(float value);

  public:
  // float max_dash_angle = 189;
  void clear_max_dash_angle() ;
  float max_dash_angle() const;
  void set_max_dash_angle(float value);

  private:
  float _internal_max_dash_angle() const;
  void _internal_set_max_dash_angle(float value);

  public:
  // float min_dash_angle = 190;
  void clear_min_dash_angle() ;
  float min_dash_angle() const;
  void set_min_dash_angle(float value);

  private:
  float _internal_min_dash_angle() const;
  void _internal_set_min_dash_angle(float value);

  public:
  // float dash_angle_step = 191;
  void clear_dash_angle_step() ;
  float dash_angle_step() const;
  void set_dash_angle_step(float value);

  private:
  float _internal_dash_angle_step() const;
  void _internal_set_dash_angle_step(float value);

  public:
  // float side_dash_rate = 192;
  void clear_side_dash_rate() ;
  float side_dash_rate() const;
  void set_side_dash_rate(float value);

  private:
  float _internal_side_dash_rate() const;
  void _internal_set_side_dash_rate(float value);

  public:
  // float back_dash_rate = 193;
  void clear_back_dash_rate() ;
  float back_dash_rate() const;
  void set_back_dash_rate(float value);

  private:
  float _internal_back_dash_rate() const;
  void _internal_set_back_dash_rate(float value);

  public:
  // float max_dash_power = 194;
  void clear_max_dash_power() ;
  float max_dash_power() const;
  void set_max_dash_power(float value);

  private:
  float _internal_max_dash_power() const;
  void _internal_set_max_dash_power(float value);

  public:
  // float min_dash_power = 195;
  void clear_min_dash_power() ;
  float min_dash_power() const;
  void set_min_dash_power(float value);

  private:
  float _internal_min_dash_power() const;
  void _internal_set_min_dash_power(float value);

  public:
  // float tackle_rand_factor = 196;
  void clear_tackle_rand_factor() ;
  float tackle_rand_factor() const;
  void set_tackle_rand_factor(float value);

  private:
  float _internal_tackle_rand_factor() const;
  void _internal_set_tackle_rand_factor(float value);

  public:
  // float foul_detect_probability = 197;
  void clear_foul_detect_probability() ;
  float foul_detect_probability() const;
  void set_foul_detect_probability(float value);

  private:
  float _internal_foul_detect_probability() const;
  void _internal_set_foul_detect_probability(float value);

  public:
  // float foul_exponent = 198;
  void clear_foul_exponent() ;
  float foul_exponent() const;
  void set_foul_exponent(float value);

  private:
  float _internal_foul_exponent() const;
  void _internal_set_foul_exponent(float value);

  public:
  // int32 foul_cycles = 199;
  void clear_foul_cycles() ;
  ::int32_t foul_cycles() const;
  void set_foul_cycles(::int32_t value);

  private:
  ::int32_t _internal_foul_cycles() const;
  void _internal_set_foul_cycles(::int32_t value);

  public:
  // float red_card_probability = 201;
  void clear_red_card_probability() ;
  float red_card_probability() const;
  void set_red_card_probability(float value);

  private:
  float _internal_red_card_probability() const;
  void _internal_set_red_card_probability(float value);

  public:
  // int32 illegal_defense_duration = 202;
  void clear_illegal_defense_duration() ;
  ::int32_t illegal_defense_duration() const;
  void set_illegal_defense_duration(::int32_t value);

  private:
  ::int32_t _internal_illegal_defense_duration() const;
  void _internal_set_illegal_defense_duration(::int32_t value);

  public:
  // int32 illegal_defense_number = 203;
  void clear_illegal_defense_number() ;
  ::int32_t illegal_defense_number() const;
  void set_illegal_defense_number(::int32_t value);

  private:
  ::int32_t _internal_illegal_defense_number() const;
  void _internal_set_illegal_defense_number(::int32_t value);

  public:
  // float illegal_defense_dist_x = 204;
  void clear_illegal_defense_dist_x() ;
  float illegal_defense_dist_x() const;
  void set_illegal_defense_dist_x(float value);

  private:
  float _internal_illegal_defense_dist_x() const;
  void _internal_set_illegal_defense_dist_x(float value);

  public:
  // float illegal_defense_width = 205;
  void clear_illegal_defense_width() ;
  float illegal_defense_width() const;
  void set_illegal_defense_width(float value);

  private:
  float _internal_illegal_defense_width() const;
  void _internal_set_illegal_defense_width(float value);

  public:
  // float max_catch_angle = 208;
  void clear_max_catch_angle() ;
  float max_catch_angle() const;
  void set_max_catch_angle(float value);

  private:
  float _internal_max_catch_angle() const;
  void _internal_set_max_catch_angle(float value);

  public:
  // float min_catch_angle = 209;
  void clear_min_catch_angle() ;
  float min_catch_angle() const;
  void set_min_catch_angle(float value);

  private:
  float _internal_min_catch_angle() const;
  void _internal_set_min_catch_angle(float value);

  public:
  // int32 random_seed = 210;
  void clear_random_seed() ;
  ::int32_t random_seed() const;
  void set_random_seed(::int32_t value);

  private:
  ::int32_t _internal_random_seed() const;
  void _internal_set_random_seed(::int32_t value);

  public:
  // float long_kick_power_factor = 211;
  void clear_long_kick_power_factor() ;
  float long_kick_power_factor() const;
  void set_long_kick_power_factor(float value);

  private:
  float _internal_long_kick_power_factor() const;
  void _internal_set_long_kick_power_factor(float value);

  public:
  // int32 long_kick_delay = 212;
  void clear_long_kick_delay() ;
  ::int32_t long_kick_delay() const;
  void set_long_kick_delay(::int32_t value);

  private:
  ::int32_t _internal_long_kick_delay() const;
  void _internal_set_long_kick_delay(::int32_t value);

  public:
  // int32 max_monitors = 213;
  void clear_max_monitors() ;
  ::int32_t max_monitors() const;
  void set_max_monitors(::int32_t value);

  private:
  ::int32_t _internal_max_monitors() const;
  void _internal_set_max_monitors(::int32_t value);

  public:
  // float catchable_area = 214;
  void clear_catchable_area() ;
  float catchable_area() const;
  void set_catchable_area(float value);

  private:
  float _internal_catchable_area() const;
  void _internal_set_catchable_area(float value);

  public:
  // float real_speed_max = 215;
  void clear_real_speed_max() ;
  float real_speed_max() const;
  void set_real_speed_max(float value);

  private:
  float _internal_real_speed_max() const;
  void _internal_set_real_speed_max(float value);

  public:
  // float pitch_half_length = 216;
  void clear_pitch_half_length() ;
  float pitch_half_length() const;
  void set_pitch_half_length(float value);

  private:
  float _internal_pitch_half_length() const;
  void _internal_set_pitch_half_length(float value);

  public:
  // float pitch_half_width = 217;
  void clear_pitch_half_width() ;
  float pitch_half_width() const;
  void set_pitch_half_width(float value);

  private:
  float _internal_pitch_half_width() const;
  void _internal_set_pitch_half_width(float value);

  public:
  // float our_penalty_area_line_x = 218;
  void clear_our_penalty_area_line_x() ;
  float our_penalty_area_line_x() const;
  void set_our_penalty_area_line_x(float value);

  private:
  float _internal_our_penalty_area_line_x() const;
  void _internal_set_our_penalty_area_line_x(float value);

  public:
  // float their_penalty_area_line_x = 219;
  void clear_their_penalty_area_line_x() ;
  float their_penalty_area_line_x() const;
  void set_their_penalty_area_line_x(float value);

  private:
  float _internal_their_penalty_area_line_x() const;
  void _internal_set_their_penalty_area_line_x(float value);

  public:
  // float penalty_area_half_width = 220;
  void clear_penalty_area_half_width() ;
  float penalty_area_half_width() const;
  void set_penalty_area_half_width(float value);

  private:
  float _internal_penalty_area_half_width() const;
  void _internal_set_penalty_area_half_width(float value);

  public:
  // float penalty_area_length = 221;
  void clear_penalty_area_length() ;
  float penalty_area_length() const;
  void set_penalty_area_length(float value);

  private:
  float _internal_penalty_area_length() const;
  void _internal_set_penalty_area_length(float value);

  public:
  // float goal_width = 222;
  void clear_goal_width() ;
  float goal_width() const;
  void set_goal_width(float value);

  private:
  float _internal_goal_width() const;
  void _internal_set_goal_width(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.ServerParam)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 222, 0,
      463, 29>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr replay_file_;
    ::google::protobuf::internal::ArenaStringPtr landmark_file_;
    ::google::protobuf::internal::ArenaStringPtr text_log_dir_;
    ::google::protobuf::internal::ArenaStringPtr game_log_dir_;
    ::google::protobuf::internal::ArenaStringPtr text_log_fixed_name_;
    ::google::protobuf::internal::ArenaStringPtr game_log_fixed_name_;
    ::google::protobuf::internal::ArenaStringPtr log_date_format_;
    ::google::protobuf::internal::ArenaStringPtr team_l_start_;
    ::google::protobuf::internal::ArenaStringPtr team_r_start_;
    ::google::protobuf::internal::ArenaStringPtr keepaway_log_dir_;
    ::google::protobuf::internal::ArenaStringPtr keepaway_log_fixed_name_;
    ::google::protobuf::internal::ArenaStringPtr module_dir_;
    ::google::protobuf::internal::ArenaStringPtr coach_msg_file_;
    ::google::protobuf::internal::ArenaStringPtr fixed_teamname_l_;
    ::google::protobuf::internal::ArenaStringPtr fixed_teamname_r_;
    int agent_type_;
    float inertia_moment_;
    float player_size_;
    float player_decay_;
    float player_rand_;
    float player_weight_;
    float player_speed_max_;
    float player_accel_max_;
    float stamina_max_;
    float stamina_inc_max_;
    float recover_init_;
    float recover_dec_thr_;
    float recover_min_;
    float recover_dec_;
    float effort_init_;
    float effort_dec_thr_;
    float effort_min_;
    float effort_dec_;
    float effort_inc_thr_;
    float effort_inc_;
    float kick_rand_;
    float player_rand_factor_l_;
    float player_rand_factor_r_;
    float kick_rand_factor_l_;
    float kick_rand_factor_r_;
    float ball_size_;
    float ball_decay_;
    float ball_rand_;
    float ball_weight_;
    float ball_speed_max_;
    float ball_accel_max_;
    float dash_power_rate_;
    float kick_power_rate_;
    float kickable_margin_;
    float control_radius_;
    float control_radius_width_;
    float max_power_;
    float min_power_;
    float max_moment_;
    float min_moment_;
    float max_neck_moment_;
    float min_neck_moment_;
    float max_neck_angle_;
    float min_neck_angle_;
    float visible_angle_;
    float visible_distance_;
    float wind_dir_;
    float wind_force_;
    float wind_angle_;
    float wind_rand_;
    float kickable_area_;
    float catch_area_l_;
    float catch_area_w_;
    float catch_probability_;
    bool team_actuator_noise_;
    bool wind_none_;
    bool use_wind_random_;
    bool use_offside_;
    ::int32_t goalie_max_moves_;
    float corner_kick_margin_;
    float offside_active_area_size_;
    ::int32_t coach_say_count_max_;
    ::int32_t coach_say_msg_size_;
    ::int32_t clang_win_size_;
    ::int32_t clang_define_win_;
    ::int32_t clang_meta_win_;
    ::int32_t clang_advice_win_;
    ::int32_t clang_info_win_;
    ::int32_t clang_mess_delay_;
    ::int32_t clang_mess_per_cycle_;
    ::int32_t half_time_;
    ::int32_t simulator_step_;
    ::int32_t send_step_;
    ::int32_t recv_step_;
    ::int32_t sense_body_step_;
    ::int32_t lcm_step_;
    ::int32_t player_say_msg_size_;
    ::int32_t player_hear_max_;
    ::int32_t player_hear_inc_;
    ::int32_t player_hear_decay_;
    ::int32_t catch_ban_cycle_;
    ::int32_t slow_down_factor_;
    float offside_kick_margin_;
    float audio_cut_dist_;
    float dist_quantize_step_;
    float landmark_dist_quantize_step_;
    float dir_quantize_step_;
    float dist_quantize_step_l_;
    float dist_quantize_step_r_;
    float landmark_dist_quantize_step_l_;
    float landmark_dist_quantize_step_r_;
    bool kickoff_offside_;
    bool coach_mode_;
    bool coach_with_referee_mode_;
    bool use_old_coach_hear_;
    float dir_quantize_step_l_;
    float dir_quantize_step_r_;
    float slowness_on_top_for_left_team_;
    float slowness_on_top_for_right_team_;
    ::int32_t start_goal_l_;
    ::int32_t start_goal_r_;
    ::int32_t drop_ball_time_;
    bool fullstate_l_;
    bool fullstate_r_;
    bool synch_mode_;
    bool verbose_mode_;
    ::int32_t synch_offset_;
    ::int32_t synch_micro_sleep_;
    ::int32_t point_to_ban_;
    ::int32_t point_to_duration_;
    ::int32_t player_port_;
    ::int32_t trainer_port_;
    ::int32_t online_coach_port_;
    ::int32_t coach_send_vi_step_;
    bool send_comms_;
    bool text_logging_;
    bool game_logging_;
    bool use_text_log_fixed_;
    ::int32_t game_log_version_;
    bool use_game_log_fixed_;
    bool use_text_log_dated_;
    bool use_game_log_dated_;
    bool log_times_;
    ::int32_t text_log_compression_;
    ::int32_t game_log_compression_;
    float tackle_dist_;
    float tackle_back_dist_;
    float tackle_width_;
    float tackle_exponent_;
    bool record_message_;
    bool use_profile_;
    bool free_kick_faults_;
    bool back_passes_;
    ::int32_t tackle_cycles_;
    float tackle_power_rate_;
    ::int32_t freeform_wait_period_;
    ::int32_t freeform_send_period_;
    float stopped_ball_vel_;
    ::int32_t max_goal_kicks_;
    ::int32_t clang_del_win_;
    ::int32_t clang_rule_win_;
    ::int32_t kick_off_wait_;
    ::int32_t connect_wait_;
    bool proper_goal_kicks_;
    bool auto_mode_;
    bool keepaway_mode_;
    bool keepaway_logging_;
    ::int32_t game_over_wait_;
    float keepaway_length_;
    float keepaway_width_;
    ::int32_t keepaway_start_;
    ::int32_t nr_normal_halfs_;
    ::int32_t nr_extra_halfs_;
    bool keepaway_log_fixed_;
    bool keepaway_log_dated_;
    bool penalty_shoot_outs_;
    bool pen_random_winner_;
    ::int32_t pen_before_setup_wait_;
    ::int32_t pen_setup_wait_;
    ::int32_t pen_ready_wait_;
    ::int32_t pen_taken_wait_;
    ::int32_t pen_nr_kicks_;
    ::int32_t pen_max_extra_kicks_;
    float pen_dist_x_;
    float pen_max_goalie_dist_x_;
    float ball_stuck_area_;
    float max_tackle_power_;
    float max_back_tackle_power_;
    float player_speed_max_min_;
    bool pen_allow_mult_kicks_;
    bool pen_coach_moves_players_;
    bool golden_goal_;
    float extra_stamina_;
    ::int32_t synch_see_offset_;
    ::int32_t extra_half_time_;
    float stamina_capacity_;
    float max_dash_angle_;
    float min_dash_angle_;
    float dash_angle_step_;
    float side_dash_rate_;
    float back_dash_rate_;
    float max_dash_power_;
    float min_dash_power_;
    float tackle_rand_factor_;
    float foul_detect_probability_;
    float foul_exponent_;
    ::int32_t foul_cycles_;
    float red_card_probability_;
    ::int32_t illegal_defense_duration_;
    ::int32_t illegal_defense_number_;
    float illegal_defense_dist_x_;
    float illegal_defense_width_;
    float max_catch_angle_;
    float min_catch_angle_;
    ::int32_t random_seed_;
    float long_kick_power_factor_;
    ::int32_t long_kick_delay_;
    ::int32_t max_monitors_;
    float catchable_area_;
    float real_speed_max_;
    float pitch_half_length_;
    float pitch_half_width_;
    float our_penalty_area_line_x_;
    float their_penalty_area_line_x_;
    float penalty_area_half_width_;
    float penalty_area_length_;
    float goal_width_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class RecoveryMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.RecoveryMessage) */ {
 public:
  inline RecoveryMessage() : RecoveryMessage(nullptr) {}
  ~RecoveryMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RecoveryMessage(::google::protobuf::internal::ConstantInitialized);

  inline RecoveryMessage(const RecoveryMessage& from)
      : RecoveryMessage(nullptr, from) {}
  RecoveryMessage(RecoveryMessage&& from) noexcept
    : RecoveryMessage() {
    *this = ::std::move(from);
  }

  inline RecoveryMessage& operator=(const RecoveryMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoveryMessage& operator=(RecoveryMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecoveryMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecoveryMessage* internal_default_instance() {
    return reinterpret_cast<const RecoveryMessage*>(
               &_RecoveryMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RecoveryMessage& a, RecoveryMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RecoveryMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecoveryMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecoveryMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecoveryMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecoveryMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RecoveryMessage& from) {
    RecoveryMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecoveryMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.RecoveryMessage";
  }
  protected:
  explicit RecoveryMessage(::google::protobuf::Arena* arena);
  RecoveryMessage(::google::protobuf::Arena* arena, const RecoveryMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecoveryFieldNumber = 1,
  };
  // float recovery = 1;
  void clear_recovery() ;
  float recovery() const;
  void set_recovery(float value);

  private:
  float _internal_recovery() const;
  void _internal_set_recovery(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.RecoveryMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float recovery_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PointToOf final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.PointToOf) */ {
 public:
  inline PointToOf() : PointToOf(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointToOf(::google::protobuf::internal::ConstantInitialized);

  inline PointToOf(const PointToOf& from)
      : PointToOf(nullptr, from) {}
  PointToOf(PointToOf&& from) noexcept
    : PointToOf() {
    *this = ::std::move(from);
  }

  inline PointToOf& operator=(const PointToOf& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointToOf& operator=(PointToOf&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointToOf& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointToOf* internal_default_instance() {
    return reinterpret_cast<const PointToOf*>(
               &_PointToOf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(PointToOf& a, PointToOf& b) {
    a.Swap(&b);
  }
  inline void Swap(PointToOf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointToOf* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointToOf* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointToOf>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PointToOf& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PointToOf& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PointToOf";
  }
  protected:
  explicit PointToOf(::google::protobuf::Arena* arena);
  PointToOf(::google::protobuf::Arena* arena, const PointToOf& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.PointToOf)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PointTo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.PointTo) */ {
 public:
  inline PointTo() : PointTo(nullptr) {}
  ~PointTo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PointTo(::google::protobuf::internal::ConstantInitialized);

  inline PointTo(const PointTo& from)
      : PointTo(nullptr, from) {}
  PointTo(PointTo&& from) noexcept
    : PointTo() {
    *this = ::std::move(from);
  }

  inline PointTo& operator=(const PointTo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointTo& operator=(PointTo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointTo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointTo* internal_default_instance() {
    return reinterpret_cast<const PointTo*>(
               &_PointTo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(PointTo& a, PointTo& b) {
    a.Swap(&b);
  }
  inline void Swap(PointTo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointTo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointTo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointTo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PointTo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PointTo& from) {
    PointTo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PointTo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PointTo";
  }
  protected:
  explicit PointTo(::google::protobuf::Arena* arena);
  PointTo(::google::protobuf::Arena* arena, const PointTo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.PointTo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float x_;
    float y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PlayerType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.PlayerType) */ {
 public:
  inline PlayerType() : PlayerType(nullptr) {}
  ~PlayerType() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerType(::google::protobuf::internal::ConstantInitialized);

  inline PlayerType(const PlayerType& from)
      : PlayerType(nullptr, from) {}
  PlayerType(PlayerType&& from) noexcept
    : PlayerType() {
    *this = ::std::move(from);
  }

  inline PlayerType& operator=(const PlayerType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerType& operator=(PlayerType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerType& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerType* internal_default_instance() {
    return reinterpret_cast<const PlayerType*>(
               &_PlayerType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(PlayerType& a, PlayerType& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerType& from) {
    PlayerType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerType* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PlayerType";
  }
  protected:
  explicit PlayerType(::google::protobuf::Arena* arena);
  PlayerType(::google::protobuf::Arena* arena, const PlayerType& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kStaminaIncMaxFieldNumber = 3,
    kPlayerDecayFieldNumber = 4,
    kInertiaMomentFieldNumber = 5,
    kDashPowerRateFieldNumber = 6,
    kPlayerSizeFieldNumber = 7,
    kKickableMarginFieldNumber = 8,
    kKickRandFieldNumber = 9,
    kExtraStaminaFieldNumber = 10,
    kEffortMaxFieldNumber = 11,
    kEffortMinFieldNumber = 12,
    kKickPowerRateFieldNumber = 13,
    kFoulDetectProbabilityFieldNumber = 14,
    kCatchableAreaLStretchFieldNumber = 15,
    kUnumFarLengthFieldNumber = 16,
    kUnumTooFarLengthFieldNumber = 17,
    kTeamFarLengthFieldNumber = 18,
    kTeamTooFarLengthFieldNumber = 19,
    kPlayerMaxObservationLengthFieldNumber = 20,
    kBallVelFarLengthFieldNumber = 21,
    kBallVelTooFarLengthFieldNumber = 22,
    kBallMaxObservationLengthFieldNumber = 23,
    kFlagChgFarLengthFieldNumber = 24,
    kFlagChgTooFarLengthFieldNumber = 25,
    kFlagMaxObservationLengthFieldNumber = 26,
    kKickableAreaFieldNumber = 27,
    kReliableCatchableDistFieldNumber = 28,
    kMaxCatchableDistFieldNumber = 29,
    kRealSpeedMaxFieldNumber = 30,
    kPlayerSpeedMax2FieldNumber = 31,
    kRealSpeedMax2FieldNumber = 32,
    kCyclesToReachMaxSpeedFieldNumber = 33,
    kPlayerSpeedMaxFieldNumber = 34,
  };
  // .protos.AgentType agent_type = 1;
  void clear_agent_type() ;
  ::protos::AgentType agent_type() const;
  void set_agent_type(::protos::AgentType value);

  private:
  ::protos::AgentType _internal_agent_type() const;
  void _internal_set_agent_type(::protos::AgentType value);

  public:
  // int32 id = 2;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // float stamina_inc_max = 3;
  void clear_stamina_inc_max() ;
  float stamina_inc_max() const;
  void set_stamina_inc_max(float value);

  private:
  float _internal_stamina_inc_max() const;
  void _internal_set_stamina_inc_max(float value);

  public:
  // float player_decay = 4;
  void clear_player_decay() ;
  float player_decay() const;
  void set_player_decay(float value);

  private:
  float _internal_player_decay() const;
  void _internal_set_player_decay(float value);

  public:
  // float inertia_moment = 5;
  void clear_inertia_moment() ;
  float inertia_moment() const;
  void set_inertia_moment(float value);

  private:
  float _internal_inertia_moment() const;
  void _internal_set_inertia_moment(float value);

  public:
  // float dash_power_rate = 6;
  void clear_dash_power_rate() ;
  float dash_power_rate() const;
  void set_dash_power_rate(float value);

  private:
  float _internal_dash_power_rate() const;
  void _internal_set_dash_power_rate(float value);

  public:
  // float player_size = 7;
  void clear_player_size() ;
  float player_size() const;
  void set_player_size(float value);

  private:
  float _internal_player_size() const;
  void _internal_set_player_size(float value);

  public:
  // float kickable_margin = 8;
  void clear_kickable_margin() ;
  float kickable_margin() const;
  void set_kickable_margin(float value);

  private:
  float _internal_kickable_margin() const;
  void _internal_set_kickable_margin(float value);

  public:
  // float kick_rand = 9;
  void clear_kick_rand() ;
  float kick_rand() const;
  void set_kick_rand(float value);

  private:
  float _internal_kick_rand() const;
  void _internal_set_kick_rand(float value);

  public:
  // float extra_stamina = 10;
  void clear_extra_stamina() ;
  float extra_stamina() const;
  void set_extra_stamina(float value);

  private:
  float _internal_extra_stamina() const;
  void _internal_set_extra_stamina(float value);

  public:
  // float effort_max = 11;
  void clear_effort_max() ;
  float effort_max() const;
  void set_effort_max(float value);

  private:
  float _internal_effort_max() const;
  void _internal_set_effort_max(float value);

  public:
  // float effort_min = 12;
  void clear_effort_min() ;
  float effort_min() const;
  void set_effort_min(float value);

  private:
  float _internal_effort_min() const;
  void _internal_set_effort_min(float value);

  public:
  // float kick_power_rate = 13;
  void clear_kick_power_rate() ;
  float kick_power_rate() const;
  void set_kick_power_rate(float value);

  private:
  float _internal_kick_power_rate() const;
  void _internal_set_kick_power_rate(float value);

  public:
  // float foul_detect_probability = 14;
  void clear_foul_detect_probability() ;
  float foul_detect_probability() const;
  void set_foul_detect_probability(float value);

  private:
  float _internal_foul_detect_probability() const;
  void _internal_set_foul_detect_probability(float value);

  public:
  // float catchable_area_l_stretch = 15;
  void clear_catchable_area_l_stretch() ;
  float catchable_area_l_stretch() const;
  void set_catchable_area_l_stretch(float value);

  private:
  float _internal_catchable_area_l_stretch() const;
  void _internal_set_catchable_area_l_stretch(float value);

  public:
  // float unum_far_length = 16;
  void clear_unum_far_length() ;
  float unum_far_length() const;
  void set_unum_far_length(float value);

  private:
  float _internal_unum_far_length() const;
  void _internal_set_unum_far_length(float value);

  public:
  // float unum_too_far_length = 17;
  void clear_unum_too_far_length() ;
  float unum_too_far_length() const;
  void set_unum_too_far_length(float value);

  private:
  float _internal_unum_too_far_length() const;
  void _internal_set_unum_too_far_length(float value);

  public:
  // float team_far_length = 18;
  void clear_team_far_length() ;
  float team_far_length() const;
  void set_team_far_length(float value);

  private:
  float _internal_team_far_length() const;
  void _internal_set_team_far_length(float value);

  public:
  // float team_too_far_length = 19;
  void clear_team_too_far_length() ;
  float team_too_far_length() const;
  void set_team_too_far_length(float value);

  private:
  float _internal_team_too_far_length() const;
  void _internal_set_team_too_far_length(float value);

  public:
  // float player_max_observation_length = 20;
  void clear_player_max_observation_length() ;
  float player_max_observation_length() const;
  void set_player_max_observation_length(float value);

  private:
  float _internal_player_max_observation_length() const;
  void _internal_set_player_max_observation_length(float value);

  public:
  // float ball_vel_far_length = 21;
  void clear_ball_vel_far_length() ;
  float ball_vel_far_length() const;
  void set_ball_vel_far_length(float value);

  private:
  float _internal_ball_vel_far_length() const;
  void _internal_set_ball_vel_far_length(float value);

  public:
  // float ball_vel_too_far_length = 22;
  void clear_ball_vel_too_far_length() ;
  float ball_vel_too_far_length() const;
  void set_ball_vel_too_far_length(float value);

  private:
  float _internal_ball_vel_too_far_length() const;
  void _internal_set_ball_vel_too_far_length(float value);

  public:
  // float ball_max_observation_length = 23;
  void clear_ball_max_observation_length() ;
  float ball_max_observation_length() const;
  void set_ball_max_observation_length(float value);

  private:
  float _internal_ball_max_observation_length() const;
  void _internal_set_ball_max_observation_length(float value);

  public:
  // float flag_chg_far_length = 24;
  void clear_flag_chg_far_length() ;
  float flag_chg_far_length() const;
  void set_flag_chg_far_length(float value);

  private:
  float _internal_flag_chg_far_length() const;
  void _internal_set_flag_chg_far_length(float value);

  public:
  // float flag_chg_too_far_length = 25;
  void clear_flag_chg_too_far_length() ;
  float flag_chg_too_far_length() const;
  void set_flag_chg_too_far_length(float value);

  private:
  float _internal_flag_chg_too_far_length() const;
  void _internal_set_flag_chg_too_far_length(float value);

  public:
  // float flag_max_observation_length = 26;
  void clear_flag_max_observation_length() ;
  float flag_max_observation_length() const;
  void set_flag_max_observation_length(float value);

  private:
  float _internal_flag_max_observation_length() const;
  void _internal_set_flag_max_observation_length(float value);

  public:
  // float kickable_area = 27;
  void clear_kickable_area() ;
  float kickable_area() const;
  void set_kickable_area(float value);

  private:
  float _internal_kickable_area() const;
  void _internal_set_kickable_area(float value);

  public:
  // float reliable_catchable_dist = 28;
  void clear_reliable_catchable_dist() ;
  float reliable_catchable_dist() const;
  void set_reliable_catchable_dist(float value);

  private:
  float _internal_reliable_catchable_dist() const;
  void _internal_set_reliable_catchable_dist(float value);

  public:
  // float max_catchable_dist = 29;
  void clear_max_catchable_dist() ;
  float max_catchable_dist() const;
  void set_max_catchable_dist(float value);

  private:
  float _internal_max_catchable_dist() const;
  void _internal_set_max_catchable_dist(float value);

  public:
  // float real_speed_max = 30;
  void clear_real_speed_max() ;
  float real_speed_max() const;
  void set_real_speed_max(float value);

  private:
  float _internal_real_speed_max() const;
  void _internal_set_real_speed_max(float value);

  public:
  // float player_speed_max2 = 31;
  void clear_player_speed_max2() ;
  float player_speed_max2() const;
  void set_player_speed_max2(float value);

  private:
  float _internal_player_speed_max2() const;
  void _internal_set_player_speed_max2(float value);

  public:
  // float real_speed_max2 = 32;
  void clear_real_speed_max2() ;
  float real_speed_max2() const;
  void set_real_speed_max2(float value);

  private:
  float _internal_real_speed_max2() const;
  void _internal_set_real_speed_max2(float value);

  public:
  // int32 cycles_to_reach_max_speed = 33;
  void clear_cycles_to_reach_max_speed() ;
  ::int32_t cycles_to_reach_max_speed() const;
  void set_cycles_to_reach_max_speed(::int32_t value);

  private:
  ::int32_t _internal_cycles_to_reach_max_speed() const;
  void _internal_set_cycles_to_reach_max_speed(::int32_t value);

  public:
  // float player_speed_max = 34;
  void clear_player_speed_max() ;
  float player_speed_max() const;
  void set_player_speed_max(float value);

  private:
  float _internal_player_speed_max() const;
  void _internal_set_player_speed_max(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.PlayerType)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 34, 0,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int agent_type_;
    ::int32_t id_;
    float stamina_inc_max_;
    float player_decay_;
    float inertia_moment_;
    float dash_power_rate_;
    float player_size_;
    float kickable_margin_;
    float kick_rand_;
    float extra_stamina_;
    float effort_max_;
    float effort_min_;
    float kick_power_rate_;
    float foul_detect_probability_;
    float catchable_area_l_stretch_;
    float unum_far_length_;
    float unum_too_far_length_;
    float team_far_length_;
    float team_too_far_length_;
    float player_max_observation_length_;
    float ball_vel_far_length_;
    float ball_vel_too_far_length_;
    float ball_max_observation_length_;
    float flag_chg_far_length_;
    float flag_chg_too_far_length_;
    float flag_max_observation_length_;
    float kickable_area_;
    float reliable_catchable_dist_;
    float max_catchable_dist_;
    float real_speed_max_;
    float player_speed_max2_;
    float real_speed_max2_;
    ::int32_t cycles_to_reach_max_speed_;
    float player_speed_max_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PlayerParam final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.PlayerParam) */ {
 public:
  inline PlayerParam() : PlayerParam(nullptr) {}
  ~PlayerParam() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerParam(::google::protobuf::internal::ConstantInitialized);

  inline PlayerParam(const PlayerParam& from)
      : PlayerParam(nullptr, from) {}
  PlayerParam(PlayerParam&& from) noexcept
    : PlayerParam() {
    *this = ::std::move(from);
  }

  inline PlayerParam& operator=(const PlayerParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerParam& operator=(PlayerParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerParam* internal_default_instance() {
    return reinterpret_cast<const PlayerParam*>(
               &_PlayerParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(PlayerParam& a, PlayerParam& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerParam* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerParam* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerParam>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerParam& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerParam& from) {
    PlayerParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerParam* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PlayerParam";
  }
  protected:
  explicit PlayerParam(::google::protobuf::Arena* arena);
  PlayerParam(::google::protobuf::Arena* arena, const PlayerParam& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentTypeFieldNumber = 1,
    kPlayerTypesFieldNumber = 2,
    kSubsMaxFieldNumber = 3,
    kPtMaxFieldNumber = 4,
    kAllowMultDefaultTypeFieldNumber = 5,
    kPlayerSpeedMaxDeltaMinFieldNumber = 6,
    kPlayerSpeedMaxDeltaMaxFieldNumber = 7,
    kStaminaIncMaxDeltaFactorFieldNumber = 8,
    kPlayerDecayDeltaMinFieldNumber = 9,
    kPlayerDecayDeltaMaxFieldNumber = 10,
    kInertiaMomentDeltaFactorFieldNumber = 11,
    kDashPowerRateDeltaMinFieldNumber = 12,
    kDashPowerRateDeltaMaxFieldNumber = 13,
    kPlayerSizeDeltaFactorFieldNumber = 14,
    kKickableMarginDeltaMinFieldNumber = 15,
    kKickableMarginDeltaMaxFieldNumber = 16,
    kKickRandDeltaFactorFieldNumber = 17,
    kExtraStaminaDeltaMinFieldNumber = 18,
    kExtraStaminaDeltaMaxFieldNumber = 19,
    kEffortMaxDeltaFactorFieldNumber = 20,
    kEffortMinDeltaFactorFieldNumber = 21,
    kRandomSeedFieldNumber = 22,
    kNewDashPowerRateDeltaMinFieldNumber = 23,
    kNewDashPowerRateDeltaMaxFieldNumber = 24,
    kNewStaminaIncMaxDeltaFactorFieldNumber = 25,
    kKickPowerRateDeltaMinFieldNumber = 26,
    kKickPowerRateDeltaMaxFieldNumber = 27,
    kFoulDetectProbabilityDeltaFactorFieldNumber = 28,
    kCatchableAreaLStretchMinFieldNumber = 29,
    kCatchableAreaLStretchMaxFieldNumber = 30,
  };
  // .protos.AgentType agent_type = 1;
  void clear_agent_type() ;
  ::protos::AgentType agent_type() const;
  void set_agent_type(::protos::AgentType value);

  private:
  ::protos::AgentType _internal_agent_type() const;
  void _internal_set_agent_type(::protos::AgentType value);

  public:
  // int32 player_types = 2;
  void clear_player_types() ;
  ::int32_t player_types() const;
  void set_player_types(::int32_t value);

  private:
  ::int32_t _internal_player_types() const;
  void _internal_set_player_types(::int32_t value);

  public:
  // int32 subs_max = 3;
  void clear_subs_max() ;
  ::int32_t subs_max() const;
  void set_subs_max(::int32_t value);

  private:
  ::int32_t _internal_subs_max() const;
  void _internal_set_subs_max(::int32_t value);

  public:
  // int32 pt_max = 4;
  void clear_pt_max() ;
  ::int32_t pt_max() const;
  void set_pt_max(::int32_t value);

  private:
  ::int32_t _internal_pt_max() const;
  void _internal_set_pt_max(::int32_t value);

  public:
  // bool allow_mult_default_type = 5;
  void clear_allow_mult_default_type() ;
  bool allow_mult_default_type() const;
  void set_allow_mult_default_type(bool value);

  private:
  bool _internal_allow_mult_default_type() const;
  void _internal_set_allow_mult_default_type(bool value);

  public:
  // float player_speed_max_delta_min = 6;
  void clear_player_speed_max_delta_min() ;
  float player_speed_max_delta_min() const;
  void set_player_speed_max_delta_min(float value);

  private:
  float _internal_player_speed_max_delta_min() const;
  void _internal_set_player_speed_max_delta_min(float value);

  public:
  // float player_speed_max_delta_max = 7;
  void clear_player_speed_max_delta_max() ;
  float player_speed_max_delta_max() const;
  void set_player_speed_max_delta_max(float value);

  private:
  float _internal_player_speed_max_delta_max() const;
  void _internal_set_player_speed_max_delta_max(float value);

  public:
  // float stamina_inc_max_delta_factor = 8;
  void clear_stamina_inc_max_delta_factor() ;
  float stamina_inc_max_delta_factor() const;
  void set_stamina_inc_max_delta_factor(float value);

  private:
  float _internal_stamina_inc_max_delta_factor() const;
  void _internal_set_stamina_inc_max_delta_factor(float value);

  public:
  // float player_decay_delta_min = 9;
  void clear_player_decay_delta_min() ;
  float player_decay_delta_min() const;
  void set_player_decay_delta_min(float value);

  private:
  float _internal_player_decay_delta_min() const;
  void _internal_set_player_decay_delta_min(float value);

  public:
  // float player_decay_delta_max = 10;
  void clear_player_decay_delta_max() ;
  float player_decay_delta_max() const;
  void set_player_decay_delta_max(float value);

  private:
  float _internal_player_decay_delta_max() const;
  void _internal_set_player_decay_delta_max(float value);

  public:
  // float inertia_moment_delta_factor = 11;
  void clear_inertia_moment_delta_factor() ;
  float inertia_moment_delta_factor() const;
  void set_inertia_moment_delta_factor(float value);

  private:
  float _internal_inertia_moment_delta_factor() const;
  void _internal_set_inertia_moment_delta_factor(float value);

  public:
  // float dash_power_rate_delta_min = 12;
  void clear_dash_power_rate_delta_min() ;
  float dash_power_rate_delta_min() const;
  void set_dash_power_rate_delta_min(float value);

  private:
  float _internal_dash_power_rate_delta_min() const;
  void _internal_set_dash_power_rate_delta_min(float value);

  public:
  // float dash_power_rate_delta_max = 13;
  void clear_dash_power_rate_delta_max() ;
  float dash_power_rate_delta_max() const;
  void set_dash_power_rate_delta_max(float value);

  private:
  float _internal_dash_power_rate_delta_max() const;
  void _internal_set_dash_power_rate_delta_max(float value);

  public:
  // float player_size_delta_factor = 14;
  void clear_player_size_delta_factor() ;
  float player_size_delta_factor() const;
  void set_player_size_delta_factor(float value);

  private:
  float _internal_player_size_delta_factor() const;
  void _internal_set_player_size_delta_factor(float value);

  public:
  // float kickable_margin_delta_min = 15;
  void clear_kickable_margin_delta_min() ;
  float kickable_margin_delta_min() const;
  void set_kickable_margin_delta_min(float value);

  private:
  float _internal_kickable_margin_delta_min() const;
  void _internal_set_kickable_margin_delta_min(float value);

  public:
  // float kickable_margin_delta_max = 16;
  void clear_kickable_margin_delta_max() ;
  float kickable_margin_delta_max() const;
  void set_kickable_margin_delta_max(float value);

  private:
  float _internal_kickable_margin_delta_max() const;
  void _internal_set_kickable_margin_delta_max(float value);

  public:
  // float kick_rand_delta_factor = 17;
  void clear_kick_rand_delta_factor() ;
  float kick_rand_delta_factor() const;
  void set_kick_rand_delta_factor(float value);

  private:
  float _internal_kick_rand_delta_factor() const;
  void _internal_set_kick_rand_delta_factor(float value);

  public:
  // float extra_stamina_delta_min = 18;
  void clear_extra_stamina_delta_min() ;
  float extra_stamina_delta_min() const;
  void set_extra_stamina_delta_min(float value);

  private:
  float _internal_extra_stamina_delta_min() const;
  void _internal_set_extra_stamina_delta_min(float value);

  public:
  // float extra_stamina_delta_max = 19;
  void clear_extra_stamina_delta_max() ;
  float extra_stamina_delta_max() const;
  void set_extra_stamina_delta_max(float value);

  private:
  float _internal_extra_stamina_delta_max() const;
  void _internal_set_extra_stamina_delta_max(float value);

  public:
  // float effort_max_delta_factor = 20;
  void clear_effort_max_delta_factor() ;
  float effort_max_delta_factor() const;
  void set_effort_max_delta_factor(float value);

  private:
  float _internal_effort_max_delta_factor() const;
  void _internal_set_effort_max_delta_factor(float value);

  public:
  // float effort_min_delta_factor = 21;
  void clear_effort_min_delta_factor() ;
  float effort_min_delta_factor() const;
  void set_effort_min_delta_factor(float value);

  private:
  float _internal_effort_min_delta_factor() const;
  void _internal_set_effort_min_delta_factor(float value);

  public:
  // int32 random_seed = 22;
  void clear_random_seed() ;
  ::int32_t random_seed() const;
  void set_random_seed(::int32_t value);

  private:
  ::int32_t _internal_random_seed() const;
  void _internal_set_random_seed(::int32_t value);

  public:
  // float new_dash_power_rate_delta_min = 23;
  void clear_new_dash_power_rate_delta_min() ;
  float new_dash_power_rate_delta_min() const;
  void set_new_dash_power_rate_delta_min(float value);

  private:
  float _internal_new_dash_power_rate_delta_min() const;
  void _internal_set_new_dash_power_rate_delta_min(float value);

  public:
  // float new_dash_power_rate_delta_max = 24;
  void clear_new_dash_power_rate_delta_max() ;
  float new_dash_power_rate_delta_max() const;
  void set_new_dash_power_rate_delta_max(float value);

  private:
  float _internal_new_dash_power_rate_delta_max() const;
  void _internal_set_new_dash_power_rate_delta_max(float value);

  public:
  // float new_stamina_inc_max_delta_factor = 25;
  void clear_new_stamina_inc_max_delta_factor() ;
  float new_stamina_inc_max_delta_factor() const;
  void set_new_stamina_inc_max_delta_factor(float value);

  private:
  float _internal_new_stamina_inc_max_delta_factor() const;
  void _internal_set_new_stamina_inc_max_delta_factor(float value);

  public:
  // float kick_power_rate_delta_min = 26;
  void clear_kick_power_rate_delta_min() ;
  float kick_power_rate_delta_min() const;
  void set_kick_power_rate_delta_min(float value);

  private:
  float _internal_kick_power_rate_delta_min() const;
  void _internal_set_kick_power_rate_delta_min(float value);

  public:
  // float kick_power_rate_delta_max = 27;
  void clear_kick_power_rate_delta_max() ;
  float kick_power_rate_delta_max() const;
  void set_kick_power_rate_delta_max(float value);

  private:
  float _internal_kick_power_rate_delta_max() const;
  void _internal_set_kick_power_rate_delta_max(float value);

  public:
  // float foul_detect_probability_delta_factor = 28;
  void clear_foul_detect_probability_delta_factor() ;
  float foul_detect_probability_delta_factor() const;
  void set_foul_detect_probability_delta_factor(float value);

  private:
  float _internal_foul_detect_probability_delta_factor() const;
  void _internal_set_foul_detect_probability_delta_factor(float value);

  public:
  // float catchable_area_l_stretch_min = 29;
  void clear_catchable_area_l_stretch_min() ;
  float catchable_area_l_stretch_min() const;
  void set_catchable_area_l_stretch_min(float value);

  private:
  float _internal_catchable_area_l_stretch_min() const;
  void _internal_set_catchable_area_l_stretch_min(float value);

  public:
  // float catchable_area_l_stretch_max = 30;
  void clear_catchable_area_l_stretch_max() ;
  float catchable_area_l_stretch_max() const;
  void set_catchable_area_l_stretch_max(float value);

  private:
  float _internal_catchable_area_l_stretch_max() const;
  void _internal_set_catchable_area_l_stretch_max(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.PlayerParam)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 30, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int agent_type_;
    ::int32_t player_types_;
    ::int32_t subs_max_;
    ::int32_t pt_max_;
    bool allow_mult_default_type_;
    float player_speed_max_delta_min_;
    float player_speed_max_delta_max_;
    float stamina_inc_max_delta_factor_;
    float player_decay_delta_min_;
    float player_decay_delta_max_;
    float inertia_moment_delta_factor_;
    float dash_power_rate_delta_min_;
    float dash_power_rate_delta_max_;
    float player_size_delta_factor_;
    float kickable_margin_delta_min_;
    float kickable_margin_delta_max_;
    float kick_rand_delta_factor_;
    float extra_stamina_delta_min_;
    float extra_stamina_delta_max_;
    float effort_max_delta_factor_;
    float effort_min_delta_factor_;
    ::int32_t random_seed_;
    float new_dash_power_rate_delta_min_;
    float new_dash_power_rate_delta_max_;
    float new_stamina_inc_max_delta_factor_;
    float kick_power_rate_delta_min_;
    float kick_power_rate_delta_max_;
    float foul_detect_probability_delta_factor_;
    float catchable_area_l_stretch_min_;
    float catchable_area_l_stretch_max_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class OffsideLineMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.OffsideLineMessage) */ {
 public:
  inline OffsideLineMessage() : OffsideLineMessage(nullptr) {}
  ~OffsideLineMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OffsideLineMessage(::google::protobuf::internal::ConstantInitialized);

  inline OffsideLineMessage(const OffsideLineMessage& from)
      : OffsideLineMessage(nullptr, from) {}
  OffsideLineMessage(OffsideLineMessage&& from) noexcept
    : OffsideLineMessage() {
    *this = ::std::move(from);
  }

  inline OffsideLineMessage& operator=(const OffsideLineMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OffsideLineMessage& operator=(OffsideLineMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OffsideLineMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OffsideLineMessage* internal_default_instance() {
    return reinterpret_cast<const OffsideLineMessage*>(
               &_OffsideLineMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(OffsideLineMessage& a, OffsideLineMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OffsideLineMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OffsideLineMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OffsideLineMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OffsideLineMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OffsideLineMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OffsideLineMessage& from) {
    OffsideLineMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OffsideLineMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.OffsideLineMessage";
  }
  protected:
  explicit OffsideLineMessage(::google::protobuf::Arena* arena);
  OffsideLineMessage(::google::protobuf::Arena* arena, const OffsideLineMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsideLineXFieldNumber = 1,
  };
  // float offside_line_x = 1;
  void clear_offside_line_x() ;
  float offside_line_x() const;
  void set_offside_line_x(float value);

  private:
  float _internal_offside_line_x() const;
  void _internal_set_offside_line_x(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.OffsideLineMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float offside_line_x_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToRelative final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToRelative) */ {
 public:
  inline Neck_TurnToRelative() : Neck_TurnToRelative(nullptr) {}
  ~Neck_TurnToRelative() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToRelative(::google::protobuf::internal::ConstantInitialized);

  inline Neck_TurnToRelative(const Neck_TurnToRelative& from)
      : Neck_TurnToRelative(nullptr, from) {}
  Neck_TurnToRelative(Neck_TurnToRelative&& from) noexcept
    : Neck_TurnToRelative() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToRelative& operator=(const Neck_TurnToRelative& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToRelative& operator=(Neck_TurnToRelative&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToRelative& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToRelative* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToRelative*>(
               &_Neck_TurnToRelative_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(Neck_TurnToRelative& a, Neck_TurnToRelative& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToRelative* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToRelative* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToRelative* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToRelative>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Neck_TurnToRelative& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Neck_TurnToRelative& from) {
    Neck_TurnToRelative::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Neck_TurnToRelative* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToRelative";
  }
  protected:
  explicit Neck_TurnToRelative(::google::protobuf::Arena* arena);
  Neck_TurnToRelative(::google::protobuf::Arena* arena, const Neck_TurnToRelative& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAngleFieldNumber = 1,
  };
  // float angle = 1;
  void clear_angle() ;
  float angle() const;
  void set_angle(float value);

  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToRelative)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float angle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToPlayerOrScan final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToPlayerOrScan) */ {
 public:
  inline Neck_TurnToPlayerOrScan() : Neck_TurnToPlayerOrScan(nullptr) {}
  ~Neck_TurnToPlayerOrScan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToPlayerOrScan(::google::protobuf::internal::ConstantInitialized);

  inline Neck_TurnToPlayerOrScan(const Neck_TurnToPlayerOrScan& from)
      : Neck_TurnToPlayerOrScan(nullptr, from) {}
  Neck_TurnToPlayerOrScan(Neck_TurnToPlayerOrScan&& from) noexcept
    : Neck_TurnToPlayerOrScan() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToPlayerOrScan& operator=(const Neck_TurnToPlayerOrScan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToPlayerOrScan& operator=(Neck_TurnToPlayerOrScan&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToPlayerOrScan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToPlayerOrScan* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToPlayerOrScan*>(
               &_Neck_TurnToPlayerOrScan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(Neck_TurnToPlayerOrScan& a, Neck_TurnToPlayerOrScan& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToPlayerOrScan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToPlayerOrScan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToPlayerOrScan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToPlayerOrScan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Neck_TurnToPlayerOrScan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Neck_TurnToPlayerOrScan& from) {
    Neck_TurnToPlayerOrScan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Neck_TurnToPlayerOrScan* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToPlayerOrScan";
  }
  protected:
  explicit Neck_TurnToPlayerOrScan(::google::protobuf::Arena* arena);
  Neck_TurnToPlayerOrScan(::google::protobuf::Arena* arena, const Neck_TurnToPlayerOrScan& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSideFieldNumber = 1,
    kUniformNumberFieldNumber = 2,
    kCountThresholdFieldNumber = 3,
  };
  // .protos.Side side = 1;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // int32 uniform_number = 2;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 count_threshold = 3;
  void clear_count_threshold() ;
  ::int32_t count_threshold() const;
  void set_count_threshold(::int32_t value);

  private:
  ::int32_t _internal_count_threshold() const;
  void _internal_set_count_threshold(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToPlayerOrScan)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int side_;
    ::int32_t uniform_number_;
    ::int32_t count_threshold_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToLowConfTeammate final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToLowConfTeammate) */ {
 public:
  inline Neck_TurnToLowConfTeammate() : Neck_TurnToLowConfTeammate(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToLowConfTeammate(::google::protobuf::internal::ConstantInitialized);

  inline Neck_TurnToLowConfTeammate(const Neck_TurnToLowConfTeammate& from)
      : Neck_TurnToLowConfTeammate(nullptr, from) {}
  Neck_TurnToLowConfTeammate(Neck_TurnToLowConfTeammate&& from) noexcept
    : Neck_TurnToLowConfTeammate() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToLowConfTeammate& operator=(const Neck_TurnToLowConfTeammate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToLowConfTeammate& operator=(Neck_TurnToLowConfTeammate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToLowConfTeammate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToLowConfTeammate* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToLowConfTeammate*>(
               &_Neck_TurnToLowConfTeammate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(Neck_TurnToLowConfTeammate& a, Neck_TurnToLowConfTeammate& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToLowConfTeammate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToLowConfTeammate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToLowConfTeammate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToLowConfTeammate>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Neck_TurnToLowConfTeammate& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Neck_TurnToLowConfTeammate& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToLowConfTeammate";
  }
  protected:
  explicit Neck_TurnToLowConfTeammate(::google::protobuf::Arena* arena);
  Neck_TurnToLowConfTeammate(::google::protobuf::Arena* arena, const Neck_TurnToLowConfTeammate& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToLowConfTeammate)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToGoalieOrScan final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToGoalieOrScan) */ {
 public:
  inline Neck_TurnToGoalieOrScan() : Neck_TurnToGoalieOrScan(nullptr) {}
  ~Neck_TurnToGoalieOrScan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToGoalieOrScan(::google::protobuf::internal::ConstantInitialized);

  inline Neck_TurnToGoalieOrScan(const Neck_TurnToGoalieOrScan& from)
      : Neck_TurnToGoalieOrScan(nullptr, from) {}
  Neck_TurnToGoalieOrScan(Neck_TurnToGoalieOrScan&& from) noexcept
    : Neck_TurnToGoalieOrScan() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToGoalieOrScan& operator=(const Neck_TurnToGoalieOrScan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToGoalieOrScan& operator=(Neck_TurnToGoalieOrScan&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToGoalieOrScan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToGoalieOrScan* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToGoalieOrScan*>(
               &_Neck_TurnToGoalieOrScan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(Neck_TurnToGoalieOrScan& a, Neck_TurnToGoalieOrScan& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToGoalieOrScan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToGoalieOrScan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToGoalieOrScan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToGoalieOrScan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Neck_TurnToGoalieOrScan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Neck_TurnToGoalieOrScan& from) {
    Neck_TurnToGoalieOrScan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Neck_TurnToGoalieOrScan* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToGoalieOrScan";
  }
  protected:
  explicit Neck_TurnToGoalieOrScan(::google::protobuf::Arena* arena);
  Neck_TurnToGoalieOrScan(::google::protobuf::Arena* arena, const Neck_TurnToGoalieOrScan& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountThresholdFieldNumber = 1,
  };
  // int32 count_threshold = 1;
  void clear_count_threshold() ;
  ::int32_t count_threshold() const;
  void set_count_threshold(::int32_t value);

  private:
  ::int32_t _internal_count_threshold() const;
  void _internal_set_count_threshold(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToGoalieOrScan)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t count_threshold_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToBallOrScan final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToBallOrScan) */ {
 public:
  inline Neck_TurnToBallOrScan() : Neck_TurnToBallOrScan(nullptr) {}
  ~Neck_TurnToBallOrScan() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToBallOrScan(::google::protobuf::internal::ConstantInitialized);

  inline Neck_TurnToBallOrScan(const Neck_TurnToBallOrScan& from)
      : Neck_TurnToBallOrScan(nullptr, from) {}
  Neck_TurnToBallOrScan(Neck_TurnToBallOrScan&& from) noexcept
    : Neck_TurnToBallOrScan() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToBallOrScan& operator=(const Neck_TurnToBallOrScan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToBallOrScan& operator=(Neck_TurnToBallOrScan&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToBallOrScan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToBallOrScan* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToBallOrScan*>(
               &_Neck_TurnToBallOrScan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(Neck_TurnToBallOrScan& a, Neck_TurnToBallOrScan& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToBallOrScan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToBallOrScan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToBallOrScan* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToBallOrScan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Neck_TurnToBallOrScan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Neck_TurnToBallOrScan& from) {
    Neck_TurnToBallOrScan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Neck_TurnToBallOrScan* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToBallOrScan";
  }
  protected:
  explicit Neck_TurnToBallOrScan(::google::protobuf::Arena* arena);
  Neck_TurnToBallOrScan(::google::protobuf::Arena* arena, const Neck_TurnToBallOrScan& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountThresholdFieldNumber = 1,
  };
  // int32 count_threshold = 1;
  void clear_count_threshold() ;
  ::int32_t count_threshold() const;
  void set_count_threshold(::int32_t value);

  private:
  ::int32_t _internal_count_threshold() const;
  void _internal_set_count_threshold(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToBallOrScan)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t count_threshold_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToBallAndPlayer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToBallAndPlayer) */ {
 public:
  inline Neck_TurnToBallAndPlayer() : Neck_TurnToBallAndPlayer(nullptr) {}
  ~Neck_TurnToBallAndPlayer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToBallAndPlayer(::google::protobuf::internal::ConstantInitialized);

  inline Neck_TurnToBallAndPlayer(const Neck_TurnToBallAndPlayer& from)
      : Neck_TurnToBallAndPlayer(nullptr, from) {}
  Neck_TurnToBallAndPlayer(Neck_TurnToBallAndPlayer&& from) noexcept
    : Neck_TurnToBallAndPlayer() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToBallAndPlayer& operator=(const Neck_TurnToBallAndPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToBallAndPlayer& operator=(Neck_TurnToBallAndPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToBallAndPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToBallAndPlayer* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToBallAndPlayer*>(
               &_Neck_TurnToBallAndPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(Neck_TurnToBallAndPlayer& a, Neck_TurnToBallAndPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToBallAndPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToBallAndPlayer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToBallAndPlayer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToBallAndPlayer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Neck_TurnToBallAndPlayer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Neck_TurnToBallAndPlayer& from) {
    Neck_TurnToBallAndPlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Neck_TurnToBallAndPlayer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToBallAndPlayer";
  }
  protected:
  explicit Neck_TurnToBallAndPlayer(::google::protobuf::Arena* arena);
  Neck_TurnToBallAndPlayer(::google::protobuf::Arena* arena, const Neck_TurnToBallAndPlayer& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSideFieldNumber = 1,
    kUniformNumberFieldNumber = 2,
    kCountThresholdFieldNumber = 3,
  };
  // .protos.Side side = 1;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // int32 uniform_number = 2;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 count_threshold = 3;
  void clear_count_threshold() ;
  ::int32_t count_threshold() const;
  void set_count_threshold(::int32_t value);

  private:
  ::int32_t _internal_count_threshold() const;
  void _internal_set_count_threshold(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToBallAndPlayer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int side_;
    ::int32_t uniform_number_;
    ::int32_t count_threshold_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToBall final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToBall) */ {
 public:
  inline Neck_TurnToBall() : Neck_TurnToBall(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToBall(::google::protobuf::internal::ConstantInitialized);

  inline Neck_TurnToBall(const Neck_TurnToBall& from)
      : Neck_TurnToBall(nullptr, from) {}
  Neck_TurnToBall(Neck_TurnToBall&& from) noexcept
    : Neck_TurnToBall() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToBall& operator=(const Neck_TurnToBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToBall& operator=(Neck_TurnToBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToBall* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToBall*>(
               &_Neck_TurnToBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(Neck_TurnToBall& a, Neck_TurnToBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToBall* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToBall>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Neck_TurnToBall& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Neck_TurnToBall& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToBall";
  }
  protected:
  explicit Neck_TurnToBall(::google::protobuf::Arena* arena);
  Neck_TurnToBall(::google::protobuf::Arena* arena, const Neck_TurnToBall& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToBall)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_ScanPlayers final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Neck_ScanPlayers) */ {
 public:
  inline Neck_ScanPlayers() : Neck_ScanPlayers(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_ScanPlayers(::google::protobuf::internal::ConstantInitialized);

  inline Neck_ScanPlayers(const Neck_ScanPlayers& from)
      : Neck_ScanPlayers(nullptr, from) {}
  Neck_ScanPlayers(Neck_ScanPlayers&& from) noexcept
    : Neck_ScanPlayers() {
    *this = ::std::move(from);
  }

  inline Neck_ScanPlayers& operator=(const Neck_ScanPlayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_ScanPlayers& operator=(Neck_ScanPlayers&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_ScanPlayers& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_ScanPlayers* internal_default_instance() {
    return reinterpret_cast<const Neck_ScanPlayers*>(
               &_Neck_ScanPlayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(Neck_ScanPlayers& a, Neck_ScanPlayers& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_ScanPlayers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_ScanPlayers* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_ScanPlayers* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_ScanPlayers>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Neck_ScanPlayers& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Neck_ScanPlayers& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_ScanPlayers";
  }
  protected:
  explicit Neck_ScanPlayers(::google::protobuf::Arena* arena);
  Neck_ScanPlayers(::google::protobuf::Arena* arena, const Neck_ScanPlayers& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Neck_ScanPlayers)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_ScanField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Neck_ScanField) */ {
 public:
  inline Neck_ScanField() : Neck_ScanField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_ScanField(::google::protobuf::internal::ConstantInitialized);

  inline Neck_ScanField(const Neck_ScanField& from)
      : Neck_ScanField(nullptr, from) {}
  Neck_ScanField(Neck_ScanField&& from) noexcept
    : Neck_ScanField() {
    *this = ::std::move(from);
  }

  inline Neck_ScanField& operator=(const Neck_ScanField& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_ScanField& operator=(Neck_ScanField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_ScanField& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_ScanField* internal_default_instance() {
    return reinterpret_cast<const Neck_ScanField*>(
               &_Neck_ScanField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(Neck_ScanField& a, Neck_ScanField& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_ScanField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_ScanField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_ScanField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_ScanField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Neck_ScanField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Neck_ScanField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_ScanField";
  }
  protected:
  explicit Neck_ScanField(::google::protobuf::Arena* arena);
  Neck_ScanField(::google::protobuf::Arena* arena, const Neck_ScanField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Neck_ScanField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Move final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Move) */ {
 public:
  inline Move() : Move(nullptr) {}
  ~Move() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Move(::google::protobuf::internal::ConstantInitialized);

  inline Move(const Move& from)
      : Move(nullptr, from) {}
  Move(Move&& from) noexcept
    : Move() {
    *this = ::std::move(from);
  }

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline Move& operator=(Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
               &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Move& a, Move& b) {
    a.Swap(&b);
  }
  inline void Swap(Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Move* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Move* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Move>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Move& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Move& from) {
    Move::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Move* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Move";
  }
  protected:
  explicit Move(::google::protobuf::Arena* arena);
  Move(::google::protobuf::Arena* arena, const Move& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Move)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float x_;
    float y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Kick final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Kick) */ {
 public:
  inline Kick() : Kick(nullptr) {}
  ~Kick() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Kick(::google::protobuf::internal::ConstantInitialized);

  inline Kick(const Kick& from)
      : Kick(nullptr, from) {}
  Kick(Kick&& from) noexcept
    : Kick() {
    *this = ::std::move(from);
  }

  inline Kick& operator=(const Kick& from) {
    CopyFrom(from);
    return *this;
  }
  inline Kick& operator=(Kick&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Kick& default_instance() {
    return *internal_default_instance();
  }
  static inline const Kick* internal_default_instance() {
    return reinterpret_cast<const Kick*>(
               &_Kick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Kick& a, Kick& b) {
    a.Swap(&b);
  }
  inline void Swap(Kick* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Kick* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Kick* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Kick>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Kick& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Kick& from) {
    Kick::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Kick* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Kick";
  }
  protected:
  explicit Kick(::google::protobuf::Arena* arena);
  Kick(::google::protobuf::Arena* arena, const Kick& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerFieldNumber = 1,
    kRelativeDirectionFieldNumber = 2,
  };
  // float power = 1;
  void clear_power() ;
  float power() const;
  void set_power(float value);

  private:
  float _internal_power() const;
  void _internal_set_power(float value);

  public:
  // float relative_direction = 2;
  void clear_relative_direction() ;
  float relative_direction() const;
  void set_relative_direction(float value);

  private:
  float _internal_relative_direction() const;
  void _internal_set_relative_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Kick)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float power_;
    float relative_direction_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class InterceptMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.InterceptMessage) */ {
 public:
  inline InterceptMessage() : InterceptMessage(nullptr) {}
  ~InterceptMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterceptMessage(::google::protobuf::internal::ConstantInitialized);

  inline InterceptMessage(const InterceptMessage& from)
      : InterceptMessage(nullptr, from) {}
  InterceptMessage(InterceptMessage&& from) noexcept
    : InterceptMessage() {
    *this = ::std::move(from);
  }

  inline InterceptMessage& operator=(const InterceptMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterceptMessage& operator=(InterceptMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterceptMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterceptMessage* internal_default_instance() {
    return reinterpret_cast<const InterceptMessage*>(
               &_InterceptMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(InterceptMessage& a, InterceptMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InterceptMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterceptMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterceptMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterceptMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InterceptMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InterceptMessage& from) {
    InterceptMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InterceptMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.InterceptMessage";
  }
  protected:
  explicit InterceptMessage(::google::protobuf::Arena* arena);
  InterceptMessage(::google::protobuf::Arena* arena, const InterceptMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOurFieldNumber = 1,
    kUniformNumberFieldNumber = 2,
    kCycleFieldNumber = 3,
  };
  // bool our = 1;
  void clear_our() ;
  bool our() const;
  void set_our(bool value);

  private:
  bool _internal_our() const;
  void _internal_set_our(bool value);

  public:
  // int32 uniform_number = 2;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 cycle = 3;
  void clear_cycle() ;
  ::int32_t cycle() const;
  void set_cycle(::int32_t value);

  private:
  ::int32_t _internal_cycle() const;
  void _internal_set_cycle(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.InterceptMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool our_;
    ::int32_t uniform_number_;
    ::int32_t cycle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class InitMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.InitMessage) */ {
 public:
  inline InitMessage() : InitMessage(nullptr) {}
  ~InitMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InitMessage(::google::protobuf::internal::ConstantInitialized);

  inline InitMessage(const InitMessage& from)
      : InitMessage(nullptr, from) {}
  InitMessage(InitMessage&& from) noexcept
    : InitMessage() {
    *this = ::std::move(from);
  }

  inline InitMessage& operator=(const InitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitMessage& operator=(InitMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitMessage* internal_default_instance() {
    return reinterpret_cast<const InitMessage*>(
               &_InitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InitMessage& a, InitMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InitMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InitMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InitMessage& from) {
    InitMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InitMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.InitMessage";
  }
  protected:
  explicit InitMessage(::google::protobuf::Arena* arena);
  InitMessage(::google::protobuf::Arena* arena, const InitMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentTypeFieldNumber = 1,
    kDebugModeFieldNumber = 2,
  };
  // .protos.AgentType agent_type = 1;
  void clear_agent_type() ;
  ::protos::AgentType agent_type() const;
  void set_agent_type(::protos::AgentType value);

  private:
  ::protos::AgentType _internal_agent_type() const;
  void _internal_set_agent_type(::protos::AgentType value);

  public:
  // bool debug_mode = 2;
  void clear_debug_mode() ;
  bool debug_mode() const;
  void set_debug_mode(bool value);

  private:
  bool _internal_debug_mode() const;
  void _internal_set_debug_mode(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.InitMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int agent_type_;
    bool debug_mode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class HeliosShoot final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.HeliosShoot) */ {
 public:
  inline HeliosShoot() : HeliosShoot(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeliosShoot(::google::protobuf::internal::ConstantInitialized);

  inline HeliosShoot(const HeliosShoot& from)
      : HeliosShoot(nullptr, from) {}
  HeliosShoot(HeliosShoot&& from) noexcept
    : HeliosShoot() {
    *this = ::std::move(from);
  }

  inline HeliosShoot& operator=(const HeliosShoot& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeliosShoot& operator=(HeliosShoot&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeliosShoot& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeliosShoot* internal_default_instance() {
    return reinterpret_cast<const HeliosShoot*>(
               &_HeliosShoot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(HeliosShoot& a, HeliosShoot& b) {
    a.Swap(&b);
  }
  inline void Swap(HeliosShoot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeliosShoot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeliosShoot* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeliosShoot>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeliosShoot& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeliosShoot& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.HeliosShoot";
  }
  protected:
  explicit HeliosShoot(::google::protobuf::Arena* arena);
  HeliosShoot(::google::protobuf::Arena* arena, const HeliosShoot& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.HeliosShoot)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class HeliosSetPlay final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.HeliosSetPlay) */ {
 public:
  inline HeliosSetPlay() : HeliosSetPlay(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeliosSetPlay(::google::protobuf::internal::ConstantInitialized);

  inline HeliosSetPlay(const HeliosSetPlay& from)
      : HeliosSetPlay(nullptr, from) {}
  HeliosSetPlay(HeliosSetPlay&& from) noexcept
    : HeliosSetPlay() {
    *this = ::std::move(from);
  }

  inline HeliosSetPlay& operator=(const HeliosSetPlay& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeliosSetPlay& operator=(HeliosSetPlay&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeliosSetPlay& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeliosSetPlay* internal_default_instance() {
    return reinterpret_cast<const HeliosSetPlay*>(
               &_HeliosSetPlay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(HeliosSetPlay& a, HeliosSetPlay& b) {
    a.Swap(&b);
  }
  inline void Swap(HeliosSetPlay* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeliosSetPlay* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeliosSetPlay* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeliosSetPlay>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeliosSetPlay& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeliosSetPlay& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.HeliosSetPlay";
  }
  protected:
  explicit HeliosSetPlay(::google::protobuf::Arena* arena);
  HeliosSetPlay(::google::protobuf::Arena* arena, const HeliosSetPlay& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.HeliosSetPlay)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class HeliosPenalty final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.HeliosPenalty) */ {
 public:
  inline HeliosPenalty() : HeliosPenalty(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeliosPenalty(::google::protobuf::internal::ConstantInitialized);

  inline HeliosPenalty(const HeliosPenalty& from)
      : HeliosPenalty(nullptr, from) {}
  HeliosPenalty(HeliosPenalty&& from) noexcept
    : HeliosPenalty() {
    *this = ::std::move(from);
  }

  inline HeliosPenalty& operator=(const HeliosPenalty& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeliosPenalty& operator=(HeliosPenalty&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeliosPenalty& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeliosPenalty* internal_default_instance() {
    return reinterpret_cast<const HeliosPenalty*>(
               &_HeliosPenalty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(HeliosPenalty& a, HeliosPenalty& b) {
    a.Swap(&b);
  }
  inline void Swap(HeliosPenalty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeliosPenalty* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeliosPenalty* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeliosPenalty>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeliosPenalty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeliosPenalty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.HeliosPenalty";
  }
  protected:
  explicit HeliosPenalty(::google::protobuf::Arena* arena);
  HeliosPenalty(::google::protobuf::Arena* arena, const HeliosPenalty& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.HeliosPenalty)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class HeliosGoalieMove final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.HeliosGoalieMove) */ {
 public:
  inline HeliosGoalieMove() : HeliosGoalieMove(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeliosGoalieMove(::google::protobuf::internal::ConstantInitialized);

  inline HeliosGoalieMove(const HeliosGoalieMove& from)
      : HeliosGoalieMove(nullptr, from) {}
  HeliosGoalieMove(HeliosGoalieMove&& from) noexcept
    : HeliosGoalieMove() {
    *this = ::std::move(from);
  }

  inline HeliosGoalieMove& operator=(const HeliosGoalieMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeliosGoalieMove& operator=(HeliosGoalieMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeliosGoalieMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeliosGoalieMove* internal_default_instance() {
    return reinterpret_cast<const HeliosGoalieMove*>(
               &_HeliosGoalieMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(HeliosGoalieMove& a, HeliosGoalieMove& b) {
    a.Swap(&b);
  }
  inline void Swap(HeliosGoalieMove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeliosGoalieMove* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeliosGoalieMove* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeliosGoalieMove>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeliosGoalieMove& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeliosGoalieMove& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.HeliosGoalieMove";
  }
  protected:
  explicit HeliosGoalieMove(::google::protobuf::Arena* arena);
  HeliosGoalieMove(::google::protobuf::Arena* arena, const HeliosGoalieMove& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.HeliosGoalieMove)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class HeliosGoalieKick final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.HeliosGoalieKick) */ {
 public:
  inline HeliosGoalieKick() : HeliosGoalieKick(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeliosGoalieKick(::google::protobuf::internal::ConstantInitialized);

  inline HeliosGoalieKick(const HeliosGoalieKick& from)
      : HeliosGoalieKick(nullptr, from) {}
  HeliosGoalieKick(HeliosGoalieKick&& from) noexcept
    : HeliosGoalieKick() {
    *this = ::std::move(from);
  }

  inline HeliosGoalieKick& operator=(const HeliosGoalieKick& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeliosGoalieKick& operator=(HeliosGoalieKick&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeliosGoalieKick& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeliosGoalieKick* internal_default_instance() {
    return reinterpret_cast<const HeliosGoalieKick*>(
               &_HeliosGoalieKick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(HeliosGoalieKick& a, HeliosGoalieKick& b) {
    a.Swap(&b);
  }
  inline void Swap(HeliosGoalieKick* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeliosGoalieKick* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeliosGoalieKick* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeliosGoalieKick>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeliosGoalieKick& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeliosGoalieKick& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.HeliosGoalieKick";
  }
  protected:
  explicit HeliosGoalieKick(::google::protobuf::Arena* arena);
  HeliosGoalieKick(::google::protobuf::Arena* arena, const HeliosGoalieKick& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.HeliosGoalieKick)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class HeliosGoalie final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.HeliosGoalie) */ {
 public:
  inline HeliosGoalie() : HeliosGoalie(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeliosGoalie(::google::protobuf::internal::ConstantInitialized);

  inline HeliosGoalie(const HeliosGoalie& from)
      : HeliosGoalie(nullptr, from) {}
  HeliosGoalie(HeliosGoalie&& from) noexcept
    : HeliosGoalie() {
    *this = ::std::move(from);
  }

  inline HeliosGoalie& operator=(const HeliosGoalie& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeliosGoalie& operator=(HeliosGoalie&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeliosGoalie& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeliosGoalie* internal_default_instance() {
    return reinterpret_cast<const HeliosGoalie*>(
               &_HeliosGoalie_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(HeliosGoalie& a, HeliosGoalie& b) {
    a.Swap(&b);
  }
  inline void Swap(HeliosGoalie* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeliosGoalie* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeliosGoalie* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeliosGoalie>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeliosGoalie& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeliosGoalie& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.HeliosGoalie";
  }
  protected:
  explicit HeliosGoalie(::google::protobuf::Arena* arena);
  HeliosGoalie(::google::protobuf::Arena* arena, const HeliosGoalie& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.HeliosGoalie)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class HeliosCommunicaion final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.HeliosCommunicaion) */ {
 public:
  inline HeliosCommunicaion() : HeliosCommunicaion(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeliosCommunicaion(::google::protobuf::internal::ConstantInitialized);

  inline HeliosCommunicaion(const HeliosCommunicaion& from)
      : HeliosCommunicaion(nullptr, from) {}
  HeliosCommunicaion(HeliosCommunicaion&& from) noexcept
    : HeliosCommunicaion() {
    *this = ::std::move(from);
  }

  inline HeliosCommunicaion& operator=(const HeliosCommunicaion& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeliosCommunicaion& operator=(HeliosCommunicaion&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeliosCommunicaion& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeliosCommunicaion* internal_default_instance() {
    return reinterpret_cast<const HeliosCommunicaion*>(
               &_HeliosCommunicaion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(HeliosCommunicaion& a, HeliosCommunicaion& b) {
    a.Swap(&b);
  }
  inline void Swap(HeliosCommunicaion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeliosCommunicaion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeliosCommunicaion* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeliosCommunicaion>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeliosCommunicaion& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeliosCommunicaion& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.HeliosCommunicaion";
  }
  protected:
  explicit HeliosCommunicaion(::google::protobuf::Arena* arena);
  HeliosCommunicaion(::google::protobuf::Arena* arena, const HeliosCommunicaion& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.HeliosCommunicaion)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class HeliosChainAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.HeliosChainAction) */ {
 public:
  inline HeliosChainAction() : HeliosChainAction(nullptr) {}
  ~HeliosChainAction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeliosChainAction(::google::protobuf::internal::ConstantInitialized);

  inline HeliosChainAction(const HeliosChainAction& from)
      : HeliosChainAction(nullptr, from) {}
  HeliosChainAction(HeliosChainAction&& from) noexcept
    : HeliosChainAction() {
    *this = ::std::move(from);
  }

  inline HeliosChainAction& operator=(const HeliosChainAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeliosChainAction& operator=(HeliosChainAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeliosChainAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeliosChainAction* internal_default_instance() {
    return reinterpret_cast<const HeliosChainAction*>(
               &_HeliosChainAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(HeliosChainAction& a, HeliosChainAction& b) {
    a.Swap(&b);
  }
  inline void Swap(HeliosChainAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeliosChainAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeliosChainAction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeliosChainAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeliosChainAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HeliosChainAction& from) {
    HeliosChainAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeliosChainAction* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.HeliosChainAction";
  }
  protected:
  explicit HeliosChainAction(::google::protobuf::Arena* arena);
  HeliosChainAction(::google::protobuf::Arena* arena, const HeliosChainAction& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectPassFieldNumber = 1,
    kLeadPassFieldNumber = 2,
    kThroughPassFieldNumber = 3,
    kShortDribbleFieldNumber = 4,
    kLongDribbleFieldNumber = 5,
    kCrossFieldNumber = 6,
    kSimplePassFieldNumber = 7,
    kSimpleDribbleFieldNumber = 8,
    kSimpleShootFieldNumber = 9,
  };
  // bool direct_pass = 1;
  void clear_direct_pass() ;
  bool direct_pass() const;
  void set_direct_pass(bool value);

  private:
  bool _internal_direct_pass() const;
  void _internal_set_direct_pass(bool value);

  public:
  // bool lead_pass = 2;
  void clear_lead_pass() ;
  bool lead_pass() const;
  void set_lead_pass(bool value);

  private:
  bool _internal_lead_pass() const;
  void _internal_set_lead_pass(bool value);

  public:
  // bool through_pass = 3;
  void clear_through_pass() ;
  bool through_pass() const;
  void set_through_pass(bool value);

  private:
  bool _internal_through_pass() const;
  void _internal_set_through_pass(bool value);

  public:
  // bool short_dribble = 4;
  void clear_short_dribble() ;
  bool short_dribble() const;
  void set_short_dribble(bool value);

  private:
  bool _internal_short_dribble() const;
  void _internal_set_short_dribble(bool value);

  public:
  // bool long_dribble = 5;
  void clear_long_dribble() ;
  bool long_dribble() const;
  void set_long_dribble(bool value);

  private:
  bool _internal_long_dribble() const;
  void _internal_set_long_dribble(bool value);

  public:
  // bool cross = 6;
  void clear_cross() ;
  bool cross() const;
  void set_cross(bool value);

  private:
  bool _internal_cross() const;
  void _internal_set_cross(bool value);

  public:
  // bool simple_pass = 7;
  void clear_simple_pass() ;
  bool simple_pass() const;
  void set_simple_pass(bool value);

  private:
  bool _internal_simple_pass() const;
  void _internal_set_simple_pass(bool value);

  public:
  // bool simple_dribble = 8;
  void clear_simple_dribble() ;
  bool simple_dribble() const;
  void set_simple_dribble(bool value);

  private:
  bool _internal_simple_dribble() const;
  void _internal_set_simple_dribble(bool value);

  public:
  // bool simple_shoot = 9;
  void clear_simple_shoot() ;
  bool simple_shoot() const;
  void set_simple_shoot(bool value);

  private:
  bool _internal_simple_shoot() const;
  void _internal_set_simple_shoot(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.HeliosChainAction)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool direct_pass_;
    bool lead_pass_;
    bool through_pass_;
    bool short_dribble_;
    bool long_dribble_;
    bool cross_;
    bool simple_pass_;
    bool simple_dribble_;
    bool simple_shoot_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class HeliosBasicOffensive final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.HeliosBasicOffensive) */ {
 public:
  inline HeliosBasicOffensive() : HeliosBasicOffensive(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeliosBasicOffensive(::google::protobuf::internal::ConstantInitialized);

  inline HeliosBasicOffensive(const HeliosBasicOffensive& from)
      : HeliosBasicOffensive(nullptr, from) {}
  HeliosBasicOffensive(HeliosBasicOffensive&& from) noexcept
    : HeliosBasicOffensive() {
    *this = ::std::move(from);
  }

  inline HeliosBasicOffensive& operator=(const HeliosBasicOffensive& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeliosBasicOffensive& operator=(HeliosBasicOffensive&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeliosBasicOffensive& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeliosBasicOffensive* internal_default_instance() {
    return reinterpret_cast<const HeliosBasicOffensive*>(
               &_HeliosBasicOffensive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(HeliosBasicOffensive& a, HeliosBasicOffensive& b) {
    a.Swap(&b);
  }
  inline void Swap(HeliosBasicOffensive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeliosBasicOffensive* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeliosBasicOffensive* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeliosBasicOffensive>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeliosBasicOffensive& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeliosBasicOffensive& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.HeliosBasicOffensive";
  }
  protected:
  explicit HeliosBasicOffensive(::google::protobuf::Arena* arena);
  HeliosBasicOffensive(::google::protobuf::Arena* arena, const HeliosBasicOffensive& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.HeliosBasicOffensive)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class HeliosBasicMove final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.HeliosBasicMove) */ {
 public:
  inline HeliosBasicMove() : HeliosBasicMove(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeliosBasicMove(::google::protobuf::internal::ConstantInitialized);

  inline HeliosBasicMove(const HeliosBasicMove& from)
      : HeliosBasicMove(nullptr, from) {}
  HeliosBasicMove(HeliosBasicMove&& from) noexcept
    : HeliosBasicMove() {
    *this = ::std::move(from);
  }

  inline HeliosBasicMove& operator=(const HeliosBasicMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeliosBasicMove& operator=(HeliosBasicMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeliosBasicMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeliosBasicMove* internal_default_instance() {
    return reinterpret_cast<const HeliosBasicMove*>(
               &_HeliosBasicMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(HeliosBasicMove& a, HeliosBasicMove& b) {
    a.Swap(&b);
  }
  inline void Swap(HeliosBasicMove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeliosBasicMove* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeliosBasicMove* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeliosBasicMove>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeliosBasicMove& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeliosBasicMove& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.HeliosBasicMove";
  }
  protected:
  explicit HeliosBasicMove(::google::protobuf::Arena* arena);
  HeliosBasicMove(::google::protobuf::Arena* arena, const HeliosBasicMove& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.HeliosBasicMove)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Focus_Reset final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Focus_Reset) */ {
 public:
  inline Focus_Reset() : Focus_Reset(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Focus_Reset(::google::protobuf::internal::ConstantInitialized);

  inline Focus_Reset(const Focus_Reset& from)
      : Focus_Reset(nullptr, from) {}
  Focus_Reset(Focus_Reset&& from) noexcept
    : Focus_Reset() {
    *this = ::std::move(from);
  }

  inline Focus_Reset& operator=(const Focus_Reset& from) {
    CopyFrom(from);
    return *this;
  }
  inline Focus_Reset& operator=(Focus_Reset&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Focus_Reset& default_instance() {
    return *internal_default_instance();
  }
  static inline const Focus_Reset* internal_default_instance() {
    return reinterpret_cast<const Focus_Reset*>(
               &_Focus_Reset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(Focus_Reset& a, Focus_Reset& b) {
    a.Swap(&b);
  }
  inline void Swap(Focus_Reset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Focus_Reset* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Focus_Reset* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Focus_Reset>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Focus_Reset& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Focus_Reset& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Focus_Reset";
  }
  protected:
  explicit Focus_Reset(::google::protobuf::Arena* arena);
  Focus_Reset(::google::protobuf::Arena* arena, const Focus_Reset& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Focus_Reset)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Empty final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Empty(::google::protobuf::internal::ConstantInitialized);

  inline Empty(const Empty& from)
      : Empty(nullptr, from) {}
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Empty";
  }
  protected:
  explicit Empty(::google::protobuf::Arena* arena);
  Empty(::google::protobuf::Arena* arena, const Empty& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Empty)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DoRecover final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.DoRecover) */ {
 public:
  inline DoRecover() : DoRecover(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoRecover(::google::protobuf::internal::ConstantInitialized);

  inline DoRecover(const DoRecover& from)
      : DoRecover(nullptr, from) {}
  DoRecover(DoRecover&& from) noexcept
    : DoRecover() {
    *this = ::std::move(from);
  }

  inline DoRecover& operator=(const DoRecover& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoRecover& operator=(DoRecover&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoRecover& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoRecover* internal_default_instance() {
    return reinterpret_cast<const DoRecover*>(
               &_DoRecover_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(DoRecover& a, DoRecover& b) {
    a.Swap(&b);
  }
  inline void Swap(DoRecover* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoRecover* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoRecover* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoRecover>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DoRecover& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DoRecover& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DoRecover";
  }
  protected:
  explicit DoRecover(::google::protobuf::Arena* arena);
  DoRecover(::google::protobuf::Arena* arena, const DoRecover& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.DoRecover)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DoKickOff final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.DoKickOff) */ {
 public:
  inline DoKickOff() : DoKickOff(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoKickOff(::google::protobuf::internal::ConstantInitialized);

  inline DoKickOff(const DoKickOff& from)
      : DoKickOff(nullptr, from) {}
  DoKickOff(DoKickOff&& from) noexcept
    : DoKickOff() {
    *this = ::std::move(from);
  }

  inline DoKickOff& operator=(const DoKickOff& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoKickOff& operator=(DoKickOff&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoKickOff& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoKickOff* internal_default_instance() {
    return reinterpret_cast<const DoKickOff*>(
               &_DoKickOff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(DoKickOff& a, DoKickOff& b) {
    a.Swap(&b);
  }
  inline void Swap(DoKickOff* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoKickOff* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoKickOff* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoKickOff>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DoKickOff& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DoKickOff& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DoKickOff";
  }
  protected:
  explicit DoKickOff(::google::protobuf::Arena* arena);
  DoKickOff(::google::protobuf::Arena* arena, const DoKickOff& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.DoKickOff)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DoHeliosSubstitute final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.DoHeliosSubstitute) */ {
 public:
  inline DoHeliosSubstitute() : DoHeliosSubstitute(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoHeliosSubstitute(::google::protobuf::internal::ConstantInitialized);

  inline DoHeliosSubstitute(const DoHeliosSubstitute& from)
      : DoHeliosSubstitute(nullptr, from) {}
  DoHeliosSubstitute(DoHeliosSubstitute&& from) noexcept
    : DoHeliosSubstitute() {
    *this = ::std::move(from);
  }

  inline DoHeliosSubstitute& operator=(const DoHeliosSubstitute& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoHeliosSubstitute& operator=(DoHeliosSubstitute&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoHeliosSubstitute& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoHeliosSubstitute* internal_default_instance() {
    return reinterpret_cast<const DoHeliosSubstitute*>(
               &_DoHeliosSubstitute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(DoHeliosSubstitute& a, DoHeliosSubstitute& b) {
    a.Swap(&b);
  }
  inline void Swap(DoHeliosSubstitute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoHeliosSubstitute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoHeliosSubstitute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoHeliosSubstitute>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DoHeliosSubstitute& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DoHeliosSubstitute& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DoHeliosSubstitute";
  }
  protected:
  explicit DoHeliosSubstitute(::google::protobuf::Arena* arena);
  DoHeliosSubstitute(::google::protobuf::Arena* arena, const DoHeliosSubstitute& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.DoHeliosSubstitute)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DoHeliosSayPlayerTypes final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.DoHeliosSayPlayerTypes) */ {
 public:
  inline DoHeliosSayPlayerTypes() : DoHeliosSayPlayerTypes(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoHeliosSayPlayerTypes(::google::protobuf::internal::ConstantInitialized);

  inline DoHeliosSayPlayerTypes(const DoHeliosSayPlayerTypes& from)
      : DoHeliosSayPlayerTypes(nullptr, from) {}
  DoHeliosSayPlayerTypes(DoHeliosSayPlayerTypes&& from) noexcept
    : DoHeliosSayPlayerTypes() {
    *this = ::std::move(from);
  }

  inline DoHeliosSayPlayerTypes& operator=(const DoHeliosSayPlayerTypes& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoHeliosSayPlayerTypes& operator=(DoHeliosSayPlayerTypes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoHeliosSayPlayerTypes& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoHeliosSayPlayerTypes* internal_default_instance() {
    return reinterpret_cast<const DoHeliosSayPlayerTypes*>(
               &_DoHeliosSayPlayerTypes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(DoHeliosSayPlayerTypes& a, DoHeliosSayPlayerTypes& b) {
    a.Swap(&b);
  }
  inline void Swap(DoHeliosSayPlayerTypes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoHeliosSayPlayerTypes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoHeliosSayPlayerTypes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoHeliosSayPlayerTypes>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DoHeliosSayPlayerTypes& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DoHeliosSayPlayerTypes& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DoHeliosSayPlayerTypes";
  }
  protected:
  explicit DoHeliosSayPlayerTypes(::google::protobuf::Arena* arena);
  DoHeliosSayPlayerTypes(::google::protobuf::Arena* arena, const DoHeliosSayPlayerTypes& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.DoHeliosSayPlayerTypes)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DoChangePlayerType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.DoChangePlayerType) */ {
 public:
  inline DoChangePlayerType() : DoChangePlayerType(nullptr) {}
  ~DoChangePlayerType() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoChangePlayerType(::google::protobuf::internal::ConstantInitialized);

  inline DoChangePlayerType(const DoChangePlayerType& from)
      : DoChangePlayerType(nullptr, from) {}
  DoChangePlayerType(DoChangePlayerType&& from) noexcept
    : DoChangePlayerType() {
    *this = ::std::move(from);
  }

  inline DoChangePlayerType& operator=(const DoChangePlayerType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoChangePlayerType& operator=(DoChangePlayerType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoChangePlayerType& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoChangePlayerType* internal_default_instance() {
    return reinterpret_cast<const DoChangePlayerType*>(
               &_DoChangePlayerType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(DoChangePlayerType& a, DoChangePlayerType& b) {
    a.Swap(&b);
  }
  inline void Swap(DoChangePlayerType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoChangePlayerType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoChangePlayerType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoChangePlayerType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoChangePlayerType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DoChangePlayerType& from) {
    DoChangePlayerType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DoChangePlayerType* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DoChangePlayerType";
  }
  protected:
  explicit DoChangePlayerType(::google::protobuf::Arena* arena);
  DoChangePlayerType(::google::protobuf::Arena* arena, const DoChangePlayerType& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOurSideFieldNumber = 1,
    kUniformNumberFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // bool our_side = 1;
  void clear_our_side() ;
  bool our_side() const;
  void set_our_side(bool value);

  private:
  bool _internal_our_side() const;
  void _internal_set_our_side(bool value);

  public:
  // int32 uniform_number = 2;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 type = 3;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.DoChangePlayerType)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool our_side_;
    ::int32_t uniform_number_;
    ::int32_t type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DoChangeMode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.DoChangeMode) */ {
 public:
  inline DoChangeMode() : DoChangeMode(nullptr) {}
  ~DoChangeMode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoChangeMode(::google::protobuf::internal::ConstantInitialized);

  inline DoChangeMode(const DoChangeMode& from)
      : DoChangeMode(nullptr, from) {}
  DoChangeMode(DoChangeMode&& from) noexcept
    : DoChangeMode() {
    *this = ::std::move(from);
  }

  inline DoChangeMode& operator=(const DoChangeMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoChangeMode& operator=(DoChangeMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoChangeMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoChangeMode* internal_default_instance() {
    return reinterpret_cast<const DoChangeMode*>(
               &_DoChangeMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(DoChangeMode& a, DoChangeMode& b) {
    a.Swap(&b);
  }
  inline void Swap(DoChangeMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoChangeMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoChangeMode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoChangeMode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoChangeMode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DoChangeMode& from) {
    DoChangeMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DoChangeMode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DoChangeMode";
  }
  protected:
  explicit DoChangeMode(::google::protobuf::Arena* arena);
  DoChangeMode(::google::protobuf::Arena* arena, const DoChangeMode& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameModeTypeFieldNumber = 1,
    kSideFieldNumber = 2,
  };
  // .protos.GameModeType game_mode_type = 1;
  void clear_game_mode_type() ;
  ::protos::GameModeType game_mode_type() const;
  void set_game_mode_type(::protos::GameModeType value);

  private:
  ::protos::GameModeType _internal_game_mode_type() const;
  void _internal_set_game_mode_type(::protos::GameModeType value);

  public:
  // .protos.Side side = 2;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // @@protoc_insertion_point(class_scope:protos.DoChangeMode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int game_mode_type_;
    int side_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DefenseLineMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.DefenseLineMessage) */ {
 public:
  inline DefenseLineMessage() : DefenseLineMessage(nullptr) {}
  ~DefenseLineMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DefenseLineMessage(::google::protobuf::internal::ConstantInitialized);

  inline DefenseLineMessage(const DefenseLineMessage& from)
      : DefenseLineMessage(nullptr, from) {}
  DefenseLineMessage(DefenseLineMessage&& from) noexcept
    : DefenseLineMessage() {
    *this = ::std::move(from);
  }

  inline DefenseLineMessage& operator=(const DefenseLineMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefenseLineMessage& operator=(DefenseLineMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefenseLineMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefenseLineMessage* internal_default_instance() {
    return reinterpret_cast<const DefenseLineMessage*>(
               &_DefenseLineMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(DefenseLineMessage& a, DefenseLineMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DefenseLineMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefenseLineMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefenseLineMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefenseLineMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DefenseLineMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DefenseLineMessage& from) {
    DefenseLineMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DefenseLineMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DefenseLineMessage";
  }
  protected:
  explicit DefenseLineMessage(::google::protobuf::Arena* arena);
  DefenseLineMessage(::google::protobuf::Arena* arena, const DefenseLineMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefenseLineXFieldNumber = 1,
  };
  // float defense_line_x = 1;
  void clear_defense_line_x() ;
  float defense_line_x() const;
  void set_defense_line_x(float value);

  private:
  float _internal_defense_line_x() const;
  void _internal_set_defense_line_x(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.DefenseLineMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float defense_line_x_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DebugClient final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.DebugClient) */ {
 public:
  inline DebugClient() : DebugClient(nullptr) {}
  ~DebugClient() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DebugClient(::google::protobuf::internal::ConstantInitialized);

  inline DebugClient(const DebugClient& from)
      : DebugClient(nullptr, from) {}
  DebugClient(DebugClient&& from) noexcept
    : DebugClient() {
    *this = ::std::move(from);
  }

  inline DebugClient& operator=(const DebugClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugClient& operator=(DebugClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugClient& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugClient* internal_default_instance() {
    return reinterpret_cast<const DebugClient*>(
               &_DebugClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(DebugClient& a, DebugClient& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugClient* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugClient* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugClient* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugClient>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DebugClient& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DebugClient& from) {
    DebugClient::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DebugClient* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DebugClient";
  }
  protected:
  explicit DebugClient(::google::protobuf::Arena* arena);
  DebugClient(::google::protobuf::Arena* arena, const DebugClient& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:protos.DebugClient)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Dash final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Dash) */ {
 public:
  inline Dash() : Dash(nullptr) {}
  ~Dash() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Dash(::google::protobuf::internal::ConstantInitialized);

  inline Dash(const Dash& from)
      : Dash(nullptr, from) {}
  Dash(Dash&& from) noexcept
    : Dash() {
    *this = ::std::move(from);
  }

  inline Dash& operator=(const Dash& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dash& operator=(Dash&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dash& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dash* internal_default_instance() {
    return reinterpret_cast<const Dash*>(
               &_Dash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Dash& a, Dash& b) {
    a.Swap(&b);
  }
  inline void Swap(Dash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dash* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dash* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dash>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Dash& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Dash& from) {
    Dash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Dash* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Dash";
  }
  protected:
  explicit Dash(::google::protobuf::Arena* arena);
  Dash(::google::protobuf::Arena* arena, const Dash& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPowerFieldNumber = 1,
    kRelativeDirectionFieldNumber = 2,
  };
  // float power = 1;
  void clear_power() ;
  float power() const;
  void set_power(float value);

  private:
  float _internal_power() const;
  void _internal_set_power(float value);

  public:
  // float relative_direction = 2;
  void clear_relative_direction() ;
  float relative_direction() const;
  void set_relative_direction(float value);

  private:
  float _internal_relative_direction() const;
  void _internal_set_relative_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Dash)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float power_;
    float relative_direction_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class ChangeView final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.ChangeView) */ {
 public:
  inline ChangeView() : ChangeView(nullptr) {}
  ~ChangeView() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChangeView(::google::protobuf::internal::ConstantInitialized);

  inline ChangeView(const ChangeView& from)
      : ChangeView(nullptr, from) {}
  ChangeView(ChangeView&& from) noexcept
    : ChangeView() {
    *this = ::std::move(from);
  }

  inline ChangeView& operator=(const ChangeView& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeView& operator=(ChangeView&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeView& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeView* internal_default_instance() {
    return reinterpret_cast<const ChangeView*>(
               &_ChangeView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ChangeView& a, ChangeView& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeView* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeView* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeView* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeView>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChangeView& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChangeView& from) {
    ChangeView::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChangeView* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.ChangeView";
  }
  protected:
  explicit ChangeView(::google::protobuf::Arena* arena);
  ChangeView(::google::protobuf::Arena* arena, const ChangeView& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewWidthFieldNumber = 1,
  };
  // .protos.ViewWidth view_width = 1;
  void clear_view_width() ;
  ::protos::ViewWidth view_width() const;
  void set_view_width(::protos::ViewWidth value);

  private:
  ::protos::ViewWidth _internal_view_width() const;
  void _internal_set_view_width(::protos::ViewWidth value);

  public:
  // @@protoc_insertion_point(class_scope:protos.ChangeView)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int view_width_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class ChangePlayerType final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.ChangePlayerType) */ {
 public:
  inline ChangePlayerType() : ChangePlayerType(nullptr) {}
  ~ChangePlayerType() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChangePlayerType(::google::protobuf::internal::ConstantInitialized);

  inline ChangePlayerType(const ChangePlayerType& from)
      : ChangePlayerType(nullptr, from) {}
  ChangePlayerType(ChangePlayerType&& from) noexcept
    : ChangePlayerType() {
    *this = ::std::move(from);
  }

  inline ChangePlayerType& operator=(const ChangePlayerType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangePlayerType& operator=(ChangePlayerType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangePlayerType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangePlayerType* internal_default_instance() {
    return reinterpret_cast<const ChangePlayerType*>(
               &_ChangePlayerType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(ChangePlayerType& a, ChangePlayerType& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangePlayerType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangePlayerType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangePlayerType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangePlayerType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChangePlayerType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChangePlayerType& from) {
    ChangePlayerType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChangePlayerType* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.ChangePlayerType";
  }
  protected:
  explicit ChangePlayerType(::google::protobuf::Arena* arena);
  ChangePlayerType(::google::protobuf::Arena* arena, const ChangePlayerType& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniformNumberFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // int32 uniform_number = 1;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 type = 2;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.ChangePlayerType)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t uniform_number_;
    ::int32_t type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Catch final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Catch) */ {
 public:
  inline Catch() : Catch(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Catch(::google::protobuf::internal::ConstantInitialized);

  inline Catch(const Catch& from)
      : Catch(nullptr, from) {}
  Catch(Catch&& from) noexcept
    : Catch() {
    *this = ::std::move(from);
  }

  inline Catch& operator=(const Catch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Catch& operator=(Catch&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Catch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Catch* internal_default_instance() {
    return reinterpret_cast<const Catch*>(
               &_Catch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Catch& a, Catch& b) {
    a.Swap(&b);
  }
  inline void Swap(Catch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Catch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Catch* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Catch>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Catch& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Catch& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Catch";
  }
  protected:
  explicit Catch(::google::protobuf::Arena* arena);
  Catch(::google::protobuf::Arena* arena, const Catch& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Catch)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_TurnToBall final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Body_TurnToBall) */ {
 public:
  inline Body_TurnToBall() : Body_TurnToBall(nullptr) {}
  ~Body_TurnToBall() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_TurnToBall(::google::protobuf::internal::ConstantInitialized);

  inline Body_TurnToBall(const Body_TurnToBall& from)
      : Body_TurnToBall(nullptr, from) {}
  Body_TurnToBall(Body_TurnToBall&& from) noexcept
    : Body_TurnToBall() {
    *this = ::std::move(from);
  }

  inline Body_TurnToBall& operator=(const Body_TurnToBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_TurnToBall& operator=(Body_TurnToBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_TurnToBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_TurnToBall* internal_default_instance() {
    return reinterpret_cast<const Body_TurnToBall*>(
               &_Body_TurnToBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(Body_TurnToBall& a, Body_TurnToBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_TurnToBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_TurnToBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_TurnToBall* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_TurnToBall>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Body_TurnToBall& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Body_TurnToBall& from) {
    Body_TurnToBall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Body_TurnToBall* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_TurnToBall";
  }
  protected:
  explicit Body_TurnToBall(::google::protobuf::Arena* arena);
  Body_TurnToBall(::google::protobuf::Arena* arena, const Body_TurnToBall& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCycleFieldNumber = 1,
  };
  // int32 cycle = 1;
  void clear_cycle() ;
  ::int32_t cycle() const;
  void set_cycle(::int32_t value);

  private:
  ::int32_t _internal_cycle() const;
  void _internal_set_cycle(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_TurnToBall)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t cycle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_TurnToAngle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Body_TurnToAngle) */ {
 public:
  inline Body_TurnToAngle() : Body_TurnToAngle(nullptr) {}
  ~Body_TurnToAngle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_TurnToAngle(::google::protobuf::internal::ConstantInitialized);

  inline Body_TurnToAngle(const Body_TurnToAngle& from)
      : Body_TurnToAngle(nullptr, from) {}
  Body_TurnToAngle(Body_TurnToAngle&& from) noexcept
    : Body_TurnToAngle() {
    *this = ::std::move(from);
  }

  inline Body_TurnToAngle& operator=(const Body_TurnToAngle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_TurnToAngle& operator=(Body_TurnToAngle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_TurnToAngle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_TurnToAngle* internal_default_instance() {
    return reinterpret_cast<const Body_TurnToAngle*>(
               &_Body_TurnToAngle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(Body_TurnToAngle& a, Body_TurnToAngle& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_TurnToAngle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_TurnToAngle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_TurnToAngle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_TurnToAngle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Body_TurnToAngle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Body_TurnToAngle& from) {
    Body_TurnToAngle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Body_TurnToAngle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_TurnToAngle";
  }
  protected:
  explicit Body_TurnToAngle(::google::protobuf::Arena* arena);
  Body_TurnToAngle(::google::protobuf::Arena* arena, const Body_TurnToAngle& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAngleFieldNumber = 1,
  };
  // float angle = 1;
  void clear_angle() ;
  float angle() const;
  void set_angle(float value);

  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_TurnToAngle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float angle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_StopDash final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Body_StopDash) */ {
 public:
  inline Body_StopDash() : Body_StopDash(nullptr) {}
  ~Body_StopDash() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_StopDash(::google::protobuf::internal::ConstantInitialized);

  inline Body_StopDash(const Body_StopDash& from)
      : Body_StopDash(nullptr, from) {}
  Body_StopDash(Body_StopDash&& from) noexcept
    : Body_StopDash() {
    *this = ::std::move(from);
  }

  inline Body_StopDash& operator=(const Body_StopDash& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_StopDash& operator=(Body_StopDash&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_StopDash& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_StopDash* internal_default_instance() {
    return reinterpret_cast<const Body_StopDash*>(
               &_Body_StopDash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(Body_StopDash& a, Body_StopDash& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_StopDash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_StopDash* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_StopDash* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_StopDash>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Body_StopDash& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Body_StopDash& from) {
    Body_StopDash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Body_StopDash* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_StopDash";
  }
  protected:
  explicit Body_StopDash(::google::protobuf::Arena* arena);
  Body_StopDash(::google::protobuf::Arena* arena, const Body_StopDash& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSaveRecoveryFieldNumber = 1,
  };
  // bool save_recovery = 1;
  void clear_save_recovery() ;
  bool save_recovery() const;
  void set_save_recovery(bool value);

  private:
  bool _internal_save_recovery() const;
  void _internal_set_save_recovery(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_StopDash)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool save_recovery_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_StopBall final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Body_StopBall) */ {
 public:
  inline Body_StopBall() : Body_StopBall(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_StopBall(::google::protobuf::internal::ConstantInitialized);

  inline Body_StopBall(const Body_StopBall& from)
      : Body_StopBall(nullptr, from) {}
  Body_StopBall(Body_StopBall&& from) noexcept
    : Body_StopBall() {
    *this = ::std::move(from);
  }

  inline Body_StopBall& operator=(const Body_StopBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_StopBall& operator=(Body_StopBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_StopBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_StopBall* internal_default_instance() {
    return reinterpret_cast<const Body_StopBall*>(
               &_Body_StopBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(Body_StopBall& a, Body_StopBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_StopBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_StopBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_StopBall* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_StopBall>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Body_StopBall& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Body_StopBall& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_StopBall";
  }
  protected:
  explicit Body_StopBall(::google::protobuf::Arena* arena);
  Body_StopBall(::google::protobuf::Arena* arena, const Body_StopBall& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Body_StopBall)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_ClearBall final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Body_ClearBall) */ {
 public:
  inline Body_ClearBall() : Body_ClearBall(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_ClearBall(::google::protobuf::internal::ConstantInitialized);

  inline Body_ClearBall(const Body_ClearBall& from)
      : Body_ClearBall(nullptr, from) {}
  Body_ClearBall(Body_ClearBall&& from) noexcept
    : Body_ClearBall() {
    *this = ::std::move(from);
  }

  inline Body_ClearBall& operator=(const Body_ClearBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_ClearBall& operator=(Body_ClearBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_ClearBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_ClearBall* internal_default_instance() {
    return reinterpret_cast<const Body_ClearBall*>(
               &_Body_ClearBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(Body_ClearBall& a, Body_ClearBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_ClearBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_ClearBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_ClearBall* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_ClearBall>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Body_ClearBall& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Body_ClearBall& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_ClearBall";
  }
  protected:
  explicit Body_ClearBall(::google::protobuf::Arena* arena);
  Body_ClearBall(::google::protobuf::Arena* arena, const Body_ClearBall& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Body_ClearBall)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_AdvanceBall final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Body_AdvanceBall) */ {
 public:
  inline Body_AdvanceBall() : Body_AdvanceBall(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_AdvanceBall(::google::protobuf::internal::ConstantInitialized);

  inline Body_AdvanceBall(const Body_AdvanceBall& from)
      : Body_AdvanceBall(nullptr, from) {}
  Body_AdvanceBall(Body_AdvanceBall&& from) noexcept
    : Body_AdvanceBall() {
    *this = ::std::move(from);
  }

  inline Body_AdvanceBall& operator=(const Body_AdvanceBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_AdvanceBall& operator=(Body_AdvanceBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_AdvanceBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_AdvanceBall* internal_default_instance() {
    return reinterpret_cast<const Body_AdvanceBall*>(
               &_Body_AdvanceBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(Body_AdvanceBall& a, Body_AdvanceBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_AdvanceBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_AdvanceBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_AdvanceBall* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_AdvanceBall>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Body_AdvanceBall& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Body_AdvanceBall& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_AdvanceBall";
  }
  protected:
  explicit Body_AdvanceBall(::google::protobuf::Arena* arena);
  Body_AdvanceBall(::google::protobuf::Arena* arena, const Body_AdvanceBall& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Body_AdvanceBall)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_ScanField final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Bhv_ScanField) */ {
 public:
  inline Bhv_ScanField() : Bhv_ScanField(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_ScanField(::google::protobuf::internal::ConstantInitialized);

  inline Bhv_ScanField(const Bhv_ScanField& from)
      : Bhv_ScanField(nullptr, from) {}
  Bhv_ScanField(Bhv_ScanField&& from) noexcept
    : Bhv_ScanField() {
    *this = ::std::move(from);
  }

  inline Bhv_ScanField& operator=(const Bhv_ScanField& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_ScanField& operator=(Bhv_ScanField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_ScanField& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_ScanField* internal_default_instance() {
    return reinterpret_cast<const Bhv_ScanField*>(
               &_Bhv_ScanField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(Bhv_ScanField& a, Bhv_ScanField& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_ScanField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_ScanField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_ScanField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_ScanField>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Bhv_ScanField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Bhv_ScanField& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_ScanField";
  }
  protected:
  explicit Bhv_ScanField(::google::protobuf::Arena* arena);
  Bhv_ScanField(::google::protobuf::Arena* arena, const Bhv_ScanField& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Bhv_ScanField)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_NeckBodyToBall final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Bhv_NeckBodyToBall) */ {
 public:
  inline Bhv_NeckBodyToBall() : Bhv_NeckBodyToBall(nullptr) {}
  ~Bhv_NeckBodyToBall() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_NeckBodyToBall(::google::protobuf::internal::ConstantInitialized);

  inline Bhv_NeckBodyToBall(const Bhv_NeckBodyToBall& from)
      : Bhv_NeckBodyToBall(nullptr, from) {}
  Bhv_NeckBodyToBall(Bhv_NeckBodyToBall&& from) noexcept
    : Bhv_NeckBodyToBall() {
    *this = ::std::move(from);
  }

  inline Bhv_NeckBodyToBall& operator=(const Bhv_NeckBodyToBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_NeckBodyToBall& operator=(Bhv_NeckBodyToBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_NeckBodyToBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_NeckBodyToBall* internal_default_instance() {
    return reinterpret_cast<const Bhv_NeckBodyToBall*>(
               &_Bhv_NeckBodyToBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(Bhv_NeckBodyToBall& a, Bhv_NeckBodyToBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_NeckBodyToBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_NeckBodyToBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_NeckBodyToBall* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_NeckBodyToBall>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Bhv_NeckBodyToBall& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Bhv_NeckBodyToBall& from) {
    Bhv_NeckBodyToBall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Bhv_NeckBodyToBall* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_NeckBodyToBall";
  }
  protected:
  explicit Bhv_NeckBodyToBall(::google::protobuf::Arena* arena);
  Bhv_NeckBodyToBall(::google::protobuf::Arena* arena, const Bhv_NeckBodyToBall& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAngleBufFieldNumber = 1,
  };
  // float angle_buf = 1;
  void clear_angle_buf() ;
  float angle_buf() const;
  void set_angle_buf(float value);

  private:
  float _internal_angle_buf() const;
  void _internal_set_angle_buf(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Bhv_NeckBodyToBall)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float angle_buf_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_Emergency final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Bhv_Emergency) */ {
 public:
  inline Bhv_Emergency() : Bhv_Emergency(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_Emergency(::google::protobuf::internal::ConstantInitialized);

  inline Bhv_Emergency(const Bhv_Emergency& from)
      : Bhv_Emergency(nullptr, from) {}
  Bhv_Emergency(Bhv_Emergency&& from) noexcept
    : Bhv_Emergency() {
    *this = ::std::move(from);
  }

  inline Bhv_Emergency& operator=(const Bhv_Emergency& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_Emergency& operator=(Bhv_Emergency&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_Emergency& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_Emergency* internal_default_instance() {
    return reinterpret_cast<const Bhv_Emergency*>(
               &_Bhv_Emergency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(Bhv_Emergency& a, Bhv_Emergency& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_Emergency* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_Emergency* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_Emergency* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_Emergency>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Bhv_Emergency& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Bhv_Emergency& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_Emergency";
  }
  protected:
  explicit Bhv_Emergency(::google::protobuf::Arena* arena);
  Bhv_Emergency(::google::protobuf::Arena* arena, const Bhv_Emergency& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Bhv_Emergency)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_BodyNeckToBall final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.Bhv_BodyNeckToBall) */ {
 public:
  inline Bhv_BodyNeckToBall() : Bhv_BodyNeckToBall(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_BodyNeckToBall(::google::protobuf::internal::ConstantInitialized);

  inline Bhv_BodyNeckToBall(const Bhv_BodyNeckToBall& from)
      : Bhv_BodyNeckToBall(nullptr, from) {}
  Bhv_BodyNeckToBall(Bhv_BodyNeckToBall&& from) noexcept
    : Bhv_BodyNeckToBall() {
    *this = ::std::move(from);
  }

  inline Bhv_BodyNeckToBall& operator=(const Bhv_BodyNeckToBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_BodyNeckToBall& operator=(Bhv_BodyNeckToBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_BodyNeckToBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_BodyNeckToBall* internal_default_instance() {
    return reinterpret_cast<const Bhv_BodyNeckToBall*>(
               &_Bhv_BodyNeckToBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(Bhv_BodyNeckToBall& a, Bhv_BodyNeckToBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_BodyNeckToBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_BodyNeckToBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_BodyNeckToBall* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_BodyNeckToBall>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Bhv_BodyNeckToBall& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Bhv_BodyNeckToBall& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_BodyNeckToBall";
  }
  protected:
  explicit Bhv_BodyNeckToBall(::google::protobuf::Arena* arena);
  Bhv_BodyNeckToBall(::google::protobuf::Arena* arena, const Bhv_BodyNeckToBall& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.Bhv_BodyNeckToBall)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AttentionToOf final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:protos.AttentionToOf) */ {
 public:
  inline AttentionToOf() : AttentionToOf(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AttentionToOf(::google::protobuf::internal::ConstantInitialized);

  inline AttentionToOf(const AttentionToOf& from)
      : AttentionToOf(nullptr, from) {}
  AttentionToOf(AttentionToOf&& from) noexcept
    : AttentionToOf() {
    *this = ::std::move(from);
  }

  inline AttentionToOf& operator=(const AttentionToOf& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttentionToOf& operator=(AttentionToOf&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttentionToOf& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttentionToOf* internal_default_instance() {
    return reinterpret_cast<const AttentionToOf*>(
               &_AttentionToOf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(AttentionToOf& a, AttentionToOf& b) {
    a.Swap(&b);
  }
  inline void Swap(AttentionToOf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttentionToOf* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttentionToOf* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttentionToOf>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AttentionToOf& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AttentionToOf& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AttentionToOf";
  }
  protected:
  explicit AttentionToOf(::google::protobuf::Arena* arena);
  AttentionToOf(::google::protobuf::Arena* arena, const AttentionToOf& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protos.AttentionToOf)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AttentionTo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.AttentionTo) */ {
 public:
  inline AttentionTo() : AttentionTo(nullptr) {}
  ~AttentionTo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AttentionTo(::google::protobuf::internal::ConstantInitialized);

  inline AttentionTo(const AttentionTo& from)
      : AttentionTo(nullptr, from) {}
  AttentionTo(AttentionTo&& from) noexcept
    : AttentionTo() {
    *this = ::std::move(from);
  }

  inline AttentionTo& operator=(const AttentionTo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttentionTo& operator=(AttentionTo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttentionTo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttentionTo* internal_default_instance() {
    return reinterpret_cast<const AttentionTo*>(
               &_AttentionTo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(AttentionTo& a, AttentionTo& b) {
    a.Swap(&b);
  }
  inline void Swap(AttentionTo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttentionTo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttentionTo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttentionTo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttentionTo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AttentionTo& from) {
    AttentionTo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AttentionTo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AttentionTo";
  }
  protected:
  explicit AttentionTo(::google::protobuf::Arena* arena);
  AttentionTo(::google::protobuf::Arena* arena, const AttentionTo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSideFieldNumber = 1,
    kUnumFieldNumber = 2,
  };
  // .protos.Side side = 1;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // int32 unum = 2;
  void clear_unum() ;
  ::int32_t unum() const;
  void set_unum(::int32_t value);

  private:
  ::int32_t _internal_unum() const;
  void _internal_set_unum(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AttentionTo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int side_;
    ::int32_t unum_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddText final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.AddText) */ {
 public:
  inline AddText() : AddText(nullptr) {}
  ~AddText() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddText(::google::protobuf::internal::ConstantInitialized);

  inline AddText(const AddText& from)
      : AddText(nullptr, from) {}
  AddText(AddText&& from) noexcept
    : AddText() {
    *this = ::std::move(from);
  }

  inline AddText& operator=(const AddText& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddText& operator=(AddText&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddText& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddText* internal_default_instance() {
    return reinterpret_cast<const AddText*>(
               &_AddText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(AddText& a, AddText& b) {
    a.Swap(&b);
  }
  inline void Swap(AddText* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddText* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddText* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddText>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddText& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddText& from) {
    AddText::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddText* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddText";
  }
  protected:
  explicit AddText(::google::protobuf::Arena* arena);
  AddText(::google::protobuf::Arena* arena, const AddText& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kLevelFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddText)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      30, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    int level_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddRectangle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.AddRectangle) */ {
 public:
  inline AddRectangle() : AddRectangle(nullptr) {}
  ~AddRectangle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddRectangle(::google::protobuf::internal::ConstantInitialized);

  inline AddRectangle(const AddRectangle& from)
      : AddRectangle(nullptr, from) {}
  AddRectangle(AddRectangle&& from) noexcept
    : AddRectangle() {
    *this = ::std::move(from);
  }

  inline AddRectangle& operator=(const AddRectangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddRectangle& operator=(AddRectangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddRectangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddRectangle* internal_default_instance() {
    return reinterpret_cast<const AddRectangle*>(
               &_AddRectangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(AddRectangle& a, AddRectangle& b) {
    a.Swap(&b);
  }
  inline void Swap(AddRectangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddRectangle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddRectangle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddRectangle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddRectangle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddRectangle& from) {
    AddRectangle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddRectangle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddRectangle";
  }
  protected:
  explicit AddRectangle(::google::protobuf::Arena* arena);
  AddRectangle(::google::protobuf::Arena* arena, const AddRectangle& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 6,
    kLevelFieldNumber = 1,
    kLeftFieldNumber = 2,
    kTopFieldNumber = 3,
    kLengthFieldNumber = 4,
    kWidthFieldNumber = 5,
    kFillFieldNumber = 7,
  };
  // string color = 6;
  void clear_color() ;
  const std::string& color() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* value);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // float left = 2;
  void clear_left() ;
  float left() const;
  void set_left(float value);

  private:
  float _internal_left() const;
  void _internal_set_left(float value);

  public:
  // float top = 3;
  void clear_top() ;
  float top() const;
  void set_top(float value);

  private:
  float _internal_top() const;
  void _internal_set_top(float value);

  public:
  // float length = 4;
  void clear_length() ;
  float length() const;
  void set_length(float value);

  private:
  float _internal_length() const;
  void _internal_set_length(float value);

  public:
  // float width = 5;
  void clear_width() ;
  float width() const;
  void set_width(float value);

  private:
  float _internal_width() const;
  void _internal_set_width(float value);

  public:
  // bool fill = 7;
  void clear_fill() ;
  bool fill() const;
  void set_fill(bool value);

  private:
  bool _internal_fill() const;
  void _internal_set_fill(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddRectangle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr color_;
    int level_;
    float left_;
    float top_;
    float length_;
    float width_;
    bool fill_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class WorldModel_HeliosHomePositionsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          WorldModel_HeliosHomePositionsEntry_DoNotUse, ::int32_t, ::protos::Vector2D,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      WorldModel_HeliosHomePositionsEntry_DoNotUse, ::int32_t, ::protos::Vector2D,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  WorldModel_HeliosHomePositionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorldModel_HeliosHomePositionsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit WorldModel_HeliosHomePositionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const WorldModel_HeliosHomePositionsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const WorldModel_HeliosHomePositionsEntry_DoNotUse*>(
        &_WorldModel_HeliosHomePositionsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class TwoPlayerMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.TwoPlayerMessage) */ {
 public:
  inline TwoPlayerMessage() : TwoPlayerMessage(nullptr) {}
  ~TwoPlayerMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TwoPlayerMessage(::google::protobuf::internal::ConstantInitialized);

  inline TwoPlayerMessage(const TwoPlayerMessage& from)
      : TwoPlayerMessage(nullptr, from) {}
  TwoPlayerMessage(TwoPlayerMessage&& from) noexcept
    : TwoPlayerMessage() {
    *this = ::std::move(from);
  }

  inline TwoPlayerMessage& operator=(const TwoPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TwoPlayerMessage& operator=(TwoPlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TwoPlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TwoPlayerMessage* internal_default_instance() {
    return reinterpret_cast<const TwoPlayerMessage*>(
               &_TwoPlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(TwoPlayerMessage& a, TwoPlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TwoPlayerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TwoPlayerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TwoPlayerMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TwoPlayerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TwoPlayerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TwoPlayerMessage& from) {
    TwoPlayerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TwoPlayerMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.TwoPlayerMessage";
  }
  protected:
  explicit TwoPlayerMessage(::google::protobuf::Arena* arena);
  TwoPlayerMessage(::google::protobuf::Arena* arena, const TwoPlayerMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstPositionFieldNumber = 2,
    kSecondPositionFieldNumber = 4,
    kFirstUniformNumberFieldNumber = 1,
    kSecondUniformNumberFieldNumber = 3,
  };
  // .protos.Vector2D first_position = 2;
  bool has_first_position() const;
  void clear_first_position() ;
  const ::protos::Vector2D& first_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_first_position();
  ::protos::Vector2D* mutable_first_position();
  void set_allocated_first_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_first_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_first_position();

  private:
  const ::protos::Vector2D& _internal_first_position() const;
  ::protos::Vector2D* _internal_mutable_first_position();

  public:
  // .protos.Vector2D second_position = 4;
  bool has_second_position() const;
  void clear_second_position() ;
  const ::protos::Vector2D& second_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_second_position();
  ::protos::Vector2D* mutable_second_position();
  void set_allocated_second_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_second_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_second_position();

  private:
  const ::protos::Vector2D& _internal_second_position() const;
  ::protos::Vector2D* _internal_mutable_second_position();

  public:
  // int32 first_uniform_number = 1;
  void clear_first_uniform_number() ;
  ::int32_t first_uniform_number() const;
  void set_first_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_first_uniform_number() const;
  void _internal_set_first_uniform_number(::int32_t value);

  public:
  // int32 second_uniform_number = 3;
  void clear_second_uniform_number() ;
  ::int32_t second_uniform_number() const;
  void set_second_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_second_uniform_number() const;
  void _internal_set_second_uniform_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.TwoPlayerMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* first_position_;
    ::protos::Vector2D* second_position_;
    ::int32_t first_uniform_number_;
    ::int32_t second_uniform_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class ThreePlayerMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.ThreePlayerMessage) */ {
 public:
  inline ThreePlayerMessage() : ThreePlayerMessage(nullptr) {}
  ~ThreePlayerMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ThreePlayerMessage(::google::protobuf::internal::ConstantInitialized);

  inline ThreePlayerMessage(const ThreePlayerMessage& from)
      : ThreePlayerMessage(nullptr, from) {}
  ThreePlayerMessage(ThreePlayerMessage&& from) noexcept
    : ThreePlayerMessage() {
    *this = ::std::move(from);
  }

  inline ThreePlayerMessage& operator=(const ThreePlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreePlayerMessage& operator=(ThreePlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThreePlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreePlayerMessage* internal_default_instance() {
    return reinterpret_cast<const ThreePlayerMessage*>(
               &_ThreePlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ThreePlayerMessage& a, ThreePlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreePlayerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreePlayerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreePlayerMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreePlayerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ThreePlayerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ThreePlayerMessage& from) {
    ThreePlayerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ThreePlayerMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.ThreePlayerMessage";
  }
  protected:
  explicit ThreePlayerMessage(::google::protobuf::Arena* arena);
  ThreePlayerMessage(::google::protobuf::Arena* arena, const ThreePlayerMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstPositionFieldNumber = 2,
    kSecondPositionFieldNumber = 4,
    kThirdPositionFieldNumber = 6,
    kFirstUniformNumberFieldNumber = 1,
    kSecondUniformNumberFieldNumber = 3,
    kThirdUniformNumberFieldNumber = 5,
  };
  // .protos.Vector2D first_position = 2;
  bool has_first_position() const;
  void clear_first_position() ;
  const ::protos::Vector2D& first_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_first_position();
  ::protos::Vector2D* mutable_first_position();
  void set_allocated_first_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_first_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_first_position();

  private:
  const ::protos::Vector2D& _internal_first_position() const;
  ::protos::Vector2D* _internal_mutable_first_position();

  public:
  // .protos.Vector2D second_position = 4;
  bool has_second_position() const;
  void clear_second_position() ;
  const ::protos::Vector2D& second_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_second_position();
  ::protos::Vector2D* mutable_second_position();
  void set_allocated_second_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_second_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_second_position();

  private:
  const ::protos::Vector2D& _internal_second_position() const;
  ::protos::Vector2D* _internal_mutable_second_position();

  public:
  // .protos.Vector2D third_position = 6;
  bool has_third_position() const;
  void clear_third_position() ;
  const ::protos::Vector2D& third_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_third_position();
  ::protos::Vector2D* mutable_third_position();
  void set_allocated_third_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_third_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_third_position();

  private:
  const ::protos::Vector2D& _internal_third_position() const;
  ::protos::Vector2D* _internal_mutable_third_position();

  public:
  // int32 first_uniform_number = 1;
  void clear_first_uniform_number() ;
  ::int32_t first_uniform_number() const;
  void set_first_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_first_uniform_number() const;
  void _internal_set_first_uniform_number(::int32_t value);

  public:
  // int32 second_uniform_number = 3;
  void clear_second_uniform_number() ;
  ::int32_t second_uniform_number() const;
  void set_second_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_second_uniform_number() const;
  void _internal_set_second_uniform_number(::int32_t value);

  public:
  // int32 third_uniform_number = 5;
  void clear_third_uniform_number() ;
  ::int32_t third_uniform_number() const;
  void set_third_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_third_uniform_number() const;
  void _internal_set_third_uniform_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.ThreePlayerMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* first_position_;
    ::protos::Vector2D* second_position_;
    ::protos::Vector2D* third_position_;
    ::int32_t first_uniform_number_;
    ::int32_t second_uniform_number_;
    ::int32_t third_uniform_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class TeammateMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.TeammateMessage) */ {
 public:
  inline TeammateMessage() : TeammateMessage(nullptr) {}
  ~TeammateMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TeammateMessage(::google::protobuf::internal::ConstantInitialized);

  inline TeammateMessage(const TeammateMessage& from)
      : TeammateMessage(nullptr, from) {}
  TeammateMessage(TeammateMessage&& from) noexcept
    : TeammateMessage() {
    *this = ::std::move(from);
  }

  inline TeammateMessage& operator=(const TeammateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeammateMessage& operator=(TeammateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeammateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeammateMessage* internal_default_instance() {
    return reinterpret_cast<const TeammateMessage*>(
               &_TeammateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(TeammateMessage& a, TeammateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TeammateMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeammateMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TeammateMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TeammateMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TeammateMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TeammateMessage& from) {
    TeammateMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TeammateMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.TeammateMessage";
  }
  protected:
  explicit TeammateMessage(::google::protobuf::Arena* arena);
  TeammateMessage(::google::protobuf::Arena* arena, const TeammateMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kUniformNumberFieldNumber = 1,
    kBodyDirectionFieldNumber = 3,
  };
  // .protos.Vector2D position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_position();

  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();

  public:
  // int32 uniform_number = 1;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // float body_direction = 3;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.TeammateMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::int32_t uniform_number_;
    float body_direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class SelfMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.SelfMessage) */ {
 public:
  inline SelfMessage() : SelfMessage(nullptr) {}
  ~SelfMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SelfMessage(::google::protobuf::internal::ConstantInitialized);

  inline SelfMessage(const SelfMessage& from)
      : SelfMessage(nullptr, from) {}
  SelfMessage(SelfMessage&& from) noexcept
    : SelfMessage() {
    *this = ::std::move(from);
  }

  inline SelfMessage& operator=(const SelfMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelfMessage& operator=(SelfMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelfMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelfMessage* internal_default_instance() {
    return reinterpret_cast<const SelfMessage*>(
               &_SelfMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SelfMessage& a, SelfMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SelfMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelfMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelfMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelfMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SelfMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SelfMessage& from) {
    SelfMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SelfMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.SelfMessage";
  }
  protected:
  explicit SelfMessage(::google::protobuf::Arena* arena);
  SelfMessage(::google::protobuf::Arena* arena, const SelfMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelfPositionFieldNumber = 1,
    kSelfBodyDirectionFieldNumber = 2,
    kSelfStaminaFieldNumber = 3,
  };
  // .protos.Vector2D self_position = 1;
  bool has_self_position() const;
  void clear_self_position() ;
  const ::protos::Vector2D& self_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_self_position();
  ::protos::Vector2D* mutable_self_position();
  void set_allocated_self_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_self_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_self_position();

  private:
  const ::protos::Vector2D& _internal_self_position() const;
  ::protos::Vector2D* _internal_mutable_self_position();

  public:
  // float self_body_direction = 2;
  void clear_self_body_direction() ;
  float self_body_direction() const;
  void set_self_body_direction(float value);

  private:
  float _internal_self_body_direction() const;
  void _internal_set_self_body_direction(float value);

  public:
  // float self_stamina = 3;
  void clear_self_stamina() ;
  float self_stamina() const;
  void set_self_stamina(float value);

  private:
  float _internal_self_stamina() const;
  void _internal_set_self_stamina(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.SelfMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* self_position_;
    float self_body_direction_;
    float self_stamina_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Self final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Self) */ {
 public:
  inline Self() : Self(nullptr) {}
  ~Self() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Self(::google::protobuf::internal::ConstantInitialized);

  inline Self(const Self& from)
      : Self(nullptr, from) {}
  Self(Self&& from) noexcept
    : Self() {
    *this = ::std::move(from);
  }

  inline Self& operator=(const Self& from) {
    CopyFrom(from);
    return *this;
  }
  inline Self& operator=(Self&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Self& default_instance() {
    return *internal_default_instance();
  }
  static inline const Self* internal_default_instance() {
    return reinterpret_cast<const Self*>(
               &_Self_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Self& a, Self& b) {
    a.Swap(&b);
  }
  inline void Swap(Self* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Self* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Self* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Self>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Self& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Self& from) {
    Self::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Self* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Self";
  }
  protected:
  explicit Self(::google::protobuf::Arena* arena);
  Self(::google::protobuf::Arena* arena, const Self& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kSeenPositionFieldNumber = 2,
    kHeardPositionFieldNumber = 3,
    kVelocityFieldNumber = 4,
    kSeenVelocityFieldNumber = 5,
    kPosCountFieldNumber = 6,
    kSeenPosCountFieldNumber = 7,
    kHeardPosCountFieldNumber = 8,
    kVelCountFieldNumber = 9,
    kSeenVelCountFieldNumber = 10,
    kGhostCountFieldNumber = 11,
    kIdFieldNumber = 12,
    kSideFieldNumber = 13,
    kUniformNumberFieldNumber = 14,
    kUniformNumberCountFieldNumber = 15,
    kBodyDirectionFieldNumber = 17,
    kBodyDirectionCountFieldNumber = 18,
    kFaceDirectionFieldNumber = 19,
    kFaceDirectionCountFieldNumber = 20,
    kPointToDirectionFieldNumber = 21,
    kPointToDirectionCountFieldNumber = 22,
    kDistFromBallFieldNumber = 24,
    kIsGoalieFieldNumber = 16,
    kIsKickingFieldNumber = 23,
    kIsTacklingFieldNumber = 27,
    kIsKickableFieldNumber = 30,
    kAngleFromBallFieldNumber = 25,
    kBallReachStepsFieldNumber = 26,
    kRelativeNeckDirectionFieldNumber = 28,
    kStaminaFieldNumber = 29,
    kCatchProbabilityFieldNumber = 31,
    kTackleProbabilityFieldNumber = 32,
    kFoulProbabilityFieldNumber = 33,
    kViewWidthFieldNumber = 34,
    kTypeIdFieldNumber = 35,
    kKickRateFieldNumber = 36,
  };
  // .protos.Vector2D position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_position();

  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();

  public:
  // .protos.Vector2D seen_position = 2;
  bool has_seen_position() const;
  void clear_seen_position() ;
  const ::protos::Vector2D& seen_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_position();
  ::protos::Vector2D* mutable_seen_position();
  void set_allocated_seen_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_seen_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_seen_position();

  private:
  const ::protos::Vector2D& _internal_seen_position() const;
  ::protos::Vector2D* _internal_mutable_seen_position();

  public:
  // .protos.Vector2D heard_position = 3;
  bool has_heard_position() const;
  void clear_heard_position() ;
  const ::protos::Vector2D& heard_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_heard_position();
  ::protos::Vector2D* mutable_heard_position();
  void set_allocated_heard_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_heard_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_heard_position();

  private:
  const ::protos::Vector2D& _internal_heard_position() const;
  ::protos::Vector2D* _internal_mutable_heard_position();

  public:
  // .protos.Vector2D velocity = 4;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::protos::Vector2D& velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_velocity();
  ::protos::Vector2D* mutable_velocity();
  void set_allocated_velocity(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_velocity(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_velocity();

  private:
  const ::protos::Vector2D& _internal_velocity() const;
  ::protos::Vector2D* _internal_mutable_velocity();

  public:
  // .protos.Vector2D seen_velocity = 5;
  bool has_seen_velocity() const;
  void clear_seen_velocity() ;
  const ::protos::Vector2D& seen_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_velocity();
  ::protos::Vector2D* mutable_seen_velocity();
  void set_allocated_seen_velocity(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_seen_velocity(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_seen_velocity();

  private:
  const ::protos::Vector2D& _internal_seen_velocity() const;
  ::protos::Vector2D* _internal_mutable_seen_velocity();

  public:
  // int32 pos_count = 6;
  void clear_pos_count() ;
  ::int32_t pos_count() const;
  void set_pos_count(::int32_t value);

  private:
  ::int32_t _internal_pos_count() const;
  void _internal_set_pos_count(::int32_t value);

  public:
  // int32 seen_pos_count = 7;
  void clear_seen_pos_count() ;
  ::int32_t seen_pos_count() const;
  void set_seen_pos_count(::int32_t value);

  private:
  ::int32_t _internal_seen_pos_count() const;
  void _internal_set_seen_pos_count(::int32_t value);

  public:
  // int32 heard_pos_count = 8;
  void clear_heard_pos_count() ;
  ::int32_t heard_pos_count() const;
  void set_heard_pos_count(::int32_t value);

  private:
  ::int32_t _internal_heard_pos_count() const;
  void _internal_set_heard_pos_count(::int32_t value);

  public:
  // int32 vel_count = 9;
  void clear_vel_count() ;
  ::int32_t vel_count() const;
  void set_vel_count(::int32_t value);

  private:
  ::int32_t _internal_vel_count() const;
  void _internal_set_vel_count(::int32_t value);

  public:
  // int32 seen_vel_count = 10;
  void clear_seen_vel_count() ;
  ::int32_t seen_vel_count() const;
  void set_seen_vel_count(::int32_t value);

  private:
  ::int32_t _internal_seen_vel_count() const;
  void _internal_set_seen_vel_count(::int32_t value);

  public:
  // int32 ghost_count = 11;
  void clear_ghost_count() ;
  ::int32_t ghost_count() const;
  void set_ghost_count(::int32_t value);

  private:
  ::int32_t _internal_ghost_count() const;
  void _internal_set_ghost_count(::int32_t value);

  public:
  // int32 id = 12;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .protos.Side side = 13;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // int32 uniform_number = 14;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 uniform_number_count = 15;
  void clear_uniform_number_count() ;
  ::int32_t uniform_number_count() const;
  void set_uniform_number_count(::int32_t value);

  private:
  ::int32_t _internal_uniform_number_count() const;
  void _internal_set_uniform_number_count(::int32_t value);

  public:
  // float body_direction = 17;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // int32 body_direction_count = 18;
  void clear_body_direction_count() ;
  ::int32_t body_direction_count() const;
  void set_body_direction_count(::int32_t value);

  private:
  ::int32_t _internal_body_direction_count() const;
  void _internal_set_body_direction_count(::int32_t value);

  public:
  // float face_direction = 19;
  void clear_face_direction() ;
  float face_direction() const;
  void set_face_direction(float value);

  private:
  float _internal_face_direction() const;
  void _internal_set_face_direction(float value);

  public:
  // int32 face_direction_count = 20;
  void clear_face_direction_count() ;
  ::int32_t face_direction_count() const;
  void set_face_direction_count(::int32_t value);

  private:
  ::int32_t _internal_face_direction_count() const;
  void _internal_set_face_direction_count(::int32_t value);

  public:
  // float point_to_direction = 21;
  void clear_point_to_direction() ;
  float point_to_direction() const;
  void set_point_to_direction(float value);

  private:
  float _internal_point_to_direction() const;
  void _internal_set_point_to_direction(float value);

  public:
  // int32 point_to_direction_count = 22;
  void clear_point_to_direction_count() ;
  ::int32_t point_to_direction_count() const;
  void set_point_to_direction_count(::int32_t value);

  private:
  ::int32_t _internal_point_to_direction_count() const;
  void _internal_set_point_to_direction_count(::int32_t value);

  public:
  // float dist_from_ball = 24;
  void clear_dist_from_ball() ;
  float dist_from_ball() const;
  void set_dist_from_ball(float value);

  private:
  float _internal_dist_from_ball() const;
  void _internal_set_dist_from_ball(float value);

  public:
  // bool is_goalie = 16;
  void clear_is_goalie() ;
  bool is_goalie() const;
  void set_is_goalie(bool value);

  private:
  bool _internal_is_goalie() const;
  void _internal_set_is_goalie(bool value);

  public:
  // bool is_kicking = 23;
  void clear_is_kicking() ;
  bool is_kicking() const;
  void set_is_kicking(bool value);

  private:
  bool _internal_is_kicking() const;
  void _internal_set_is_kicking(bool value);

  public:
  // bool is_tackling = 27;
  void clear_is_tackling() ;
  bool is_tackling() const;
  void set_is_tackling(bool value);

  private:
  bool _internal_is_tackling() const;
  void _internal_set_is_tackling(bool value);

  public:
  // bool is_kickable = 30;
  void clear_is_kickable() ;
  bool is_kickable() const;
  void set_is_kickable(bool value);

  private:
  bool _internal_is_kickable() const;
  void _internal_set_is_kickable(bool value);

  public:
  // float angle_from_ball = 25;
  void clear_angle_from_ball() ;
  float angle_from_ball() const;
  void set_angle_from_ball(float value);

  private:
  float _internal_angle_from_ball() const;
  void _internal_set_angle_from_ball(float value);

  public:
  // int32 ball_reach_steps = 26;
  void clear_ball_reach_steps() ;
  ::int32_t ball_reach_steps() const;
  void set_ball_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_ball_reach_steps() const;
  void _internal_set_ball_reach_steps(::int32_t value);

  public:
  // float relative_neck_direction = 28;
  void clear_relative_neck_direction() ;
  float relative_neck_direction() const;
  void set_relative_neck_direction(float value);

  private:
  float _internal_relative_neck_direction() const;
  void _internal_set_relative_neck_direction(float value);

  public:
  // float stamina = 29;
  void clear_stamina() ;
  float stamina() const;
  void set_stamina(float value);

  private:
  float _internal_stamina() const;
  void _internal_set_stamina(float value);

  public:
  // float catch_probability = 31;
  void clear_catch_probability() ;
  float catch_probability() const;
  void set_catch_probability(float value);

  private:
  float _internal_catch_probability() const;
  void _internal_set_catch_probability(float value);

  public:
  // float tackle_probability = 32;
  void clear_tackle_probability() ;
  float tackle_probability() const;
  void set_tackle_probability(float value);

  private:
  float _internal_tackle_probability() const;
  void _internal_set_tackle_probability(float value);

  public:
  // float foul_probability = 33;
  void clear_foul_probability() ;
  float foul_probability() const;
  void set_foul_probability(float value);

  private:
  float _internal_foul_probability() const;
  void _internal_set_foul_probability(float value);

  public:
  // .protos.ViewWidth view_width = 34;
  void clear_view_width() ;
  ::protos::ViewWidth view_width() const;
  void set_view_width(::protos::ViewWidth value);

  private:
  ::protos::ViewWidth _internal_view_width() const;
  void _internal_set_view_width(::protos::ViewWidth value);

  public:
  // int32 type_id = 35;
  void clear_type_id() ;
  ::int32_t type_id() const;
  void set_type_id(::int32_t value);

  private:
  ::int32_t _internal_type_id() const;
  void _internal_set_type_id(::int32_t value);

  public:
  // float kick_rate = 36;
  void clear_kick_rate() ;
  float kick_rate() const;
  void set_kick_rate(float value);

  private:
  float _internal_kick_rate() const;
  void _internal_set_kick_rate(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Self)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 36, 5,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::protos::Vector2D* seen_position_;
    ::protos::Vector2D* heard_position_;
    ::protos::Vector2D* velocity_;
    ::protos::Vector2D* seen_velocity_;
    ::int32_t pos_count_;
    ::int32_t seen_pos_count_;
    ::int32_t heard_pos_count_;
    ::int32_t vel_count_;
    ::int32_t seen_vel_count_;
    ::int32_t ghost_count_;
    ::int32_t id_;
    int side_;
    ::int32_t uniform_number_;
    ::int32_t uniform_number_count_;
    float body_direction_;
    ::int32_t body_direction_count_;
    float face_direction_;
    ::int32_t face_direction_count_;
    float point_to_direction_;
    ::int32_t point_to_direction_count_;
    float dist_from_ball_;
    bool is_goalie_;
    bool is_kicking_;
    bool is_tackling_;
    bool is_kickable_;
    float angle_from_ball_;
    ::int32_t ball_reach_steps_;
    float relative_neck_direction_;
    float stamina_;
    float catch_probability_;
    float tackle_probability_;
    float foul_probability_;
    int view_width_;
    ::int32_t type_id_;
    float kick_rate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Player final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Player(::google::protobuf::internal::ConstantInitialized);

  inline Player(const Player& from)
      : Player(nullptr, from) {}
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Player& from) {
    Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Player* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Player";
  }
  protected:
  explicit Player(::google::protobuf::Arena* arena);
  Player(::google::protobuf::Arena* arena, const Player& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kSeenPositionFieldNumber = 2,
    kHeardPositionFieldNumber = 3,
    kVelocityFieldNumber = 4,
    kSeenVelocityFieldNumber = 5,
    kPosCountFieldNumber = 6,
    kSeenPosCountFieldNumber = 7,
    kHeardPosCountFieldNumber = 8,
    kVelCountFieldNumber = 9,
    kSeenVelCountFieldNumber = 10,
    kGhostCountFieldNumber = 11,
    kDistFromSelfFieldNumber = 12,
    kAngleFromSelfFieldNumber = 13,
    kIdFieldNumber = 14,
    kSideFieldNumber = 15,
    kUniformNumberFieldNumber = 16,
    kUniformNumberCountFieldNumber = 17,
    kBodyDirectionFieldNumber = 19,
    kBodyDirectionCountFieldNumber = 20,
    kFaceDirectionFieldNumber = 21,
    kFaceDirectionCountFieldNumber = 22,
    kPointToDirectionFieldNumber = 23,
    kPointToDirectionCountFieldNumber = 24,
    kIsGoalieFieldNumber = 18,
    kIsKickingFieldNumber = 25,
    kIsTacklingFieldNumber = 29,
    kDistFromBallFieldNumber = 26,
    kAngleFromBallFieldNumber = 27,
    kBallReachStepsFieldNumber = 28,
    kTypeIdFieldNumber = 30,
  };
  // .protos.Vector2D position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_position();

  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();

  public:
  // .protos.Vector2D seen_position = 2;
  bool has_seen_position() const;
  void clear_seen_position() ;
  const ::protos::Vector2D& seen_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_position();
  ::protos::Vector2D* mutable_seen_position();
  void set_allocated_seen_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_seen_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_seen_position();

  private:
  const ::protos::Vector2D& _internal_seen_position() const;
  ::protos::Vector2D* _internal_mutable_seen_position();

  public:
  // .protos.Vector2D heard_position = 3;
  bool has_heard_position() const;
  void clear_heard_position() ;
  const ::protos::Vector2D& heard_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_heard_position();
  ::protos::Vector2D* mutable_heard_position();
  void set_allocated_heard_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_heard_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_heard_position();

  private:
  const ::protos::Vector2D& _internal_heard_position() const;
  ::protos::Vector2D* _internal_mutable_heard_position();

  public:
  // .protos.Vector2D velocity = 4;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::protos::Vector2D& velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_velocity();
  ::protos::Vector2D* mutable_velocity();
  void set_allocated_velocity(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_velocity(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_velocity();

  private:
  const ::protos::Vector2D& _internal_velocity() const;
  ::protos::Vector2D* _internal_mutable_velocity();

  public:
  // .protos.Vector2D seen_velocity = 5;
  bool has_seen_velocity() const;
  void clear_seen_velocity() ;
  const ::protos::Vector2D& seen_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_velocity();
  ::protos::Vector2D* mutable_seen_velocity();
  void set_allocated_seen_velocity(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_seen_velocity(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_seen_velocity();

  private:
  const ::protos::Vector2D& _internal_seen_velocity() const;
  ::protos::Vector2D* _internal_mutable_seen_velocity();

  public:
  // int32 pos_count = 6;
  void clear_pos_count() ;
  ::int32_t pos_count() const;
  void set_pos_count(::int32_t value);

  private:
  ::int32_t _internal_pos_count() const;
  void _internal_set_pos_count(::int32_t value);

  public:
  // int32 seen_pos_count = 7;
  void clear_seen_pos_count() ;
  ::int32_t seen_pos_count() const;
  void set_seen_pos_count(::int32_t value);

  private:
  ::int32_t _internal_seen_pos_count() const;
  void _internal_set_seen_pos_count(::int32_t value);

  public:
  // int32 heard_pos_count = 8;
  void clear_heard_pos_count() ;
  ::int32_t heard_pos_count() const;
  void set_heard_pos_count(::int32_t value);

  private:
  ::int32_t _internal_heard_pos_count() const;
  void _internal_set_heard_pos_count(::int32_t value);

  public:
  // int32 vel_count = 9;
  void clear_vel_count() ;
  ::int32_t vel_count() const;
  void set_vel_count(::int32_t value);

  private:
  ::int32_t _internal_vel_count() const;
  void _internal_set_vel_count(::int32_t value);

  public:
  // int32 seen_vel_count = 10;
  void clear_seen_vel_count() ;
  ::int32_t seen_vel_count() const;
  void set_seen_vel_count(::int32_t value);

  private:
  ::int32_t _internal_seen_vel_count() const;
  void _internal_set_seen_vel_count(::int32_t value);

  public:
  // int32 ghost_count = 11;
  void clear_ghost_count() ;
  ::int32_t ghost_count() const;
  void set_ghost_count(::int32_t value);

  private:
  ::int32_t _internal_ghost_count() const;
  void _internal_set_ghost_count(::int32_t value);

  public:
  // float dist_from_self = 12;
  void clear_dist_from_self() ;
  float dist_from_self() const;
  void set_dist_from_self(float value);

  private:
  float _internal_dist_from_self() const;
  void _internal_set_dist_from_self(float value);

  public:
  // float angle_from_self = 13;
  void clear_angle_from_self() ;
  float angle_from_self() const;
  void set_angle_from_self(float value);

  private:
  float _internal_angle_from_self() const;
  void _internal_set_angle_from_self(float value);

  public:
  // int32 id = 14;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .protos.Side side = 15;
  void clear_side() ;
  ::protos::Side side() const;
  void set_side(::protos::Side value);

  private:
  ::protos::Side _internal_side() const;
  void _internal_set_side(::protos::Side value);

  public:
  // int32 uniform_number = 16;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // int32 uniform_number_count = 17;
  void clear_uniform_number_count() ;
  ::int32_t uniform_number_count() const;
  void set_uniform_number_count(::int32_t value);

  private:
  ::int32_t _internal_uniform_number_count() const;
  void _internal_set_uniform_number_count(::int32_t value);

  public:
  // float body_direction = 19;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // int32 body_direction_count = 20;
  void clear_body_direction_count() ;
  ::int32_t body_direction_count() const;
  void set_body_direction_count(::int32_t value);

  private:
  ::int32_t _internal_body_direction_count() const;
  void _internal_set_body_direction_count(::int32_t value);

  public:
  // float face_direction = 21;
  void clear_face_direction() ;
  float face_direction() const;
  void set_face_direction(float value);

  private:
  float _internal_face_direction() const;
  void _internal_set_face_direction(float value);

  public:
  // int32 face_direction_count = 22;
  void clear_face_direction_count() ;
  ::int32_t face_direction_count() const;
  void set_face_direction_count(::int32_t value);

  private:
  ::int32_t _internal_face_direction_count() const;
  void _internal_set_face_direction_count(::int32_t value);

  public:
  // float point_to_direction = 23;
  void clear_point_to_direction() ;
  float point_to_direction() const;
  void set_point_to_direction(float value);

  private:
  float _internal_point_to_direction() const;
  void _internal_set_point_to_direction(float value);

  public:
  // int32 point_to_direction_count = 24;
  void clear_point_to_direction_count() ;
  ::int32_t point_to_direction_count() const;
  void set_point_to_direction_count(::int32_t value);

  private:
  ::int32_t _internal_point_to_direction_count() const;
  void _internal_set_point_to_direction_count(::int32_t value);

  public:
  // bool is_goalie = 18;
  void clear_is_goalie() ;
  bool is_goalie() const;
  void set_is_goalie(bool value);

  private:
  bool _internal_is_goalie() const;
  void _internal_set_is_goalie(bool value);

  public:
  // bool is_kicking = 25;
  void clear_is_kicking() ;
  bool is_kicking() const;
  void set_is_kicking(bool value);

  private:
  bool _internal_is_kicking() const;
  void _internal_set_is_kicking(bool value);

  public:
  // bool is_tackling = 29;
  void clear_is_tackling() ;
  bool is_tackling() const;
  void set_is_tackling(bool value);

  private:
  bool _internal_is_tackling() const;
  void _internal_set_is_tackling(bool value);

  public:
  // float dist_from_ball = 26;
  void clear_dist_from_ball() ;
  float dist_from_ball() const;
  void set_dist_from_ball(float value);

  private:
  float _internal_dist_from_ball() const;
  void _internal_set_dist_from_ball(float value);

  public:
  // float angle_from_ball = 27;
  void clear_angle_from_ball() ;
  float angle_from_ball() const;
  void set_angle_from_ball(float value);

  private:
  float _internal_angle_from_ball() const;
  void _internal_set_angle_from_ball(float value);

  public:
  // int32 ball_reach_steps = 28;
  void clear_ball_reach_steps() ;
  ::int32_t ball_reach_steps() const;
  void set_ball_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_ball_reach_steps() const;
  void _internal_set_ball_reach_steps(::int32_t value);

  public:
  // int32 type_id = 30;
  void clear_type_id() ;
  ::int32_t type_id() const;
  void set_type_id(::int32_t value);

  private:
  ::int32_t _internal_type_id() const;
  void _internal_set_type_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Player)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 30, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::protos::Vector2D* seen_position_;
    ::protos::Vector2D* heard_position_;
    ::protos::Vector2D* velocity_;
    ::protos::Vector2D* seen_velocity_;
    ::int32_t pos_count_;
    ::int32_t seen_pos_count_;
    ::int32_t heard_pos_count_;
    ::int32_t vel_count_;
    ::int32_t seen_vel_count_;
    ::int32_t ghost_count_;
    float dist_from_self_;
    float angle_from_self_;
    ::int32_t id_;
    int side_;
    ::int32_t uniform_number_;
    ::int32_t uniform_number_count_;
    float body_direction_;
    ::int32_t body_direction_count_;
    float face_direction_;
    ::int32_t face_direction_count_;
    float point_to_direction_;
    ::int32_t point_to_direction_count_;
    bool is_goalie_;
    bool is_kicking_;
    bool is_tackling_;
    float dist_from_ball_;
    float angle_from_ball_;
    ::int32_t ball_reach_steps_;
    ::int32_t type_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PassRequestMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.PassRequestMessage) */ {
 public:
  inline PassRequestMessage() : PassRequestMessage(nullptr) {}
  ~PassRequestMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PassRequestMessage(::google::protobuf::internal::ConstantInitialized);

  inline PassRequestMessage(const PassRequestMessage& from)
      : PassRequestMessage(nullptr, from) {}
  PassRequestMessage(PassRequestMessage&& from) noexcept
    : PassRequestMessage() {
    *this = ::std::move(from);
  }

  inline PassRequestMessage& operator=(const PassRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PassRequestMessage& operator=(PassRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PassRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PassRequestMessage* internal_default_instance() {
    return reinterpret_cast<const PassRequestMessage*>(
               &_PassRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(PassRequestMessage& a, PassRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PassRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PassRequestMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PassRequestMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PassRequestMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PassRequestMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PassRequestMessage& from) {
    PassRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PassRequestMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PassRequestMessage";
  }
  protected:
  explicit PassRequestMessage(::google::protobuf::Arena* arena);
  PassRequestMessage(::google::protobuf::Arena* arena, const PassRequestMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_target_point();

  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();

  public:
  // @@protoc_insertion_point(class_scope:protos.PassRequestMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PassMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.PassMessage) */ {
 public:
  inline PassMessage() : PassMessage(nullptr) {}
  ~PassMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PassMessage(::google::protobuf::internal::ConstantInitialized);

  inline PassMessage(const PassMessage& from)
      : PassMessage(nullptr, from) {}
  PassMessage(PassMessage&& from) noexcept
    : PassMessage() {
    *this = ::std::move(from);
  }

  inline PassMessage& operator=(const PassMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PassMessage& operator=(PassMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PassMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PassMessage* internal_default_instance() {
    return reinterpret_cast<const PassMessage*>(
               &_PassMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PassMessage& a, PassMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PassMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PassMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PassMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PassMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PassMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PassMessage& from) {
    PassMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PassMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PassMessage";
  }
  protected:
  explicit PassMessage(::google::protobuf::Arena* arena);
  PassMessage(::google::protobuf::Arena* arena, const PassMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiverPointFieldNumber = 2,
    kBallPositionFieldNumber = 3,
    kBallVelocityFieldNumber = 4,
    kReceiverUniformNumberFieldNumber = 1,
  };
  // .protos.Vector2D receiver_point = 2;
  bool has_receiver_point() const;
  void clear_receiver_point() ;
  const ::protos::Vector2D& receiver_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_receiver_point();
  ::protos::Vector2D* mutable_receiver_point();
  void set_allocated_receiver_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_receiver_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_receiver_point();

  private:
  const ::protos::Vector2D& _internal_receiver_point() const;
  ::protos::Vector2D* _internal_mutable_receiver_point();

  public:
  // .protos.Vector2D ball_position = 3;
  bool has_ball_position() const;
  void clear_ball_position() ;
  const ::protos::Vector2D& ball_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_position();
  ::protos::Vector2D* mutable_ball_position();
  void set_allocated_ball_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_ball_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_ball_position();

  private:
  const ::protos::Vector2D& _internal_ball_position() const;
  ::protos::Vector2D* _internal_mutable_ball_position();

  public:
  // .protos.Vector2D ball_velocity = 4;
  bool has_ball_velocity() const;
  void clear_ball_velocity() ;
  const ::protos::Vector2D& ball_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_velocity();
  ::protos::Vector2D* mutable_ball_velocity();
  void set_allocated_ball_velocity(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_ball_velocity(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_ball_velocity();

  private:
  const ::protos::Vector2D& _internal_ball_velocity() const;
  ::protos::Vector2D* _internal_mutable_ball_velocity();

  public:
  // int32 receiver_uniform_number = 1;
  void clear_receiver_uniform_number() ;
  ::int32_t receiver_uniform_number() const;
  void set_receiver_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_receiver_uniform_number() const;
  void _internal_set_receiver_uniform_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.PassMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* receiver_point_;
    ::protos::Vector2D* ball_position_;
    ::protos::Vector2D* ball_velocity_;
    ::int32_t receiver_uniform_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class OpponentMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.OpponentMessage) */ {
 public:
  inline OpponentMessage() : OpponentMessage(nullptr) {}
  ~OpponentMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OpponentMessage(::google::protobuf::internal::ConstantInitialized);

  inline OpponentMessage(const OpponentMessage& from)
      : OpponentMessage(nullptr, from) {}
  OpponentMessage(OpponentMessage&& from) noexcept
    : OpponentMessage() {
    *this = ::std::move(from);
  }

  inline OpponentMessage& operator=(const OpponentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpponentMessage& operator=(OpponentMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpponentMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpponentMessage* internal_default_instance() {
    return reinterpret_cast<const OpponentMessage*>(
               &_OpponentMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(OpponentMessage& a, OpponentMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OpponentMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpponentMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpponentMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpponentMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OpponentMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OpponentMessage& from) {
    OpponentMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OpponentMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.OpponentMessage";
  }
  protected:
  explicit OpponentMessage(::google::protobuf::Arena* arena);
  OpponentMessage(::google::protobuf::Arena* arena, const OpponentMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kUniformNumberFieldNumber = 1,
    kBodyDirectionFieldNumber = 3,
  };
  // .protos.Vector2D position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_position();

  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();

  public:
  // int32 uniform_number = 1;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // float body_direction = 3;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.OpponentMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::int32_t uniform_number_;
    float body_direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class OnePlayerMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.OnePlayerMessage) */ {
 public:
  inline OnePlayerMessage() : OnePlayerMessage(nullptr) {}
  ~OnePlayerMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OnePlayerMessage(::google::protobuf::internal::ConstantInitialized);

  inline OnePlayerMessage(const OnePlayerMessage& from)
      : OnePlayerMessage(nullptr, from) {}
  OnePlayerMessage(OnePlayerMessage&& from) noexcept
    : OnePlayerMessage() {
    *this = ::std::move(from);
  }

  inline OnePlayerMessage& operator=(const OnePlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnePlayerMessage& operator=(OnePlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnePlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnePlayerMessage* internal_default_instance() {
    return reinterpret_cast<const OnePlayerMessage*>(
               &_OnePlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(OnePlayerMessage& a, OnePlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OnePlayerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnePlayerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnePlayerMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnePlayerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OnePlayerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OnePlayerMessage& from) {
    OnePlayerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OnePlayerMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.OnePlayerMessage";
  }
  protected:
  explicit OnePlayerMessage(::google::protobuf::Arena* arena);
  OnePlayerMessage(::google::protobuf::Arena* arena, const OnePlayerMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kUniformNumberFieldNumber = 1,
  };
  // .protos.Vector2D position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_position();

  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();

  public:
  // int32 uniform_number = 1;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.OnePlayerMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::int32_t uniform_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Neck_TurnToPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Neck_TurnToPoint) */ {
 public:
  inline Neck_TurnToPoint() : Neck_TurnToPoint(nullptr) {}
  ~Neck_TurnToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Neck_TurnToPoint(::google::protobuf::internal::ConstantInitialized);

  inline Neck_TurnToPoint(const Neck_TurnToPoint& from)
      : Neck_TurnToPoint(nullptr, from) {}
  Neck_TurnToPoint(Neck_TurnToPoint&& from) noexcept
    : Neck_TurnToPoint() {
    *this = ::std::move(from);
  }

  inline Neck_TurnToPoint& operator=(const Neck_TurnToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neck_TurnToPoint& operator=(Neck_TurnToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neck_TurnToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neck_TurnToPoint* internal_default_instance() {
    return reinterpret_cast<const Neck_TurnToPoint*>(
               &_Neck_TurnToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(Neck_TurnToPoint& a, Neck_TurnToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Neck_TurnToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neck_TurnToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neck_TurnToPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neck_TurnToPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Neck_TurnToPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Neck_TurnToPoint& from) {
    Neck_TurnToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Neck_TurnToPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Neck_TurnToPoint";
  }
  protected:
  explicit Neck_TurnToPoint(::google::protobuf::Arena* arena);
  Neck_TurnToPoint(::google::protobuf::Arena* arena, const Neck_TurnToPoint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_target_point();

  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();

  public:
  // @@protoc_insertion_point(class_scope:protos.Neck_TurnToPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class InterceptInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.InterceptInfo) */ {
 public:
  inline InterceptInfo() : InterceptInfo(nullptr) {}
  ~InterceptInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterceptInfo(::google::protobuf::internal::ConstantInitialized);

  inline InterceptInfo(const InterceptInfo& from)
      : InterceptInfo(nullptr, from) {}
  InterceptInfo(InterceptInfo&& from) noexcept
    : InterceptInfo() {
    *this = ::std::move(from);
  }

  inline InterceptInfo& operator=(const InterceptInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterceptInfo& operator=(InterceptInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterceptInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterceptInfo* internal_default_instance() {
    return reinterpret_cast<const InterceptInfo*>(
               &_InterceptInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InterceptInfo& a, InterceptInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(InterceptInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterceptInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterceptInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterceptInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InterceptInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InterceptInfo& from) {
    InterceptInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InterceptInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.InterceptInfo";
  }
  protected:
  explicit InterceptInfo(::google::protobuf::Arena* arena);
  InterceptInfo(::google::protobuf::Arena* arena, const InterceptInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFinalSelfPositionFieldNumber = 7,
    kActionTypeFieldNumber = 1,
    kTurnStepsFieldNumber = 2,
    kTurnAngleFieldNumber = 3,
    kDashStepsFieldNumber = 4,
    kDashPowerFieldNumber = 5,
    kDashDirFieldNumber = 6,
    kFinalBallDistFieldNumber = 8,
    kFinalStaminaFieldNumber = 9,
    kValueFieldNumber = 10,
  };
  // .protos.Vector2D final_self_position = 7;
  bool has_final_self_position() const;
  void clear_final_self_position() ;
  const ::protos::Vector2D& final_self_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_final_self_position();
  ::protos::Vector2D* mutable_final_self_position();
  void set_allocated_final_self_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_final_self_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_final_self_position();

  private:
  const ::protos::Vector2D& _internal_final_self_position() const;
  ::protos::Vector2D* _internal_mutable_final_self_position();

  public:
  // .protos.InterceptActionType action_type = 1;
  void clear_action_type() ;
  ::protos::InterceptActionType action_type() const;
  void set_action_type(::protos::InterceptActionType value);

  private:
  ::protos::InterceptActionType _internal_action_type() const;
  void _internal_set_action_type(::protos::InterceptActionType value);

  public:
  // int32 turn_steps = 2;
  void clear_turn_steps() ;
  ::int32_t turn_steps() const;
  void set_turn_steps(::int32_t value);

  private:
  ::int32_t _internal_turn_steps() const;
  void _internal_set_turn_steps(::int32_t value);

  public:
  // float turn_angle = 3;
  void clear_turn_angle() ;
  float turn_angle() const;
  void set_turn_angle(float value);

  private:
  float _internal_turn_angle() const;
  void _internal_set_turn_angle(float value);

  public:
  // int32 dash_steps = 4;
  void clear_dash_steps() ;
  ::int32_t dash_steps() const;
  void set_dash_steps(::int32_t value);

  private:
  ::int32_t _internal_dash_steps() const;
  void _internal_set_dash_steps(::int32_t value);

  public:
  // float dash_power = 5;
  void clear_dash_power() ;
  float dash_power() const;
  void set_dash_power(float value);

  private:
  float _internal_dash_power() const;
  void _internal_set_dash_power(float value);

  public:
  // float dash_dir = 6;
  void clear_dash_dir() ;
  float dash_dir() const;
  void set_dash_dir(float value);

  private:
  float _internal_dash_dir() const;
  void _internal_set_dash_dir(float value);

  public:
  // float final_ball_dist = 8;
  void clear_final_ball_dist() ;
  float final_ball_dist() const;
  void set_final_ball_dist(float value);

  private:
  float _internal_final_ball_dist() const;
  void _internal_set_final_ball_dist(float value);

  public:
  // float final_stamina = 9;
  void clear_final_stamina() ;
  float final_stamina() const;
  void set_final_stamina(float value);

  private:
  float _internal_final_stamina() const;
  void _internal_set_final_stamina(float value);

  public:
  // float value = 10;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.InterceptInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* final_self_position_;
    int action_type_;
    ::int32_t turn_steps_;
    float turn_angle_;
    ::int32_t dash_steps_;
    float dash_power_;
    float dash_dir_;
    float final_ball_dist_;
    float final_stamina_;
    float value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class GoalieMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.GoalieMessage) */ {
 public:
  inline GoalieMessage() : GoalieMessage(nullptr) {}
  ~GoalieMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GoalieMessage(::google::protobuf::internal::ConstantInitialized);

  inline GoalieMessage(const GoalieMessage& from)
      : GoalieMessage(nullptr, from) {}
  GoalieMessage(GoalieMessage&& from) noexcept
    : GoalieMessage() {
    *this = ::std::move(from);
  }

  inline GoalieMessage& operator=(const GoalieMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoalieMessage& operator=(GoalieMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoalieMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoalieMessage* internal_default_instance() {
    return reinterpret_cast<const GoalieMessage*>(
               &_GoalieMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GoalieMessage& a, GoalieMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GoalieMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoalieMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoalieMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GoalieMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoalieMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GoalieMessage& from) {
    GoalieMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GoalieMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.GoalieMessage";
  }
  protected:
  explicit GoalieMessage(::google::protobuf::Arena* arena);
  GoalieMessage(::google::protobuf::Arena* arena, const GoalieMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoaliePositionFieldNumber = 2,
    kGoalieUniformNumberFieldNumber = 1,
    kGoalieBodyDirectionFieldNumber = 3,
  };
  // .protos.Vector2D goalie_position = 2;
  bool has_goalie_position() const;
  void clear_goalie_position() ;
  const ::protos::Vector2D& goalie_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_goalie_position();
  ::protos::Vector2D* mutable_goalie_position();
  void set_allocated_goalie_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_goalie_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_goalie_position();

  private:
  const ::protos::Vector2D& _internal_goalie_position() const;
  ::protos::Vector2D* _internal_mutable_goalie_position();

  public:
  // int32 goalie_uniform_number = 1;
  void clear_goalie_uniform_number() ;
  ::int32_t goalie_uniform_number() const;
  void set_goalie_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_goalie_uniform_number() const;
  void _internal_set_goalie_uniform_number(::int32_t value);

  public:
  // float goalie_body_direction = 3;
  void clear_goalie_body_direction() ;
  float goalie_body_direction() const;
  void set_goalie_body_direction(float value);

  private:
  float _internal_goalie_body_direction() const;
  void _internal_set_goalie_body_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.GoalieMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* goalie_position_;
    ::int32_t goalie_uniform_number_;
    float goalie_body_direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class GoalieAndPlayerMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.GoalieAndPlayerMessage) */ {
 public:
  inline GoalieAndPlayerMessage() : GoalieAndPlayerMessage(nullptr) {}
  ~GoalieAndPlayerMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GoalieAndPlayerMessage(::google::protobuf::internal::ConstantInitialized);

  inline GoalieAndPlayerMessage(const GoalieAndPlayerMessage& from)
      : GoalieAndPlayerMessage(nullptr, from) {}
  GoalieAndPlayerMessage(GoalieAndPlayerMessage&& from) noexcept
    : GoalieAndPlayerMessage() {
    *this = ::std::move(from);
  }

  inline GoalieAndPlayerMessage& operator=(const GoalieAndPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoalieAndPlayerMessage& operator=(GoalieAndPlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoalieAndPlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoalieAndPlayerMessage* internal_default_instance() {
    return reinterpret_cast<const GoalieAndPlayerMessage*>(
               &_GoalieAndPlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GoalieAndPlayerMessage& a, GoalieAndPlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GoalieAndPlayerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoalieAndPlayerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoalieAndPlayerMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GoalieAndPlayerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoalieAndPlayerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GoalieAndPlayerMessage& from) {
    GoalieAndPlayerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GoalieAndPlayerMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.GoalieAndPlayerMessage";
  }
  protected:
  explicit GoalieAndPlayerMessage(::google::protobuf::Arena* arena);
  GoalieAndPlayerMessage(::google::protobuf::Arena* arena, const GoalieAndPlayerMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoaliePositionFieldNumber = 2,
    kPlayerPositionFieldNumber = 5,
    kGoalieUniformNumberFieldNumber = 1,
    kGoalieBodyDirectionFieldNumber = 3,
    kPlayerUniformNumberFieldNumber = 4,
  };
  // .protos.Vector2D goalie_position = 2;
  bool has_goalie_position() const;
  void clear_goalie_position() ;
  const ::protos::Vector2D& goalie_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_goalie_position();
  ::protos::Vector2D* mutable_goalie_position();
  void set_allocated_goalie_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_goalie_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_goalie_position();

  private:
  const ::protos::Vector2D& _internal_goalie_position() const;
  ::protos::Vector2D* _internal_mutable_goalie_position();

  public:
  // .protos.Vector2D player_position = 5;
  bool has_player_position() const;
  void clear_player_position() ;
  const ::protos::Vector2D& player_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_player_position();
  ::protos::Vector2D* mutable_player_position();
  void set_allocated_player_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_player_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_player_position();

  private:
  const ::protos::Vector2D& _internal_player_position() const;
  ::protos::Vector2D* _internal_mutable_player_position();

  public:
  // int32 goalie_uniform_number = 1;
  void clear_goalie_uniform_number() ;
  ::int32_t goalie_uniform_number() const;
  void set_goalie_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_goalie_uniform_number() const;
  void _internal_set_goalie_uniform_number(::int32_t value);

  public:
  // float goalie_body_direction = 3;
  void clear_goalie_body_direction() ;
  float goalie_body_direction() const;
  void set_goalie_body_direction(float value);

  private:
  float _internal_goalie_body_direction() const;
  void _internal_set_goalie_body_direction(float value);

  public:
  // int32 player_uniform_number = 4;
  void clear_player_uniform_number() ;
  ::int32_t player_uniform_number() const;
  void set_player_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_player_uniform_number() const;
  void _internal_set_player_uniform_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.GoalieAndPlayerMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* goalie_position_;
    ::protos::Vector2D* player_position_;
    ::int32_t goalie_uniform_number_;
    float goalie_body_direction_;
    ::int32_t player_uniform_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Focus_MoveToPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Focus_MoveToPoint) */ {
 public:
  inline Focus_MoveToPoint() : Focus_MoveToPoint(nullptr) {}
  ~Focus_MoveToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Focus_MoveToPoint(::google::protobuf::internal::ConstantInitialized);

  inline Focus_MoveToPoint(const Focus_MoveToPoint& from)
      : Focus_MoveToPoint(nullptr, from) {}
  Focus_MoveToPoint(Focus_MoveToPoint&& from) noexcept
    : Focus_MoveToPoint() {
    *this = ::std::move(from);
  }

  inline Focus_MoveToPoint& operator=(const Focus_MoveToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Focus_MoveToPoint& operator=(Focus_MoveToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Focus_MoveToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Focus_MoveToPoint* internal_default_instance() {
    return reinterpret_cast<const Focus_MoveToPoint*>(
               &_Focus_MoveToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(Focus_MoveToPoint& a, Focus_MoveToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Focus_MoveToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Focus_MoveToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Focus_MoveToPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Focus_MoveToPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Focus_MoveToPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Focus_MoveToPoint& from) {
    Focus_MoveToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Focus_MoveToPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Focus_MoveToPoint";
  }
  protected:
  explicit Focus_MoveToPoint(::google::protobuf::Arena* arena);
  Focus_MoveToPoint(::google::protobuf::Arena* arena, const Focus_MoveToPoint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_target_point();

  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();

  public:
  // @@protoc_insertion_point(class_scope:protos.Focus_MoveToPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DribbleMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.DribbleMessage) */ {
 public:
  inline DribbleMessage() : DribbleMessage(nullptr) {}
  ~DribbleMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DribbleMessage(::google::protobuf::internal::ConstantInitialized);

  inline DribbleMessage(const DribbleMessage& from)
      : DribbleMessage(nullptr, from) {}
  DribbleMessage(DribbleMessage&& from) noexcept
    : DribbleMessage() {
    *this = ::std::move(from);
  }

  inline DribbleMessage& operator=(const DribbleMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DribbleMessage& operator=(DribbleMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DribbleMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DribbleMessage* internal_default_instance() {
    return reinterpret_cast<const DribbleMessage*>(
               &_DribbleMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(DribbleMessage& a, DribbleMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DribbleMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DribbleMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DribbleMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DribbleMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DribbleMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DribbleMessage& from) {
    DribbleMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DribbleMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DribbleMessage";
  }
  protected:
  explicit DribbleMessage(::google::protobuf::Arena* arena);
  DribbleMessage(::google::protobuf::Arena* arena, const DribbleMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kQueueCountFieldNumber = 2,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_target_point();

  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();

  public:
  // int32 queue_count = 2;
  void clear_queue_count() ;
  ::int32_t queue_count() const;
  void set_queue_count(::int32_t value);

  private:
  ::int32_t _internal_queue_count() const;
  void _internal_set_queue_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.DribbleMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    ::int32_t queue_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DoMovePlayer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.DoMovePlayer) */ {
 public:
  inline DoMovePlayer() : DoMovePlayer(nullptr) {}
  ~DoMovePlayer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoMovePlayer(::google::protobuf::internal::ConstantInitialized);

  inline DoMovePlayer(const DoMovePlayer& from)
      : DoMovePlayer(nullptr, from) {}
  DoMovePlayer(DoMovePlayer&& from) noexcept
    : DoMovePlayer() {
    *this = ::std::move(from);
  }

  inline DoMovePlayer& operator=(const DoMovePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoMovePlayer& operator=(DoMovePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoMovePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoMovePlayer* internal_default_instance() {
    return reinterpret_cast<const DoMovePlayer*>(
               &_DoMovePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(DoMovePlayer& a, DoMovePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(DoMovePlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoMovePlayer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoMovePlayer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoMovePlayer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoMovePlayer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DoMovePlayer& from) {
    DoMovePlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DoMovePlayer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DoMovePlayer";
  }
  protected:
  explicit DoMovePlayer(::google::protobuf::Arena* arena);
  DoMovePlayer(::google::protobuf::Arena* arena, const DoMovePlayer& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 3,
    kOurSideFieldNumber = 1,
    kUniformNumberFieldNumber = 2,
    kBodyDirectionFieldNumber = 4,
  };
  // .protos.Vector2D position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_position();

  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();

  public:
  // bool our_side = 1;
  void clear_our_side() ;
  bool our_side() const;
  void set_our_side(bool value);

  private:
  bool _internal_our_side() const;
  void _internal_set_our_side(bool value);

  public:
  // int32 uniform_number = 2;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // float body_direction = 4;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.DoMovePlayer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    bool our_side_;
    ::int32_t uniform_number_;
    float body_direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class DoMoveBall final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.DoMoveBall) */ {
 public:
  inline DoMoveBall() : DoMoveBall(nullptr) {}
  ~DoMoveBall() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoMoveBall(::google::protobuf::internal::ConstantInitialized);

  inline DoMoveBall(const DoMoveBall& from)
      : DoMoveBall(nullptr, from) {}
  DoMoveBall(DoMoveBall&& from) noexcept
    : DoMoveBall() {
    *this = ::std::move(from);
  }

  inline DoMoveBall& operator=(const DoMoveBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoMoveBall& operator=(DoMoveBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoMoveBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoMoveBall* internal_default_instance() {
    return reinterpret_cast<const DoMoveBall*>(
               &_DoMoveBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(DoMoveBall& a, DoMoveBall& b) {
    a.Swap(&b);
  }
  inline void Swap(DoMoveBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoMoveBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoMoveBall* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoMoveBall>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoMoveBall& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DoMoveBall& from) {
    DoMoveBall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DoMoveBall* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.DoMoveBall";
  }
  protected:
  explicit DoMoveBall(::google::protobuf::Arena* arena);
  DoMoveBall(::google::protobuf::Arena* arena, const DoMoveBall& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kVelocityFieldNumber = 2,
  };
  // .protos.Vector2D position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_position();

  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();

  public:
  // .protos.Vector2D velocity = 2;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::protos::Vector2D& velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_velocity();
  ::protos::Vector2D* mutable_velocity();
  void set_allocated_velocity(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_velocity(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_velocity();

  private:
  const ::protos::Vector2D& _internal_velocity() const;
  ::protos::Vector2D* _internal_mutable_velocity();

  public:
  // @@protoc_insertion_point(class_scope:protos.DoMoveBall)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::protos::Vector2D* velocity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class CoachAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.CoachAction) */ {
 public:
  inline CoachAction() : CoachAction(nullptr) {}
  ~CoachAction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CoachAction(::google::protobuf::internal::ConstantInitialized);

  inline CoachAction(const CoachAction& from)
      : CoachAction(nullptr, from) {}
  CoachAction(CoachAction&& from) noexcept
    : CoachAction() {
    *this = ::std::move(from);
  }

  inline CoachAction& operator=(const CoachAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoachAction& operator=(CoachAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoachAction& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kChangePlayerTypes = 1,
    kDoHeliosSubstitute = 2,
    kDoHeliosSayPlayerTypes = 3,
    ACTION_NOT_SET = 0,
  };

  static inline const CoachAction* internal_default_instance() {
    return reinterpret_cast<const CoachAction*>(
               &_CoachAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(CoachAction& a, CoachAction& b) {
    a.Swap(&b);
  }
  inline void Swap(CoachAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoachAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoachAction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoachAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CoachAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CoachAction& from) {
    CoachAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CoachAction* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.CoachAction";
  }
  protected:
  explicit CoachAction(::google::protobuf::Arena* arena);
  CoachAction(::google::protobuf::Arena* arena, const CoachAction& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangePlayerTypesFieldNumber = 1,
    kDoHeliosSubstituteFieldNumber = 2,
    kDoHeliosSayPlayerTypesFieldNumber = 3,
  };
  // .protos.ChangePlayerType change_player_types = 1;
  bool has_change_player_types() const;
  private:
  bool _internal_has_change_player_types() const;

  public:
  void clear_change_player_types() ;
  const ::protos::ChangePlayerType& change_player_types() const;
  PROTOBUF_NODISCARD ::protos::ChangePlayerType* release_change_player_types();
  ::protos::ChangePlayerType* mutable_change_player_types();
  void set_allocated_change_player_types(::protos::ChangePlayerType* value);
  void unsafe_arena_set_allocated_change_player_types(::protos::ChangePlayerType* value);
  ::protos::ChangePlayerType* unsafe_arena_release_change_player_types();

  private:
  const ::protos::ChangePlayerType& _internal_change_player_types() const;
  ::protos::ChangePlayerType* _internal_mutable_change_player_types();

  public:
  // .protos.DoHeliosSubstitute do_helios_substitute = 2;
  bool has_do_helios_substitute() const;
  private:
  bool _internal_has_do_helios_substitute() const;

  public:
  void clear_do_helios_substitute() ;
  const ::protos::DoHeliosSubstitute& do_helios_substitute() const;
  PROTOBUF_NODISCARD ::protos::DoHeliosSubstitute* release_do_helios_substitute();
  ::protos::DoHeliosSubstitute* mutable_do_helios_substitute();
  void set_allocated_do_helios_substitute(::protos::DoHeliosSubstitute* value);
  void unsafe_arena_set_allocated_do_helios_substitute(::protos::DoHeliosSubstitute* value);
  ::protos::DoHeliosSubstitute* unsafe_arena_release_do_helios_substitute();

  private:
  const ::protos::DoHeliosSubstitute& _internal_do_helios_substitute() const;
  ::protos::DoHeliosSubstitute* _internal_mutable_do_helios_substitute();

  public:
  // .protos.DoHeliosSayPlayerTypes do_helios_say_player_types = 3;
  bool has_do_helios_say_player_types() const;
  private:
  bool _internal_has_do_helios_say_player_types() const;

  public:
  void clear_do_helios_say_player_types() ;
  const ::protos::DoHeliosSayPlayerTypes& do_helios_say_player_types() const;
  PROTOBUF_NODISCARD ::protos::DoHeliosSayPlayerTypes* release_do_helios_say_player_types();
  ::protos::DoHeliosSayPlayerTypes* mutable_do_helios_say_player_types();
  void set_allocated_do_helios_say_player_types(::protos::DoHeliosSayPlayerTypes* value);
  void unsafe_arena_set_allocated_do_helios_say_player_types(::protos::DoHeliosSayPlayerTypes* value);
  ::protos::DoHeliosSayPlayerTypes* unsafe_arena_release_do_helios_say_player_types();

  private:
  const ::protos::DoHeliosSayPlayerTypes& _internal_do_helios_say_player_types() const;
  ::protos::DoHeliosSayPlayerTypes* _internal_mutable_do_helios_say_player_types();

  public:
  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:protos.CoachAction)
 private:
  class _Internal;
  void set_has_change_player_types();
  void set_has_do_helios_substitute();
  void set_has_do_helios_say_player_types();

  inline bool has_action() const;
  inline void clear_has_action();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::protos::ChangePlayerType* change_player_types_;
      ::protos::DoHeliosSubstitute* do_helios_substitute_;
      ::protos::DoHeliosSayPlayerTypes* do_helios_say_player_types_;
    } action_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_TurnToPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Body_TurnToPoint) */ {
 public:
  inline Body_TurnToPoint() : Body_TurnToPoint(nullptr) {}
  ~Body_TurnToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_TurnToPoint(::google::protobuf::internal::ConstantInitialized);

  inline Body_TurnToPoint(const Body_TurnToPoint& from)
      : Body_TurnToPoint(nullptr, from) {}
  Body_TurnToPoint(Body_TurnToPoint&& from) noexcept
    : Body_TurnToPoint() {
    *this = ::std::move(from);
  }

  inline Body_TurnToPoint& operator=(const Body_TurnToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_TurnToPoint& operator=(Body_TurnToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_TurnToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_TurnToPoint* internal_default_instance() {
    return reinterpret_cast<const Body_TurnToPoint*>(
               &_Body_TurnToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(Body_TurnToPoint& a, Body_TurnToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_TurnToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_TurnToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_TurnToPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_TurnToPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Body_TurnToPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Body_TurnToPoint& from) {
    Body_TurnToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Body_TurnToPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_TurnToPoint";
  }
  protected:
  explicit Body_TurnToPoint(::google::protobuf::Arena* arena);
  Body_TurnToPoint(::google::protobuf::Arena* arena, const Body_TurnToPoint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kCycleFieldNumber = 2,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_target_point();

  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();

  public:
  // int32 cycle = 2;
  void clear_cycle() ;
  ::int32_t cycle() const;
  void set_cycle(::int32_t value);

  private:
  ::int32_t _internal_cycle() const;
  void _internal_set_cycle(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_TurnToPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    ::int32_t cycle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_TackleToPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Body_TackleToPoint) */ {
 public:
  inline Body_TackleToPoint() : Body_TackleToPoint(nullptr) {}
  ~Body_TackleToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_TackleToPoint(::google::protobuf::internal::ConstantInitialized);

  inline Body_TackleToPoint(const Body_TackleToPoint& from)
      : Body_TackleToPoint(nullptr, from) {}
  Body_TackleToPoint(Body_TackleToPoint&& from) noexcept
    : Body_TackleToPoint() {
    *this = ::std::move(from);
  }

  inline Body_TackleToPoint& operator=(const Body_TackleToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_TackleToPoint& operator=(Body_TackleToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_TackleToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_TackleToPoint* internal_default_instance() {
    return reinterpret_cast<const Body_TackleToPoint*>(
               &_Body_TackleToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(Body_TackleToPoint& a, Body_TackleToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_TackleToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_TackleToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_TackleToPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_TackleToPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Body_TackleToPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Body_TackleToPoint& from) {
    Body_TackleToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Body_TackleToPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_TackleToPoint";
  }
  protected:
  explicit Body_TackleToPoint(::google::protobuf::Arena* arena);
  Body_TackleToPoint(::google::protobuf::Arena* arena, const Body_TackleToPoint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kMinProbabilityFieldNumber = 2,
    kMinSpeedFieldNumber = 3,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_target_point();

  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();

  public:
  // float min_probability = 2;
  void clear_min_probability() ;
  float min_probability() const;
  void set_min_probability(float value);

  private:
  float _internal_min_probability() const;
  void _internal_set_min_probability(float value);

  public:
  // float min_speed = 3;
  void clear_min_speed() ;
  float min_speed() const;
  void set_min_speed(float value);

  private:
  float _internal_min_speed() const;
  void _internal_set_min_speed(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_TackleToPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float min_probability_;
    float min_speed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_SmartKick final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Body_SmartKick) */ {
 public:
  inline Body_SmartKick() : Body_SmartKick(nullptr) {}
  ~Body_SmartKick() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_SmartKick(::google::protobuf::internal::ConstantInitialized);

  inline Body_SmartKick(const Body_SmartKick& from)
      : Body_SmartKick(nullptr, from) {}
  Body_SmartKick(Body_SmartKick&& from) noexcept
    : Body_SmartKick() {
    *this = ::std::move(from);
  }

  inline Body_SmartKick& operator=(const Body_SmartKick& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_SmartKick& operator=(Body_SmartKick&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_SmartKick& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_SmartKick* internal_default_instance() {
    return reinterpret_cast<const Body_SmartKick*>(
               &_Body_SmartKick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(Body_SmartKick& a, Body_SmartKick& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_SmartKick* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_SmartKick* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_SmartKick* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_SmartKick>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Body_SmartKick& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Body_SmartKick& from) {
    Body_SmartKick::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Body_SmartKick* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_SmartKick";
  }
  protected:
  explicit Body_SmartKick(::google::protobuf::Arena* arena);
  Body_SmartKick(::google::protobuf::Arena* arena, const Body_SmartKick& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kFirstSpeedFieldNumber = 2,
    kFirstSpeedThresholdFieldNumber = 3,
    kMaxStepsFieldNumber = 4,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_target_point();

  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();

  public:
  // float first_speed = 2;
  void clear_first_speed() ;
  float first_speed() const;
  void set_first_speed(float value);

  private:
  float _internal_first_speed() const;
  void _internal_set_first_speed(float value);

  public:
  // float first_speed_threshold = 3;
  void clear_first_speed_threshold() ;
  float first_speed_threshold() const;
  void set_first_speed_threshold(float value);

  private:
  float _internal_first_speed_threshold() const;
  void _internal_set_first_speed_threshold(float value);

  public:
  // int32 max_steps = 4;
  void clear_max_steps() ;
  ::int32_t max_steps() const;
  void set_max_steps(::int32_t value);

  private:
  ::int32_t _internal_max_steps() const;
  void _internal_set_max_steps(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_SmartKick)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float first_speed_;
    float first_speed_threshold_;
    ::int32_t max_steps_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_KickOneStep final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Body_KickOneStep) */ {
 public:
  inline Body_KickOneStep() : Body_KickOneStep(nullptr) {}
  ~Body_KickOneStep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_KickOneStep(::google::protobuf::internal::ConstantInitialized);

  inline Body_KickOneStep(const Body_KickOneStep& from)
      : Body_KickOneStep(nullptr, from) {}
  Body_KickOneStep(Body_KickOneStep&& from) noexcept
    : Body_KickOneStep() {
    *this = ::std::move(from);
  }

  inline Body_KickOneStep& operator=(const Body_KickOneStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_KickOneStep& operator=(Body_KickOneStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_KickOneStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_KickOneStep* internal_default_instance() {
    return reinterpret_cast<const Body_KickOneStep*>(
               &_Body_KickOneStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(Body_KickOneStep& a, Body_KickOneStep& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_KickOneStep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_KickOneStep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_KickOneStep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_KickOneStep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Body_KickOneStep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Body_KickOneStep& from) {
    Body_KickOneStep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Body_KickOneStep* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_KickOneStep";
  }
  protected:
  explicit Body_KickOneStep(::google::protobuf::Arena* arena);
  Body_KickOneStep(::google::protobuf::Arena* arena, const Body_KickOneStep& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kFirstSpeedFieldNumber = 2,
    kForceModeFieldNumber = 3,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_target_point();

  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();

  public:
  // float first_speed = 2;
  void clear_first_speed() ;
  float first_speed() const;
  void set_first_speed(float value);

  private:
  float _internal_first_speed() const;
  void _internal_set_first_speed(float value);

  public:
  // bool force_mode = 3;
  void clear_force_mode() ;
  bool force_mode() const;
  void set_force_mode(bool value);

  private:
  bool _internal_force_mode() const;
  void _internal_set_force_mode(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_KickOneStep)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float first_speed_;
    bool force_mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_Intercept final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Body_Intercept) */ {
 public:
  inline Body_Intercept() : Body_Intercept(nullptr) {}
  ~Body_Intercept() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_Intercept(::google::protobuf::internal::ConstantInitialized);

  inline Body_Intercept(const Body_Intercept& from)
      : Body_Intercept(nullptr, from) {}
  Body_Intercept(Body_Intercept&& from) noexcept
    : Body_Intercept() {
    *this = ::std::move(from);
  }

  inline Body_Intercept& operator=(const Body_Intercept& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_Intercept& operator=(Body_Intercept&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_Intercept& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_Intercept* internal_default_instance() {
    return reinterpret_cast<const Body_Intercept*>(
               &_Body_Intercept_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(Body_Intercept& a, Body_Intercept& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_Intercept* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_Intercept* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_Intercept* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_Intercept>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Body_Intercept& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Body_Intercept& from) {
    Body_Intercept::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Body_Intercept* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_Intercept";
  }
  protected:
  explicit Body_Intercept(::google::protobuf::Arena* arena);
  Body_Intercept(::google::protobuf::Arena* arena, const Body_Intercept& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFacePointFieldNumber = 2,
    kSaveRecoveryFieldNumber = 1,
  };
  // .protos.Vector2D face_point = 2;
  bool has_face_point() const;
  void clear_face_point() ;
  const ::protos::Vector2D& face_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_face_point();
  ::protos::Vector2D* mutable_face_point();
  void set_allocated_face_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_face_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_face_point();

  private:
  const ::protos::Vector2D& _internal_face_point() const;
  ::protos::Vector2D* _internal_mutable_face_point();

  public:
  // bool save_recovery = 1;
  void clear_save_recovery() ;
  bool save_recovery() const;
  void set_save_recovery(bool value);

  private:
  bool _internal_save_recovery() const;
  void _internal_set_save_recovery(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_Intercept)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* face_point_;
    bool save_recovery_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_HoldBall final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Body_HoldBall) */ {
 public:
  inline Body_HoldBall() : Body_HoldBall(nullptr) {}
  ~Body_HoldBall() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_HoldBall(::google::protobuf::internal::ConstantInitialized);

  inline Body_HoldBall(const Body_HoldBall& from)
      : Body_HoldBall(nullptr, from) {}
  Body_HoldBall(Body_HoldBall&& from) noexcept
    : Body_HoldBall() {
    *this = ::std::move(from);
  }

  inline Body_HoldBall& operator=(const Body_HoldBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_HoldBall& operator=(Body_HoldBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_HoldBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_HoldBall* internal_default_instance() {
    return reinterpret_cast<const Body_HoldBall*>(
               &_Body_HoldBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(Body_HoldBall& a, Body_HoldBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_HoldBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_HoldBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_HoldBall* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_HoldBall>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Body_HoldBall& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Body_HoldBall& from) {
    Body_HoldBall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Body_HoldBall* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_HoldBall";
  }
  protected:
  explicit Body_HoldBall(::google::protobuf::Arena* arena);
  Body_HoldBall(::google::protobuf::Arena* arena, const Body_HoldBall& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTurnTargetPointFieldNumber = 2,
    kKickTargetPointFieldNumber = 3,
    kDoTurnFieldNumber = 1,
  };
  // .protos.Vector2D turn_target_point = 2;
  bool has_turn_target_point() const;
  void clear_turn_target_point() ;
  const ::protos::Vector2D& turn_target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_turn_target_point();
  ::protos::Vector2D* mutable_turn_target_point();
  void set_allocated_turn_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_turn_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_turn_target_point();

  private:
  const ::protos::Vector2D& _internal_turn_target_point() const;
  ::protos::Vector2D* _internal_mutable_turn_target_point();

  public:
  // .protos.Vector2D kick_target_point = 3;
  bool has_kick_target_point() const;
  void clear_kick_target_point() ;
  const ::protos::Vector2D& kick_target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_kick_target_point();
  ::protos::Vector2D* mutable_kick_target_point();
  void set_allocated_kick_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_kick_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_kick_target_point();

  private:
  const ::protos::Vector2D& _internal_kick_target_point() const;
  ::protos::Vector2D* _internal_mutable_kick_target_point();

  public:
  // bool do_turn = 1;
  void clear_do_turn() ;
  bool do_turn() const;
  void set_do_turn(bool value);

  private:
  bool _internal_do_turn() const;
  void _internal_set_do_turn(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_HoldBall)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* turn_target_point_;
    ::protos::Vector2D* kick_target_point_;
    bool do_turn_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_GoToPointDodge final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Body_GoToPointDodge) */ {
 public:
  inline Body_GoToPointDodge() : Body_GoToPointDodge(nullptr) {}
  ~Body_GoToPointDodge() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_GoToPointDodge(::google::protobuf::internal::ConstantInitialized);

  inline Body_GoToPointDodge(const Body_GoToPointDodge& from)
      : Body_GoToPointDodge(nullptr, from) {}
  Body_GoToPointDodge(Body_GoToPointDodge&& from) noexcept
    : Body_GoToPointDodge() {
    *this = ::std::move(from);
  }

  inline Body_GoToPointDodge& operator=(const Body_GoToPointDodge& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_GoToPointDodge& operator=(Body_GoToPointDodge&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_GoToPointDodge& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_GoToPointDodge* internal_default_instance() {
    return reinterpret_cast<const Body_GoToPointDodge*>(
               &_Body_GoToPointDodge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(Body_GoToPointDodge& a, Body_GoToPointDodge& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_GoToPointDodge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_GoToPointDodge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_GoToPointDodge* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_GoToPointDodge>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Body_GoToPointDodge& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Body_GoToPointDodge& from) {
    Body_GoToPointDodge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Body_GoToPointDodge* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_GoToPointDodge";
  }
  protected:
  explicit Body_GoToPointDodge(::google::protobuf::Arena* arena);
  Body_GoToPointDodge(::google::protobuf::Arena* arena, const Body_GoToPointDodge& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kDashPowerFieldNumber = 2,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_target_point();

  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();

  public:
  // float dash_power = 2;
  void clear_dash_power() ;
  float dash_power() const;
  void set_dash_power(float value);

  private:
  float _internal_dash_power() const;
  void _internal_set_dash_power(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_GoToPointDodge)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float dash_power_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_GoToPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Body_GoToPoint) */ {
 public:
  inline Body_GoToPoint() : Body_GoToPoint(nullptr) {}
  ~Body_GoToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_GoToPoint(::google::protobuf::internal::ConstantInitialized);

  inline Body_GoToPoint(const Body_GoToPoint& from)
      : Body_GoToPoint(nullptr, from) {}
  Body_GoToPoint(Body_GoToPoint&& from) noexcept
    : Body_GoToPoint() {
    *this = ::std::move(from);
  }

  inline Body_GoToPoint& operator=(const Body_GoToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_GoToPoint& operator=(Body_GoToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_GoToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_GoToPoint* internal_default_instance() {
    return reinterpret_cast<const Body_GoToPoint*>(
               &_Body_GoToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(Body_GoToPoint& a, Body_GoToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_GoToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_GoToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_GoToPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_GoToPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Body_GoToPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Body_GoToPoint& from) {
    Body_GoToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Body_GoToPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_GoToPoint";
  }
  protected:
  explicit Body_GoToPoint(::google::protobuf::Arena* arena);
  Body_GoToPoint(::google::protobuf::Arena* arena, const Body_GoToPoint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kDistanceThresholdFieldNumber = 2,
    kMaxDashPowerFieldNumber = 3,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_target_point();

  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();

  public:
  // float distance_threshold = 2;
  void clear_distance_threshold() ;
  float distance_threshold() const;
  void set_distance_threshold(float value);

  private:
  float _internal_distance_threshold() const;
  void _internal_set_distance_threshold(float value);

  public:
  // float max_dash_power = 3;
  void clear_max_dash_power() ;
  float max_dash_power() const;
  void set_max_dash_power(float value);

  private:
  float _internal_max_dash_power() const;
  void _internal_set_max_dash_power(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_GoToPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float distance_threshold_;
    float max_dash_power_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Body_Dribble final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Body_Dribble) */ {
 public:
  inline Body_Dribble() : Body_Dribble(nullptr) {}
  ~Body_Dribble() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Body_Dribble(::google::protobuf::internal::ConstantInitialized);

  inline Body_Dribble(const Body_Dribble& from)
      : Body_Dribble(nullptr, from) {}
  Body_Dribble(Body_Dribble&& from) noexcept
    : Body_Dribble() {
    *this = ::std::move(from);
  }

  inline Body_Dribble& operator=(const Body_Dribble& from) {
    CopyFrom(from);
    return *this;
  }
  inline Body_Dribble& operator=(Body_Dribble&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Body_Dribble& default_instance() {
    return *internal_default_instance();
  }
  static inline const Body_Dribble* internal_default_instance() {
    return reinterpret_cast<const Body_Dribble*>(
               &_Body_Dribble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(Body_Dribble& a, Body_Dribble& b) {
    a.Swap(&b);
  }
  inline void Swap(Body_Dribble* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Body_Dribble* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Body_Dribble* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Body_Dribble>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Body_Dribble& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Body_Dribble& from) {
    Body_Dribble::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Body_Dribble* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Body_Dribble";
  }
  protected:
  explicit Body_Dribble(::google::protobuf::Arena* arena);
  Body_Dribble(::google::protobuf::Arena* arena, const Body_Dribble& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kDistanceThresholdFieldNumber = 2,
    kDashPowerFieldNumber = 3,
    kDashCountFieldNumber = 4,
    kDodgeFieldNumber = 5,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_target_point();

  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();

  public:
  // float distance_threshold = 2;
  void clear_distance_threshold() ;
  float distance_threshold() const;
  void set_distance_threshold(float value);

  private:
  float _internal_distance_threshold() const;
  void _internal_set_distance_threshold(float value);

  public:
  // float dash_power = 3;
  void clear_dash_power() ;
  float dash_power() const;
  void set_dash_power(float value);

  private:
  float _internal_dash_power() const;
  void _internal_set_dash_power(float value);

  public:
  // int32 dash_count = 4;
  void clear_dash_count() ;
  ::int32_t dash_count() const;
  void set_dash_count(::int32_t value);

  private:
  ::int32_t _internal_dash_count() const;
  void _internal_set_dash_count(::int32_t value);

  public:
  // bool dodge = 5;
  void clear_dodge() ;
  bool dodge() const;
  void set_dodge(bool value);

  private:
  bool _internal_dodge() const;
  void _internal_set_dodge(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Body_Dribble)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float distance_threshold_;
    float dash_power_;
    ::int32_t dash_count_;
    bool dodge_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_NeckBodyToPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Bhv_NeckBodyToPoint) */ {
 public:
  inline Bhv_NeckBodyToPoint() : Bhv_NeckBodyToPoint(nullptr) {}
  ~Bhv_NeckBodyToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_NeckBodyToPoint(::google::protobuf::internal::ConstantInitialized);

  inline Bhv_NeckBodyToPoint(const Bhv_NeckBodyToPoint& from)
      : Bhv_NeckBodyToPoint(nullptr, from) {}
  Bhv_NeckBodyToPoint(Bhv_NeckBodyToPoint&& from) noexcept
    : Bhv_NeckBodyToPoint() {
    *this = ::std::move(from);
  }

  inline Bhv_NeckBodyToPoint& operator=(const Bhv_NeckBodyToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_NeckBodyToPoint& operator=(Bhv_NeckBodyToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_NeckBodyToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_NeckBodyToPoint* internal_default_instance() {
    return reinterpret_cast<const Bhv_NeckBodyToPoint*>(
               &_Bhv_NeckBodyToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(Bhv_NeckBodyToPoint& a, Bhv_NeckBodyToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_NeckBodyToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_NeckBodyToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_NeckBodyToPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_NeckBodyToPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Bhv_NeckBodyToPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Bhv_NeckBodyToPoint& from) {
    Bhv_NeckBodyToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Bhv_NeckBodyToPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_NeckBodyToPoint";
  }
  protected:
  explicit Bhv_NeckBodyToPoint(::google::protobuf::Arena* arena);
  Bhv_NeckBodyToPoint(::google::protobuf::Arena* arena, const Bhv_NeckBodyToPoint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kAngleBufFieldNumber = 2,
  };
  // .protos.Vector2D point = 1;
  bool has_point() const;
  void clear_point() ;
  const ::protos::Vector2D& point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point();
  ::protos::Vector2D* mutable_point();
  void set_allocated_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_point();

  private:
  const ::protos::Vector2D& _internal_point() const;
  ::protos::Vector2D* _internal_mutable_point();

  public:
  // float angle_buf = 2;
  void clear_angle_buf() ;
  float angle_buf() const;
  void set_angle_buf(float value);

  private:
  float _internal_angle_buf() const;
  void _internal_set_angle_buf(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Bhv_NeckBodyToPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* point_;
    float angle_buf_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_GoToPointLookBall final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Bhv_GoToPointLookBall) */ {
 public:
  inline Bhv_GoToPointLookBall() : Bhv_GoToPointLookBall(nullptr) {}
  ~Bhv_GoToPointLookBall() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_GoToPointLookBall(::google::protobuf::internal::ConstantInitialized);

  inline Bhv_GoToPointLookBall(const Bhv_GoToPointLookBall& from)
      : Bhv_GoToPointLookBall(nullptr, from) {}
  Bhv_GoToPointLookBall(Bhv_GoToPointLookBall&& from) noexcept
    : Bhv_GoToPointLookBall() {
    *this = ::std::move(from);
  }

  inline Bhv_GoToPointLookBall& operator=(const Bhv_GoToPointLookBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_GoToPointLookBall& operator=(Bhv_GoToPointLookBall&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_GoToPointLookBall& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_GoToPointLookBall* internal_default_instance() {
    return reinterpret_cast<const Bhv_GoToPointLookBall*>(
               &_Bhv_GoToPointLookBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(Bhv_GoToPointLookBall& a, Bhv_GoToPointLookBall& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_GoToPointLookBall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_GoToPointLookBall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_GoToPointLookBall* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_GoToPointLookBall>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Bhv_GoToPointLookBall& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Bhv_GoToPointLookBall& from) {
    Bhv_GoToPointLookBall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Bhv_GoToPointLookBall* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_GoToPointLookBall";
  }
  protected:
  explicit Bhv_GoToPointLookBall(::google::protobuf::Arena* arena);
  Bhv_GoToPointLookBall(::google::protobuf::Arena* arena, const Bhv_GoToPointLookBall& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPointFieldNumber = 1,
    kDistanceThresholdFieldNumber = 2,
    kMaxDashPowerFieldNumber = 3,
  };
  // .protos.Vector2D target_point = 1;
  bool has_target_point() const;
  void clear_target_point() ;
  const ::protos::Vector2D& target_point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_target_point();
  ::protos::Vector2D* mutable_target_point();
  void set_allocated_target_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_target_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_target_point();

  private:
  const ::protos::Vector2D& _internal_target_point() const;
  ::protos::Vector2D* _internal_mutable_target_point();

  public:
  // float distance_threshold = 2;
  void clear_distance_threshold() ;
  float distance_threshold() const;
  void set_distance_threshold(float value);

  private:
  float _internal_distance_threshold() const;
  void _internal_set_distance_threshold(float value);

  public:
  // float max_dash_power = 3;
  void clear_max_dash_power() ;
  float max_dash_power() const;
  void set_max_dash_power(float value);

  private:
  float _internal_max_dash_power() const;
  void _internal_set_max_dash_power(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Bhv_GoToPointLookBall)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* target_point_;
    float distance_threshold_;
    float max_dash_power_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_BodyNeckToPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Bhv_BodyNeckToPoint) */ {
 public:
  inline Bhv_BodyNeckToPoint() : Bhv_BodyNeckToPoint(nullptr) {}
  ~Bhv_BodyNeckToPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_BodyNeckToPoint(::google::protobuf::internal::ConstantInitialized);

  inline Bhv_BodyNeckToPoint(const Bhv_BodyNeckToPoint& from)
      : Bhv_BodyNeckToPoint(nullptr, from) {}
  Bhv_BodyNeckToPoint(Bhv_BodyNeckToPoint&& from) noexcept
    : Bhv_BodyNeckToPoint() {
    *this = ::std::move(from);
  }

  inline Bhv_BodyNeckToPoint& operator=(const Bhv_BodyNeckToPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_BodyNeckToPoint& operator=(Bhv_BodyNeckToPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_BodyNeckToPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_BodyNeckToPoint* internal_default_instance() {
    return reinterpret_cast<const Bhv_BodyNeckToPoint*>(
               &_Bhv_BodyNeckToPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(Bhv_BodyNeckToPoint& a, Bhv_BodyNeckToPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_BodyNeckToPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_BodyNeckToPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_BodyNeckToPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_BodyNeckToPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Bhv_BodyNeckToPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Bhv_BodyNeckToPoint& from) {
    Bhv_BodyNeckToPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Bhv_BodyNeckToPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_BodyNeckToPoint";
  }
  protected:
  explicit Bhv_BodyNeckToPoint(::google::protobuf::Arena* arena);
  Bhv_BodyNeckToPoint(::google::protobuf::Arena* arena, const Bhv_BodyNeckToPoint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
  };
  // .protos.Vector2D point = 1;
  bool has_point() const;
  void clear_point() ;
  const ::protos::Vector2D& point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point();
  ::protos::Vector2D* mutable_point();
  void set_allocated_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_point();

  private:
  const ::protos::Vector2D& _internal_point() const;
  ::protos::Vector2D* _internal_mutable_point();

  public:
  // @@protoc_insertion_point(class_scope:protos.Bhv_BodyNeckToPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* point_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Bhv_BeforeKickOff final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Bhv_BeforeKickOff) */ {
 public:
  inline Bhv_BeforeKickOff() : Bhv_BeforeKickOff(nullptr) {}
  ~Bhv_BeforeKickOff() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bhv_BeforeKickOff(::google::protobuf::internal::ConstantInitialized);

  inline Bhv_BeforeKickOff(const Bhv_BeforeKickOff& from)
      : Bhv_BeforeKickOff(nullptr, from) {}
  Bhv_BeforeKickOff(Bhv_BeforeKickOff&& from) noexcept
    : Bhv_BeforeKickOff() {
    *this = ::std::move(from);
  }

  inline Bhv_BeforeKickOff& operator=(const Bhv_BeforeKickOff& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bhv_BeforeKickOff& operator=(Bhv_BeforeKickOff&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bhv_BeforeKickOff& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bhv_BeforeKickOff* internal_default_instance() {
    return reinterpret_cast<const Bhv_BeforeKickOff*>(
               &_Bhv_BeforeKickOff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(Bhv_BeforeKickOff& a, Bhv_BeforeKickOff& b) {
    a.Swap(&b);
  }
  inline void Swap(Bhv_BeforeKickOff* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bhv_BeforeKickOff* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bhv_BeforeKickOff* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bhv_BeforeKickOff>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Bhv_BeforeKickOff& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Bhv_BeforeKickOff& from) {
    Bhv_BeforeKickOff::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Bhv_BeforeKickOff* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Bhv_BeforeKickOff";
  }
  protected:
  explicit Bhv_BeforeKickOff(::google::protobuf::Arena* arena);
  Bhv_BeforeKickOff(::google::protobuf::Arena* arena, const Bhv_BeforeKickOff& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
  };
  // .protos.Vector2D point = 1;
  bool has_point() const;
  void clear_point() ;
  const ::protos::Vector2D& point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point();
  ::protos::Vector2D* mutable_point();
  void set_allocated_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_point();

  private:
  const ::protos::Vector2D& _internal_point() const;
  ::protos::Vector2D* _internal_mutable_point();

  public:
  // @@protoc_insertion_point(class_scope:protos.Bhv_BeforeKickOff)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* point_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class BallPlayerMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.BallPlayerMessage) */ {
 public:
  inline BallPlayerMessage() : BallPlayerMessage(nullptr) {}
  ~BallPlayerMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BallPlayerMessage(::google::protobuf::internal::ConstantInitialized);

  inline BallPlayerMessage(const BallPlayerMessage& from)
      : BallPlayerMessage(nullptr, from) {}
  BallPlayerMessage(BallPlayerMessage&& from) noexcept
    : BallPlayerMessage() {
    *this = ::std::move(from);
  }

  inline BallPlayerMessage& operator=(const BallPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BallPlayerMessage& operator=(BallPlayerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BallPlayerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BallPlayerMessage* internal_default_instance() {
    return reinterpret_cast<const BallPlayerMessage*>(
               &_BallPlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(BallPlayerMessage& a, BallPlayerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BallPlayerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BallPlayerMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BallPlayerMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BallPlayerMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BallPlayerMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BallPlayerMessage& from) {
    BallPlayerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BallPlayerMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.BallPlayerMessage";
  }
  protected:
  explicit BallPlayerMessage(::google::protobuf::Arena* arena);
  BallPlayerMessage(::google::protobuf::Arena* arena, const BallPlayerMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBallPositionFieldNumber = 1,
    kBallVelocityFieldNumber = 2,
    kPlayerPositionFieldNumber = 4,
    kUniformNumberFieldNumber = 3,
    kBodyDirectionFieldNumber = 5,
  };
  // .protos.Vector2D ball_position = 1;
  bool has_ball_position() const;
  void clear_ball_position() ;
  const ::protos::Vector2D& ball_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_position();
  ::protos::Vector2D* mutable_ball_position();
  void set_allocated_ball_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_ball_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_ball_position();

  private:
  const ::protos::Vector2D& _internal_ball_position() const;
  ::protos::Vector2D* _internal_mutable_ball_position();

  public:
  // .protos.Vector2D ball_velocity = 2;
  bool has_ball_velocity() const;
  void clear_ball_velocity() ;
  const ::protos::Vector2D& ball_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_velocity();
  ::protos::Vector2D* mutable_ball_velocity();
  void set_allocated_ball_velocity(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_ball_velocity(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_ball_velocity();

  private:
  const ::protos::Vector2D& _internal_ball_velocity() const;
  ::protos::Vector2D* _internal_mutable_ball_velocity();

  public:
  // .protos.Vector2D player_position = 4;
  bool has_player_position() const;
  void clear_player_position() ;
  const ::protos::Vector2D& player_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_player_position();
  ::protos::Vector2D* mutable_player_position();
  void set_allocated_player_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_player_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_player_position();

  private:
  const ::protos::Vector2D& _internal_player_position() const;
  ::protos::Vector2D* _internal_mutable_player_position();

  public:
  // int32 uniform_number = 3;
  void clear_uniform_number() ;
  ::int32_t uniform_number() const;
  void set_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_uniform_number() const;
  void _internal_set_uniform_number(::int32_t value);

  public:
  // float body_direction = 5;
  void clear_body_direction() ;
  float body_direction() const;
  void set_body_direction(float value);

  private:
  float _internal_body_direction() const;
  void _internal_set_body_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.BallPlayerMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* ball_position_;
    ::protos::Vector2D* ball_velocity_;
    ::protos::Vector2D* player_position_;
    ::int32_t uniform_number_;
    float body_direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class BallMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.BallMessage) */ {
 public:
  inline BallMessage() : BallMessage(nullptr) {}
  ~BallMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BallMessage(::google::protobuf::internal::ConstantInitialized);

  inline BallMessage(const BallMessage& from)
      : BallMessage(nullptr, from) {}
  BallMessage(BallMessage&& from) noexcept
    : BallMessage() {
    *this = ::std::move(from);
  }

  inline BallMessage& operator=(const BallMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BallMessage& operator=(BallMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BallMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BallMessage* internal_default_instance() {
    return reinterpret_cast<const BallMessage*>(
               &_BallMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BallMessage& a, BallMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BallMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BallMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BallMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BallMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BallMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BallMessage& from) {
    BallMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BallMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.BallMessage";
  }
  protected:
  explicit BallMessage(::google::protobuf::Arena* arena);
  BallMessage(::google::protobuf::Arena* arena, const BallMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBallPositionFieldNumber = 1,
    kBallVelocityFieldNumber = 2,
  };
  // .protos.Vector2D ball_position = 1;
  bool has_ball_position() const;
  void clear_ball_position() ;
  const ::protos::Vector2D& ball_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_position();
  ::protos::Vector2D* mutable_ball_position();
  void set_allocated_ball_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_ball_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_ball_position();

  private:
  const ::protos::Vector2D& _internal_ball_position() const;
  ::protos::Vector2D* _internal_mutable_ball_position();

  public:
  // .protos.Vector2D ball_velocity = 2;
  bool has_ball_velocity() const;
  void clear_ball_velocity() ;
  const ::protos::Vector2D& ball_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_velocity();
  ::protos::Vector2D* mutable_ball_velocity();
  void set_allocated_ball_velocity(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_ball_velocity(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_ball_velocity();

  private:
  const ::protos::Vector2D& _internal_ball_velocity() const;
  ::protos::Vector2D* _internal_mutable_ball_velocity();

  public:
  // @@protoc_insertion_point(class_scope:protos.BallMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* ball_position_;
    ::protos::Vector2D* ball_velocity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class BallGoalieMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.BallGoalieMessage) */ {
 public:
  inline BallGoalieMessage() : BallGoalieMessage(nullptr) {}
  ~BallGoalieMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BallGoalieMessage(::google::protobuf::internal::ConstantInitialized);

  inline BallGoalieMessage(const BallGoalieMessage& from)
      : BallGoalieMessage(nullptr, from) {}
  BallGoalieMessage(BallGoalieMessage&& from) noexcept
    : BallGoalieMessage() {
    *this = ::std::move(from);
  }

  inline BallGoalieMessage& operator=(const BallGoalieMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BallGoalieMessage& operator=(BallGoalieMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BallGoalieMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BallGoalieMessage* internal_default_instance() {
    return reinterpret_cast<const BallGoalieMessage*>(
               &_BallGoalieMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(BallGoalieMessage& a, BallGoalieMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BallGoalieMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BallGoalieMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BallGoalieMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BallGoalieMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BallGoalieMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BallGoalieMessage& from) {
    BallGoalieMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BallGoalieMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.BallGoalieMessage";
  }
  protected:
  explicit BallGoalieMessage(::google::protobuf::Arena* arena);
  BallGoalieMessage(::google::protobuf::Arena* arena, const BallGoalieMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBallPositionFieldNumber = 1,
    kBallVelocityFieldNumber = 2,
    kGoaliePositionFieldNumber = 3,
    kGoalieBodyDirectionFieldNumber = 4,
  };
  // .protos.Vector2D ball_position = 1;
  bool has_ball_position() const;
  void clear_ball_position() ;
  const ::protos::Vector2D& ball_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_position();
  ::protos::Vector2D* mutable_ball_position();
  void set_allocated_ball_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_ball_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_ball_position();

  private:
  const ::protos::Vector2D& _internal_ball_position() const;
  ::protos::Vector2D* _internal_mutable_ball_position();

  public:
  // .protos.Vector2D ball_velocity = 2;
  bool has_ball_velocity() const;
  void clear_ball_velocity() ;
  const ::protos::Vector2D& ball_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_ball_velocity();
  ::protos::Vector2D* mutable_ball_velocity();
  void set_allocated_ball_velocity(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_ball_velocity(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_ball_velocity();

  private:
  const ::protos::Vector2D& _internal_ball_velocity() const;
  ::protos::Vector2D* _internal_mutable_ball_velocity();

  public:
  // .protos.Vector2D goalie_position = 3;
  bool has_goalie_position() const;
  void clear_goalie_position() ;
  const ::protos::Vector2D& goalie_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_goalie_position();
  ::protos::Vector2D* mutable_goalie_position();
  void set_allocated_goalie_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_goalie_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_goalie_position();

  private:
  const ::protos::Vector2D& _internal_goalie_position() const;
  ::protos::Vector2D* _internal_mutable_goalie_position();

  public:
  // float goalie_body_direction = 4;
  void clear_goalie_body_direction() ;
  float goalie_body_direction() const;
  void set_goalie_body_direction(float value);

  private:
  float _internal_goalie_body_direction() const;
  void _internal_set_goalie_body_direction(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.BallGoalieMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* ball_position_;
    ::protos::Vector2D* ball_velocity_;
    ::protos::Vector2D* goalie_position_;
    float goalie_body_direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Ball final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Ball) */ {
 public:
  inline Ball() : Ball(nullptr) {}
  ~Ball() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Ball(::google::protobuf::internal::ConstantInitialized);

  inline Ball(const Ball& from)
      : Ball(nullptr, from) {}
  Ball(Ball&& from) noexcept
    : Ball() {
    *this = ::std::move(from);
  }

  inline Ball& operator=(const Ball& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ball& operator=(Ball&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ball& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ball* internal_default_instance() {
    return reinterpret_cast<const Ball*>(
               &_Ball_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ball& a, Ball& b) {
    a.Swap(&b);
  }
  inline void Swap(Ball* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ball* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ball* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ball>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Ball& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Ball& from) {
    Ball::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Ball* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Ball";
  }
  protected:
  explicit Ball(::google::protobuf::Arena* arena);
  Ball(::google::protobuf::Arena* arena, const Ball& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kRelativePositionFieldNumber = 2,
    kSeenPositionFieldNumber = 3,
    kHeardPositionFieldNumber = 4,
    kVelocityFieldNumber = 5,
    kSeenVelocityFieldNumber = 6,
    kHeardVelocityFieldNumber = 7,
    kPosCountFieldNumber = 8,
    kSeenPosCountFieldNumber = 9,
    kHeardPosCountFieldNumber = 10,
    kVelCountFieldNumber = 11,
    kSeenVelCountFieldNumber = 12,
    kHeardVelCountFieldNumber = 13,
    kLostCountFieldNumber = 14,
    kGhostCountFieldNumber = 15,
    kDistFromSelfFieldNumber = 16,
    kAngleFromSelfFieldNumber = 17,
  };
  // .protos.Vector2D position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_position();

  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();

  public:
  // .protos.Vector2D relative_position = 2;
  bool has_relative_position() const;
  void clear_relative_position() ;
  const ::protos::Vector2D& relative_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_relative_position();
  ::protos::Vector2D* mutable_relative_position();
  void set_allocated_relative_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_relative_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_relative_position();

  private:
  const ::protos::Vector2D& _internal_relative_position() const;
  ::protos::Vector2D* _internal_mutable_relative_position();

  public:
  // .protos.Vector2D seen_position = 3;
  bool has_seen_position() const;
  void clear_seen_position() ;
  const ::protos::Vector2D& seen_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_position();
  ::protos::Vector2D* mutable_seen_position();
  void set_allocated_seen_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_seen_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_seen_position();

  private:
  const ::protos::Vector2D& _internal_seen_position() const;
  ::protos::Vector2D* _internal_mutable_seen_position();

  public:
  // .protos.Vector2D heard_position = 4;
  bool has_heard_position() const;
  void clear_heard_position() ;
  const ::protos::Vector2D& heard_position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_heard_position();
  ::protos::Vector2D* mutable_heard_position();
  void set_allocated_heard_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_heard_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_heard_position();

  private:
  const ::protos::Vector2D& _internal_heard_position() const;
  ::protos::Vector2D* _internal_mutable_heard_position();

  public:
  // .protos.Vector2D velocity = 5;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::protos::Vector2D& velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_velocity();
  ::protos::Vector2D* mutable_velocity();
  void set_allocated_velocity(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_velocity(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_velocity();

  private:
  const ::protos::Vector2D& _internal_velocity() const;
  ::protos::Vector2D* _internal_mutable_velocity();

  public:
  // .protos.Vector2D seen_velocity = 6;
  bool has_seen_velocity() const;
  void clear_seen_velocity() ;
  const ::protos::Vector2D& seen_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_seen_velocity();
  ::protos::Vector2D* mutable_seen_velocity();
  void set_allocated_seen_velocity(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_seen_velocity(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_seen_velocity();

  private:
  const ::protos::Vector2D& _internal_seen_velocity() const;
  ::protos::Vector2D* _internal_mutable_seen_velocity();

  public:
  // .protos.Vector2D heard_velocity = 7;
  bool has_heard_velocity() const;
  void clear_heard_velocity() ;
  const ::protos::Vector2D& heard_velocity() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_heard_velocity();
  ::protos::Vector2D* mutable_heard_velocity();
  void set_allocated_heard_velocity(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_heard_velocity(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_heard_velocity();

  private:
  const ::protos::Vector2D& _internal_heard_velocity() const;
  ::protos::Vector2D* _internal_mutable_heard_velocity();

  public:
  // int32 pos_count = 8;
  void clear_pos_count() ;
  ::int32_t pos_count() const;
  void set_pos_count(::int32_t value);

  private:
  ::int32_t _internal_pos_count() const;
  void _internal_set_pos_count(::int32_t value);

  public:
  // int32 seen_pos_count = 9;
  void clear_seen_pos_count() ;
  ::int32_t seen_pos_count() const;
  void set_seen_pos_count(::int32_t value);

  private:
  ::int32_t _internal_seen_pos_count() const;
  void _internal_set_seen_pos_count(::int32_t value);

  public:
  // int32 heard_pos_count = 10;
  void clear_heard_pos_count() ;
  ::int32_t heard_pos_count() const;
  void set_heard_pos_count(::int32_t value);

  private:
  ::int32_t _internal_heard_pos_count() const;
  void _internal_set_heard_pos_count(::int32_t value);

  public:
  // int32 vel_count = 11;
  void clear_vel_count() ;
  ::int32_t vel_count() const;
  void set_vel_count(::int32_t value);

  private:
  ::int32_t _internal_vel_count() const;
  void _internal_set_vel_count(::int32_t value);

  public:
  // int32 seen_vel_count = 12;
  void clear_seen_vel_count() ;
  ::int32_t seen_vel_count() const;
  void set_seen_vel_count(::int32_t value);

  private:
  ::int32_t _internal_seen_vel_count() const;
  void _internal_set_seen_vel_count(::int32_t value);

  public:
  // int32 heard_vel_count = 13;
  void clear_heard_vel_count() ;
  ::int32_t heard_vel_count() const;
  void set_heard_vel_count(::int32_t value);

  private:
  ::int32_t _internal_heard_vel_count() const;
  void _internal_set_heard_vel_count(::int32_t value);

  public:
  // int32 lost_count = 14;
  void clear_lost_count() ;
  ::int32_t lost_count() const;
  void set_lost_count(::int32_t value);

  private:
  ::int32_t _internal_lost_count() const;
  void _internal_set_lost_count(::int32_t value);

  public:
  // int32 ghost_count = 15;
  void clear_ghost_count() ;
  ::int32_t ghost_count() const;
  void set_ghost_count(::int32_t value);

  private:
  ::int32_t _internal_ghost_count() const;
  void _internal_set_ghost_count(::int32_t value);

  public:
  // float dist_from_self = 16;
  void clear_dist_from_self() ;
  float dist_from_self() const;
  void set_dist_from_self(float value);

  private:
  float _internal_dist_from_self() const;
  void _internal_set_dist_from_self(float value);

  public:
  // float angle_from_self = 17;
  void clear_angle_from_self() ;
  float angle_from_self() const;
  void set_angle_from_self(float value);

  private:
  float _internal_angle_from_self() const;
  void _internal_set_angle_from_self(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.Ball)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 17, 7,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::Vector2D* position_;
    ::protos::Vector2D* relative_position_;
    ::protos::Vector2D* seen_position_;
    ::protos::Vector2D* heard_position_;
    ::protos::Vector2D* velocity_;
    ::protos::Vector2D* seen_velocity_;
    ::protos::Vector2D* heard_velocity_;
    ::int32_t pos_count_;
    ::int32_t seen_pos_count_;
    ::int32_t heard_pos_count_;
    ::int32_t vel_count_;
    ::int32_t seen_vel_count_;
    ::int32_t heard_vel_count_;
    ::int32_t lost_count_;
    ::int32_t ghost_count_;
    float dist_from_self_;
    float angle_from_self_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddTriangle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.AddTriangle) */ {
 public:
  inline AddTriangle() : AddTriangle(nullptr) {}
  ~AddTriangle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddTriangle(::google::protobuf::internal::ConstantInitialized);

  inline AddTriangle(const AddTriangle& from)
      : AddTriangle(nullptr, from) {}
  AddTriangle(AddTriangle&& from) noexcept
    : AddTriangle() {
    *this = ::std::move(from);
  }

  inline AddTriangle& operator=(const AddTriangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTriangle& operator=(AddTriangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddTriangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddTriangle* internal_default_instance() {
    return reinterpret_cast<const AddTriangle*>(
               &_AddTriangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(AddTriangle& a, AddTriangle& b) {
    a.Swap(&b);
  }
  inline void Swap(AddTriangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddTriangle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddTriangle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddTriangle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddTriangle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddTriangle& from) {
    AddTriangle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddTriangle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddTriangle";
  }
  protected:
  explicit AddTriangle(::google::protobuf::Arena* arena);
  AddTriangle(::google::protobuf::Arena* arena, const AddTriangle& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 5,
    kPoint1FieldNumber = 2,
    kPoint2FieldNumber = 3,
    kPoint3FieldNumber = 4,
    kLevelFieldNumber = 1,
    kFillFieldNumber = 6,
  };
  // string color = 5;
  void clear_color() ;
  const std::string& color() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* value);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D point1 = 2;
  bool has_point1() const;
  void clear_point1() ;
  const ::protos::Vector2D& point1() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point1();
  ::protos::Vector2D* mutable_point1();
  void set_allocated_point1(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_point1(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_point1();

  private:
  const ::protos::Vector2D& _internal_point1() const;
  ::protos::Vector2D* _internal_mutable_point1();

  public:
  // .protos.Vector2D point2 = 3;
  bool has_point2() const;
  void clear_point2() ;
  const ::protos::Vector2D& point2() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point2();
  ::protos::Vector2D* mutable_point2();
  void set_allocated_point2(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_point2(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_point2();

  private:
  const ::protos::Vector2D& _internal_point2() const;
  ::protos::Vector2D* _internal_mutable_point2();

  public:
  // .protos.Vector2D point3 = 4;
  bool has_point3() const;
  void clear_point3() ;
  const ::protos::Vector2D& point3() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point3();
  ::protos::Vector2D* mutable_point3();
  void set_allocated_point3(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_point3(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_point3();

  private:
  const ::protos::Vector2D& _internal_point3() const;
  ::protos::Vector2D* _internal_mutable_point3();

  public:
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // bool fill = 6;
  void clear_fill() ;
  bool fill() const;
  void set_fill(bool value);

  private:
  bool _internal_fill() const;
  void _internal_set_fill(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddTriangle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr color_;
    ::protos::Vector2D* point1_;
    ::protos::Vector2D* point2_;
    ::protos::Vector2D* point3_;
    int level_;
    bool fill_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddSector final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.AddSector) */ {
 public:
  inline AddSector() : AddSector(nullptr) {}
  ~AddSector() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddSector(::google::protobuf::internal::ConstantInitialized);

  inline AddSector(const AddSector& from)
      : AddSector(nullptr, from) {}
  AddSector(AddSector&& from) noexcept
    : AddSector() {
    *this = ::std::move(from);
  }

  inline AddSector& operator=(const AddSector& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddSector& operator=(AddSector&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddSector& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddSector* internal_default_instance() {
    return reinterpret_cast<const AddSector*>(
               &_AddSector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(AddSector& a, AddSector& b) {
    a.Swap(&b);
  }
  inline void Swap(AddSector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddSector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddSector* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddSector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddSector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddSector& from) {
    AddSector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddSector* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddSector";
  }
  protected:
  explicit AddSector(::google::protobuf::Arena* arena);
  AddSector(::google::protobuf::Arena* arena, const AddSector& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 7,
    kCenterFieldNumber = 2,
    kLevelFieldNumber = 1,
    kMinRadiusFieldNumber = 3,
    kMaxRadiusFieldNumber = 4,
    kStartAngleFieldNumber = 5,
    kSpanAngelFieldNumber = 6,
    kFillFieldNumber = 8,
  };
  // string color = 7;
  void clear_color() ;
  const std::string& color() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* value);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::protos::Vector2D& center() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_center();
  ::protos::Vector2D* mutable_center();
  void set_allocated_center(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_center(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_center();

  private:
  const ::protos::Vector2D& _internal_center() const;
  ::protos::Vector2D* _internal_mutable_center();

  public:
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // float min_radius = 3;
  void clear_min_radius() ;
  float min_radius() const;
  void set_min_radius(float value);

  private:
  float _internal_min_radius() const;
  void _internal_set_min_radius(float value);

  public:
  // float max_radius = 4;
  void clear_max_radius() ;
  float max_radius() const;
  void set_max_radius(float value);

  private:
  float _internal_max_radius() const;
  void _internal_set_max_radius(float value);

  public:
  // float start_angle = 5;
  void clear_start_angle() ;
  float start_angle() const;
  void set_start_angle(float value);

  private:
  float _internal_start_angle() const;
  void _internal_set_start_angle(float value);

  public:
  // float span_angel = 6;
  void clear_span_angel() ;
  float span_angel() const;
  void set_span_angel(float value);

  private:
  float _internal_span_angel() const;
  void _internal_set_span_angel(float value);

  public:
  // bool fill = 8;
  void clear_fill() ;
  bool fill() const;
  void set_fill(bool value);

  private:
  bool _internal_fill() const;
  void _internal_set_fill(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddSector)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr color_;
    ::protos::Vector2D* center_;
    int level_;
    float min_radius_;
    float max_radius_;
    float start_angle_;
    float span_angel_;
    bool fill_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddPoint final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.AddPoint) */ {
 public:
  inline AddPoint() : AddPoint(nullptr) {}
  ~AddPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddPoint(::google::protobuf::internal::ConstantInitialized);

  inline AddPoint(const AddPoint& from)
      : AddPoint(nullptr, from) {}
  AddPoint(AddPoint&& from) noexcept
    : AddPoint() {
    *this = ::std::move(from);
  }

  inline AddPoint& operator=(const AddPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPoint& operator=(AddPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPoint* internal_default_instance() {
    return reinterpret_cast<const AddPoint*>(
               &_AddPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(AddPoint& a, AddPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddPoint& from) {
    AddPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddPoint";
  }
  protected:
  explicit AddPoint(::google::protobuf::Arena* arena);
  AddPoint(::google::protobuf::Arena* arena, const AddPoint& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 3,
    kPointFieldNumber = 2,
    kLevelFieldNumber = 1,
  };
  // string color = 3;
  void clear_color() ;
  const std::string& color() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* value);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D point = 2;
  bool has_point() const;
  void clear_point() ;
  const ::protos::Vector2D& point() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_point();
  ::protos::Vector2D* mutable_point();
  void set_allocated_point(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_point(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_point();

  private:
  const ::protos::Vector2D& _internal_point() const;
  ::protos::Vector2D* _internal_mutable_point();

  public:
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      29, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr color_;
    ::protos::Vector2D* point_;
    int level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.AddMessage) */ {
 public:
  inline AddMessage() : AddMessage(nullptr) {}
  ~AddMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddMessage(::google::protobuf::internal::ConstantInitialized);

  inline AddMessage(const AddMessage& from)
      : AddMessage(nullptr, from) {}
  AddMessage(AddMessage&& from) noexcept
    : AddMessage() {
    *this = ::std::move(from);
  }

  inline AddMessage& operator=(const AddMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddMessage& operator=(AddMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddMessage* internal_default_instance() {
    return reinterpret_cast<const AddMessage*>(
               &_AddMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(AddMessage& a, AddMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AddMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddMessage& from) {
    AddMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddMessage";
  }
  protected:
  explicit AddMessage(::google::protobuf::Arena* arena);
  AddMessage(::google::protobuf::Arena* arena, const AddMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kColorFieldNumber = 4,
    kPositionFieldNumber = 2,
    kLevelFieldNumber = 1,
  };
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // string color = 4;
  void clear_color() ;
  const std::string& color() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* value);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::protos::Vector2D& position() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_position();
  ::protos::Vector2D* mutable_position();
  void set_allocated_position(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_position(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_position();

  private:
  const ::protos::Vector2D& _internal_position() const;
  ::protos::Vector2D* _internal_mutable_position();

  public:
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr color_;
    ::protos::Vector2D* position_;
    int level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddLine final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.AddLine) */ {
 public:
  inline AddLine() : AddLine(nullptr) {}
  ~AddLine() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddLine(::google::protobuf::internal::ConstantInitialized);

  inline AddLine(const AddLine& from)
      : AddLine(nullptr, from) {}
  AddLine(AddLine&& from) noexcept
    : AddLine() {
    *this = ::std::move(from);
  }

  inline AddLine& operator=(const AddLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddLine& operator=(AddLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddLine* internal_default_instance() {
    return reinterpret_cast<const AddLine*>(
               &_AddLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(AddLine& a, AddLine& b) {
    a.Swap(&b);
  }
  inline void Swap(AddLine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddLine* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddLine* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddLine>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddLine& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddLine& from) {
    AddLine::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddLine* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddLine";
  }
  protected:
  explicit AddLine(::google::protobuf::Arena* arena);
  AddLine(::google::protobuf::Arena* arena, const AddLine& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 4,
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
    kLevelFieldNumber = 1,
  };
  // string color = 4;
  void clear_color() ;
  const std::string& color() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* value);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D start = 2;
  bool has_start() const;
  void clear_start() ;
  const ::protos::Vector2D& start() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_start();
  ::protos::Vector2D* mutable_start();
  void set_allocated_start(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_start(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_start();

  private:
  const ::protos::Vector2D& _internal_start() const;
  ::protos::Vector2D* _internal_mutable_start();

  public:
  // .protos.Vector2D end = 3;
  bool has_end() const;
  void clear_end() ;
  const ::protos::Vector2D& end() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_end();
  ::protos::Vector2D* mutable_end();
  void set_allocated_end(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_end(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_end();

  private:
  const ::protos::Vector2D& _internal_end() const;
  ::protos::Vector2D* _internal_mutable_end();

  public:
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddLine)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      28, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr color_;
    ::protos::Vector2D* start_;
    ::protos::Vector2D* end_;
    int level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddCircle final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.AddCircle) */ {
 public:
  inline AddCircle() : AddCircle(nullptr) {}
  ~AddCircle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddCircle(::google::protobuf::internal::ConstantInitialized);

  inline AddCircle(const AddCircle& from)
      : AddCircle(nullptr, from) {}
  AddCircle(AddCircle&& from) noexcept
    : AddCircle() {
    *this = ::std::move(from);
  }

  inline AddCircle& operator=(const AddCircle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddCircle& operator=(AddCircle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddCircle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddCircle* internal_default_instance() {
    return reinterpret_cast<const AddCircle*>(
               &_AddCircle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(AddCircle& a, AddCircle& b) {
    a.Swap(&b);
  }
  inline void Swap(AddCircle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddCircle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddCircle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddCircle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddCircle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddCircle& from) {
    AddCircle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddCircle* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddCircle";
  }
  protected:
  explicit AddCircle(::google::protobuf::Arena* arena);
  AddCircle(::google::protobuf::Arena* arena, const AddCircle& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 4,
    kCenterFieldNumber = 2,
    kLevelFieldNumber = 1,
    kRadiusFieldNumber = 3,
    kFillFieldNumber = 5,
  };
  // string color = 4;
  void clear_color() ;
  const std::string& color() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* value);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::protos::Vector2D& center() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_center();
  ::protos::Vector2D* mutable_center();
  void set_allocated_center(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_center(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_center();

  private:
  const ::protos::Vector2D& _internal_center() const;
  ::protos::Vector2D* _internal_mutable_center();

  public:
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // float radius = 3;
  void clear_radius() ;
  float radius() const;
  void set_radius(float value);

  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);

  public:
  // bool fill = 5;
  void clear_fill() ;
  bool fill() const;
  void set_fill(bool value);

  private:
  bool _internal_fill() const;
  void _internal_set_fill(bool value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddCircle)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      30, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr color_;
    ::protos::Vector2D* center_;
    int level_;
    float radius_;
    bool fill_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class AddArc final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.AddArc) */ {
 public:
  inline AddArc() : AddArc(nullptr) {}
  ~AddArc() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddArc(::google::protobuf::internal::ConstantInitialized);

  inline AddArc(const AddArc& from)
      : AddArc(nullptr, from) {}
  AddArc(AddArc&& from) noexcept
    : AddArc() {
    *this = ::std::move(from);
  }

  inline AddArc& operator=(const AddArc& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddArc& operator=(AddArc&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddArc& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddArc* internal_default_instance() {
    return reinterpret_cast<const AddArc*>(
               &_AddArc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(AddArc& a, AddArc& b) {
    a.Swap(&b);
  }
  inline void Swap(AddArc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddArc* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddArc* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddArc>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddArc& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AddArc& from) {
    AddArc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddArc* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.AddArc";
  }
  protected:
  explicit AddArc(::google::protobuf::Arena* arena);
  AddArc(::google::protobuf::Arena* arena, const AddArc& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 6,
    kCenterFieldNumber = 2,
    kLevelFieldNumber = 1,
    kRadiusFieldNumber = 3,
    kStartAngleFieldNumber = 4,
    kSpanAngelFieldNumber = 5,
  };
  // string color = 6;
  void clear_color() ;
  const std::string& color() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* value);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // .protos.Vector2D center = 2;
  bool has_center() const;
  void clear_center() ;
  const ::protos::Vector2D& center() const;
  PROTOBUF_NODISCARD ::protos::Vector2D* release_center();
  ::protos::Vector2D* mutable_center();
  void set_allocated_center(::protos::Vector2D* value);
  void unsafe_arena_set_allocated_center(::protos::Vector2D* value);
  ::protos::Vector2D* unsafe_arena_release_center();

  private:
  const ::protos::Vector2D& _internal_center() const;
  ::protos::Vector2D* _internal_mutable_center();

  public:
  // .protos.LoggerLevel level = 1;
  void clear_level() ;
  ::protos::LoggerLevel level() const;
  void set_level(::protos::LoggerLevel value);

  private:
  ::protos::LoggerLevel _internal_level() const;
  void _internal_set_level(::protos::LoggerLevel value);

  public:
  // float radius = 3;
  void clear_radius() ;
  float radius() const;
  void set_radius(float value);

  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);

  public:
  // float start_angle = 4;
  void clear_start_angle() ;
  float start_angle() const;
  void set_start_angle(float value);

  private:
  float _internal_start_angle() const;
  void _internal_set_start_angle(float value);

  public:
  // float span_angel = 5;
  void clear_span_angel() ;
  float span_angel() const;
  void set_span_angel(float value);

  private:
  float _internal_span_angel() const;
  void _internal_set_span_angel(float value);

  public:
  // @@protoc_insertion_point(class_scope:protos.AddArc)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      27, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr color_;
    ::protos::Vector2D* center_;
    int level_;
    float radius_;
    float start_angle_;
    float span_angel_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class WorldModel_TheirPlayersDictEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          WorldModel_TheirPlayersDictEntry_DoNotUse, ::int32_t, ::protos::Player,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      WorldModel_TheirPlayersDictEntry_DoNotUse, ::int32_t, ::protos::Player,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  WorldModel_TheirPlayersDictEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorldModel_TheirPlayersDictEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit WorldModel_TheirPlayersDictEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const WorldModel_TheirPlayersDictEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const WorldModel_TheirPlayersDictEntry_DoNotUse*>(
        &_WorldModel_TheirPlayersDictEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class WorldModel_OurPlayersDictEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          WorldModel_OurPlayersDictEntry_DoNotUse, ::int32_t, ::protos::Player,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      WorldModel_OurPlayersDictEntry_DoNotUse, ::int32_t, ::protos::Player,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  WorldModel_OurPlayersDictEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorldModel_OurPlayersDictEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit WorldModel_OurPlayersDictEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const WorldModel_OurPlayersDictEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const WorldModel_OurPlayersDictEntry_DoNotUse*>(
        &_WorldModel_OurPlayersDictEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_service_2eproto;
};
// -------------------------------------------------------------------

class TrainerAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.TrainerAction) */ {
 public:
  inline TrainerAction() : TrainerAction(nullptr) {}
  ~TrainerAction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrainerAction(::google::protobuf::internal::ConstantInitialized);

  inline TrainerAction(const TrainerAction& from)
      : TrainerAction(nullptr, from) {}
  TrainerAction(TrainerAction&& from) noexcept
    : TrainerAction() {
    *this = ::std::move(from);
  }

  inline TrainerAction& operator=(const TrainerAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainerAction& operator=(TrainerAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainerAction& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kDoKickOff = 1,
    kDoMoveBall = 2,
    kDoMovePlayer = 3,
    kDoRecover = 4,
    kDoChangeMode = 5,
    kDoChangePlayerType = 6,
    ACTION_NOT_SET = 0,
  };

  static inline const TrainerAction* internal_default_instance() {
    return reinterpret_cast<const TrainerAction*>(
               &_TrainerAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(TrainerAction& a, TrainerAction& b) {
    a.Swap(&b);
  }
  inline void Swap(TrainerAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainerAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainerAction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainerAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrainerAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrainerAction& from) {
    TrainerAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrainerAction* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.TrainerAction";
  }
  protected:
  explicit TrainerAction(::google::protobuf::Arena* arena);
  TrainerAction(::google::protobuf::Arena* arena, const TrainerAction& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDoKickOffFieldNumber = 1,
    kDoMoveBallFieldNumber = 2,
    kDoMovePlayerFieldNumber = 3,
    kDoRecoverFieldNumber = 4,
    kDoChangeModeFieldNumber = 5,
    kDoChangePlayerTypeFieldNumber = 6,
  };
  // .protos.DoKickOff do_kick_off = 1;
  bool has_do_kick_off() const;
  private:
  bool _internal_has_do_kick_off() const;

  public:
  void clear_do_kick_off() ;
  const ::protos::DoKickOff& do_kick_off() const;
  PROTOBUF_NODISCARD ::protos::DoKickOff* release_do_kick_off();
  ::protos::DoKickOff* mutable_do_kick_off();
  void set_allocated_do_kick_off(::protos::DoKickOff* value);
  void unsafe_arena_set_allocated_do_kick_off(::protos::DoKickOff* value);
  ::protos::DoKickOff* unsafe_arena_release_do_kick_off();

  private:
  const ::protos::DoKickOff& _internal_do_kick_off() const;
  ::protos::DoKickOff* _internal_mutable_do_kick_off();

  public:
  // .protos.DoMoveBall do_move_ball = 2;
  bool has_do_move_ball() const;
  private:
  bool _internal_has_do_move_ball() const;

  public:
  void clear_do_move_ball() ;
  const ::protos::DoMoveBall& do_move_ball() const;
  PROTOBUF_NODISCARD ::protos::DoMoveBall* release_do_move_ball();
  ::protos::DoMoveBall* mutable_do_move_ball();
  void set_allocated_do_move_ball(::protos::DoMoveBall* value);
  void unsafe_arena_set_allocated_do_move_ball(::protos::DoMoveBall* value);
  ::protos::DoMoveBall* unsafe_arena_release_do_move_ball();

  private:
  const ::protos::DoMoveBall& _internal_do_move_ball() const;
  ::protos::DoMoveBall* _internal_mutable_do_move_ball();

  public:
  // .protos.DoMovePlayer do_move_player = 3;
  bool has_do_move_player() const;
  private:
  bool _internal_has_do_move_player() const;

  public:
  void clear_do_move_player() ;
  const ::protos::DoMovePlayer& do_move_player() const;
  PROTOBUF_NODISCARD ::protos::DoMovePlayer* release_do_move_player();
  ::protos::DoMovePlayer* mutable_do_move_player();
  void set_allocated_do_move_player(::protos::DoMovePlayer* value);
  void unsafe_arena_set_allocated_do_move_player(::protos::DoMovePlayer* value);
  ::protos::DoMovePlayer* unsafe_arena_release_do_move_player();

  private:
  const ::protos::DoMovePlayer& _internal_do_move_player() const;
  ::protos::DoMovePlayer* _internal_mutable_do_move_player();

  public:
  // .protos.DoRecover do_recover = 4;
  bool has_do_recover() const;
  private:
  bool _internal_has_do_recover() const;

  public:
  void clear_do_recover() ;
  const ::protos::DoRecover& do_recover() const;
  PROTOBUF_NODISCARD ::protos::DoRecover* release_do_recover();
  ::protos::DoRecover* mutable_do_recover();
  void set_allocated_do_recover(::protos::DoRecover* value);
  void unsafe_arena_set_allocated_do_recover(::protos::DoRecover* value);
  ::protos::DoRecover* unsafe_arena_release_do_recover();

  private:
  const ::protos::DoRecover& _internal_do_recover() const;
  ::protos::DoRecover* _internal_mutable_do_recover();

  public:
  // .protos.DoChangeMode do_change_mode = 5;
  bool has_do_change_mode() const;
  private:
  bool _internal_has_do_change_mode() const;

  public:
  void clear_do_change_mode() ;
  const ::protos::DoChangeMode& do_change_mode() const;
  PROTOBUF_NODISCARD ::protos::DoChangeMode* release_do_change_mode();
  ::protos::DoChangeMode* mutable_do_change_mode();
  void set_allocated_do_change_mode(::protos::DoChangeMode* value);
  void unsafe_arena_set_allocated_do_change_mode(::protos::DoChangeMode* value);
  ::protos::DoChangeMode* unsafe_arena_release_do_change_mode();

  private:
  const ::protos::DoChangeMode& _internal_do_change_mode() const;
  ::protos::DoChangeMode* _internal_mutable_do_change_mode();

  public:
  // .protos.DoChangePlayerType do_change_player_type = 6;
  bool has_do_change_player_type() const;
  private:
  bool _internal_has_do_change_player_type() const;

  public:
  void clear_do_change_player_type() ;
  const ::protos::DoChangePlayerType& do_change_player_type() const;
  PROTOBUF_NODISCARD ::protos::DoChangePlayerType* release_do_change_player_type();
  ::protos::DoChangePlayerType* mutable_do_change_player_type();
  void set_allocated_do_change_player_type(::protos::DoChangePlayerType* value);
  void unsafe_arena_set_allocated_do_change_player_type(::protos::DoChangePlayerType* value);
  ::protos::DoChangePlayerType* unsafe_arena_release_do_change_player_type();

  private:
  const ::protos::DoChangePlayerType& _internal_do_change_player_type() const;
  ::protos::DoChangePlayerType* _internal_mutable_do_change_player_type();

  public:
  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:protos.TrainerAction)
 private:
  class _Internal;
  void set_has_do_kick_off();
  void set_has_do_move_ball();
  void set_has_do_move_player();
  void set_has_do_recover();
  void set_has_do_change_mode();
  void set_has_do_change_player_type();

  inline bool has_action() const;
  inline void clear_has_action();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 6, 6,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::protos::DoKickOff* do_kick_off_;
      ::protos::DoMoveBall* do_move_ball_;
      ::protos::DoMovePlayer* do_move_player_;
      ::protos::DoRecover* do_recover_;
      ::protos::DoChangeMode* do_change_mode_;
      ::protos::DoChangePlayerType* do_change_player_type_;
    } action_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Say final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Say) */ {
 public:
  inline Say() : Say(nullptr) {}
  ~Say() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Say(::google::protobuf::internal::ConstantInitialized);

  inline Say(const Say& from)
      : Say(nullptr, from) {}
  Say(Say&& from) noexcept
    : Say() {
    *this = ::std::move(from);
  }

  inline Say& operator=(const Say& from) {
    CopyFrom(from);
    return *this;
  }
  inline Say& operator=(Say&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Say& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kBallMessage = 1,
    kPassMessage = 2,
    kInterceptMessage = 3,
    kGoalieMessage = 4,
    kGoalieAndPlayerMessage = 5,
    kOffsideLineMessage = 6,
    kDefenseLineMessage = 7,
    kWaitRequestMessage = 8,
    kSetplayMessage = 9,
    kPassRequestMessage = 10,
    kStaminaMessage = 11,
    kRecoveryMessage = 12,
    kStaminaCapacityMessage = 13,
    kDribbleMessage = 14,
    kBallGoalieMessage = 15,
    kOnePlayerMessage = 16,
    kTwoPlayerMessage = 17,
    kThreePlayerMessage = 18,
    kSelfMessage = 19,
    kTeammateMessage = 20,
    kOpponentMessage = 21,
    kBallPlayerMessage = 22,
    MESSAGE_NOT_SET = 0,
  };

  static inline const Say* internal_default_instance() {
    return reinterpret_cast<const Say*>(
               &_Say_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(Say& a, Say& b) {
    a.Swap(&b);
  }
  inline void Swap(Say* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Say* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Say* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Say>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Say& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Say& from) {
    Say::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Say* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Say";
  }
  protected:
  explicit Say(::google::protobuf::Arena* arena);
  Say(::google::protobuf::Arena* arena, const Say& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBallMessageFieldNumber = 1,
    kPassMessageFieldNumber = 2,
    kInterceptMessageFieldNumber = 3,
    kGoalieMessageFieldNumber = 4,
    kGoalieAndPlayerMessageFieldNumber = 5,
    kOffsideLineMessageFieldNumber = 6,
    kDefenseLineMessageFieldNumber = 7,
    kWaitRequestMessageFieldNumber = 8,
    kSetplayMessageFieldNumber = 9,
    kPassRequestMessageFieldNumber = 10,
    kStaminaMessageFieldNumber = 11,
    kRecoveryMessageFieldNumber = 12,
    kStaminaCapacityMessageFieldNumber = 13,
    kDribbleMessageFieldNumber = 14,
    kBallGoalieMessageFieldNumber = 15,
    kOnePlayerMessageFieldNumber = 16,
    kTwoPlayerMessageFieldNumber = 17,
    kThreePlayerMessageFieldNumber = 18,
    kSelfMessageFieldNumber = 19,
    kTeammateMessageFieldNumber = 20,
    kOpponentMessageFieldNumber = 21,
    kBallPlayerMessageFieldNumber = 22,
  };
  // .protos.BallMessage ball_message = 1;
  bool has_ball_message() const;
  private:
  bool _internal_has_ball_message() const;

  public:
  void clear_ball_message() ;
  const ::protos::BallMessage& ball_message() const;
  PROTOBUF_NODISCARD ::protos::BallMessage* release_ball_message();
  ::protos::BallMessage* mutable_ball_message();
  void set_allocated_ball_message(::protos::BallMessage* value);
  void unsafe_arena_set_allocated_ball_message(::protos::BallMessage* value);
  ::protos::BallMessage* unsafe_arena_release_ball_message();

  private:
  const ::protos::BallMessage& _internal_ball_message() const;
  ::protos::BallMessage* _internal_mutable_ball_message();

  public:
  // .protos.PassMessage pass_message = 2;
  bool has_pass_message() const;
  private:
  bool _internal_has_pass_message() const;

  public:
  void clear_pass_message() ;
  const ::protos::PassMessage& pass_message() const;
  PROTOBUF_NODISCARD ::protos::PassMessage* release_pass_message();
  ::protos::PassMessage* mutable_pass_message();
  void set_allocated_pass_message(::protos::PassMessage* value);
  void unsafe_arena_set_allocated_pass_message(::protos::PassMessage* value);
  ::protos::PassMessage* unsafe_arena_release_pass_message();

  private:
  const ::protos::PassMessage& _internal_pass_message() const;
  ::protos::PassMessage* _internal_mutable_pass_message();

  public:
  // .protos.InterceptMessage intercept_message = 3;
  bool has_intercept_message() const;
  private:
  bool _internal_has_intercept_message() const;

  public:
  void clear_intercept_message() ;
  const ::protos::InterceptMessage& intercept_message() const;
  PROTOBUF_NODISCARD ::protos::InterceptMessage* release_intercept_message();
  ::protos::InterceptMessage* mutable_intercept_message();
  void set_allocated_intercept_message(::protos::InterceptMessage* value);
  void unsafe_arena_set_allocated_intercept_message(::protos::InterceptMessage* value);
  ::protos::InterceptMessage* unsafe_arena_release_intercept_message();

  private:
  const ::protos::InterceptMessage& _internal_intercept_message() const;
  ::protos::InterceptMessage* _internal_mutable_intercept_message();

  public:
  // .protos.GoalieMessage goalie_message = 4;
  bool has_goalie_message() const;
  private:
  bool _internal_has_goalie_message() const;

  public:
  void clear_goalie_message() ;
  const ::protos::GoalieMessage& goalie_message() const;
  PROTOBUF_NODISCARD ::protos::GoalieMessage* release_goalie_message();
  ::protos::GoalieMessage* mutable_goalie_message();
  void set_allocated_goalie_message(::protos::GoalieMessage* value);
  void unsafe_arena_set_allocated_goalie_message(::protos::GoalieMessage* value);
  ::protos::GoalieMessage* unsafe_arena_release_goalie_message();

  private:
  const ::protos::GoalieMessage& _internal_goalie_message() const;
  ::protos::GoalieMessage* _internal_mutable_goalie_message();

  public:
  // .protos.GoalieAndPlayerMessage goalie_and_player_message = 5;
  bool has_goalie_and_player_message() const;
  private:
  bool _internal_has_goalie_and_player_message() const;

  public:
  void clear_goalie_and_player_message() ;
  const ::protos::GoalieAndPlayerMessage& goalie_and_player_message() const;
  PROTOBUF_NODISCARD ::protos::GoalieAndPlayerMessage* release_goalie_and_player_message();
  ::protos::GoalieAndPlayerMessage* mutable_goalie_and_player_message();
  void set_allocated_goalie_and_player_message(::protos::GoalieAndPlayerMessage* value);
  void unsafe_arena_set_allocated_goalie_and_player_message(::protos::GoalieAndPlayerMessage* value);
  ::protos::GoalieAndPlayerMessage* unsafe_arena_release_goalie_and_player_message();

  private:
  const ::protos::GoalieAndPlayerMessage& _internal_goalie_and_player_message() const;
  ::protos::GoalieAndPlayerMessage* _internal_mutable_goalie_and_player_message();

  public:
  // .protos.OffsideLineMessage offside_line_message = 6;
  bool has_offside_line_message() const;
  private:
  bool _internal_has_offside_line_message() const;

  public:
  void clear_offside_line_message() ;
  const ::protos::OffsideLineMessage& offside_line_message() const;
  PROTOBUF_NODISCARD ::protos::OffsideLineMessage* release_offside_line_message();
  ::protos::OffsideLineMessage* mutable_offside_line_message();
  void set_allocated_offside_line_message(::protos::OffsideLineMessage* value);
  void unsafe_arena_set_allocated_offside_line_message(::protos::OffsideLineMessage* value);
  ::protos::OffsideLineMessage* unsafe_arena_release_offside_line_message();

  private:
  const ::protos::OffsideLineMessage& _internal_offside_line_message() const;
  ::protos::OffsideLineMessage* _internal_mutable_offside_line_message();

  public:
  // .protos.DefenseLineMessage defense_line_message = 7;
  bool has_defense_line_message() const;
  private:
  bool _internal_has_defense_line_message() const;

  public:
  void clear_defense_line_message() ;
  const ::protos::DefenseLineMessage& defense_line_message() const;
  PROTOBUF_NODISCARD ::protos::DefenseLineMessage* release_defense_line_message();
  ::protos::DefenseLineMessage* mutable_defense_line_message();
  void set_allocated_defense_line_message(::protos::DefenseLineMessage* value);
  void unsafe_arena_set_allocated_defense_line_message(::protos::DefenseLineMessage* value);
  ::protos::DefenseLineMessage* unsafe_arena_release_defense_line_message();

  private:
  const ::protos::DefenseLineMessage& _internal_defense_line_message() const;
  ::protos::DefenseLineMessage* _internal_mutable_defense_line_message();

  public:
  // .protos.WaitRequestMessage wait_request_message = 8;
  bool has_wait_request_message() const;
  private:
  bool _internal_has_wait_request_message() const;

  public:
  void clear_wait_request_message() ;
  const ::protos::WaitRequestMessage& wait_request_message() const;
  PROTOBUF_NODISCARD ::protos::WaitRequestMessage* release_wait_request_message();
  ::protos::WaitRequestMessage* mutable_wait_request_message();
  void set_allocated_wait_request_message(::protos::WaitRequestMessage* value);
  void unsafe_arena_set_allocated_wait_request_message(::protos::WaitRequestMessage* value);
  ::protos::WaitRequestMessage* unsafe_arena_release_wait_request_message();

  private:
  const ::protos::WaitRequestMessage& _internal_wait_request_message() const;
  ::protos::WaitRequestMessage* _internal_mutable_wait_request_message();

  public:
  // .protos.SetplayMessage setplay_message = 9;
  bool has_setplay_message() const;
  private:
  bool _internal_has_setplay_message() const;

  public:
  void clear_setplay_message() ;
  const ::protos::SetplayMessage& setplay_message() const;
  PROTOBUF_NODISCARD ::protos::SetplayMessage* release_setplay_message();
  ::protos::SetplayMessage* mutable_setplay_message();
  void set_allocated_setplay_message(::protos::SetplayMessage* value);
  void unsafe_arena_set_allocated_setplay_message(::protos::SetplayMessage* value);
  ::protos::SetplayMessage* unsafe_arena_release_setplay_message();

  private:
  const ::protos::SetplayMessage& _internal_setplay_message() const;
  ::protos::SetplayMessage* _internal_mutable_setplay_message();

  public:
  // .protos.PassRequestMessage pass_request_message = 10;
  bool has_pass_request_message() const;
  private:
  bool _internal_has_pass_request_message() const;

  public:
  void clear_pass_request_message() ;
  const ::protos::PassRequestMessage& pass_request_message() const;
  PROTOBUF_NODISCARD ::protos::PassRequestMessage* release_pass_request_message();
  ::protos::PassRequestMessage* mutable_pass_request_message();
  void set_allocated_pass_request_message(::protos::PassRequestMessage* value);
  void unsafe_arena_set_allocated_pass_request_message(::protos::PassRequestMessage* value);
  ::protos::PassRequestMessage* unsafe_arena_release_pass_request_message();

  private:
  const ::protos::PassRequestMessage& _internal_pass_request_message() const;
  ::protos::PassRequestMessage* _internal_mutable_pass_request_message();

  public:
  // .protos.StaminaMessage stamina_message = 11;
  bool has_stamina_message() const;
  private:
  bool _internal_has_stamina_message() const;

  public:
  void clear_stamina_message() ;
  const ::protos::StaminaMessage& stamina_message() const;
  PROTOBUF_NODISCARD ::protos::StaminaMessage* release_stamina_message();
  ::protos::StaminaMessage* mutable_stamina_message();
  void set_allocated_stamina_message(::protos::StaminaMessage* value);
  void unsafe_arena_set_allocated_stamina_message(::protos::StaminaMessage* value);
  ::protos::StaminaMessage* unsafe_arena_release_stamina_message();

  private:
  const ::protos::StaminaMessage& _internal_stamina_message() const;
  ::protos::StaminaMessage* _internal_mutable_stamina_message();

  public:
  // .protos.RecoveryMessage recovery_message = 12;
  bool has_recovery_message() const;
  private:
  bool _internal_has_recovery_message() const;

  public:
  void clear_recovery_message() ;
  const ::protos::RecoveryMessage& recovery_message() const;
  PROTOBUF_NODISCARD ::protos::RecoveryMessage* release_recovery_message();
  ::protos::RecoveryMessage* mutable_recovery_message();
  void set_allocated_recovery_message(::protos::RecoveryMessage* value);
  void unsafe_arena_set_allocated_recovery_message(::protos::RecoveryMessage* value);
  ::protos::RecoveryMessage* unsafe_arena_release_recovery_message();

  private:
  const ::protos::RecoveryMessage& _internal_recovery_message() const;
  ::protos::RecoveryMessage* _internal_mutable_recovery_message();

  public:
  // .protos.StaminaCapacityMessage stamina_capacity_message = 13;
  bool has_stamina_capacity_message() const;
  private:
  bool _internal_has_stamina_capacity_message() const;

  public:
  void clear_stamina_capacity_message() ;
  const ::protos::StaminaCapacityMessage& stamina_capacity_message() const;
  PROTOBUF_NODISCARD ::protos::StaminaCapacityMessage* release_stamina_capacity_message();
  ::protos::StaminaCapacityMessage* mutable_stamina_capacity_message();
  void set_allocated_stamina_capacity_message(::protos::StaminaCapacityMessage* value);
  void unsafe_arena_set_allocated_stamina_capacity_message(::protos::StaminaCapacityMessage* value);
  ::protos::StaminaCapacityMessage* unsafe_arena_release_stamina_capacity_message();

  private:
  const ::protos::StaminaCapacityMessage& _internal_stamina_capacity_message() const;
  ::protos::StaminaCapacityMessage* _internal_mutable_stamina_capacity_message();

  public:
  // .protos.DribbleMessage dribble_message = 14;
  bool has_dribble_message() const;
  private:
  bool _internal_has_dribble_message() const;

  public:
  void clear_dribble_message() ;
  const ::protos::DribbleMessage& dribble_message() const;
  PROTOBUF_NODISCARD ::protos::DribbleMessage* release_dribble_message();
  ::protos::DribbleMessage* mutable_dribble_message();
  void set_allocated_dribble_message(::protos::DribbleMessage* value);
  void unsafe_arena_set_allocated_dribble_message(::protos::DribbleMessage* value);
  ::protos::DribbleMessage* unsafe_arena_release_dribble_message();

  private:
  const ::protos::DribbleMessage& _internal_dribble_message() const;
  ::protos::DribbleMessage* _internal_mutable_dribble_message();

  public:
  // .protos.BallGoalieMessage ball_goalie_message = 15;
  bool has_ball_goalie_message() const;
  private:
  bool _internal_has_ball_goalie_message() const;

  public:
  void clear_ball_goalie_message() ;
  const ::protos::BallGoalieMessage& ball_goalie_message() const;
  PROTOBUF_NODISCARD ::protos::BallGoalieMessage* release_ball_goalie_message();
  ::protos::BallGoalieMessage* mutable_ball_goalie_message();
  void set_allocated_ball_goalie_message(::protos::BallGoalieMessage* value);
  void unsafe_arena_set_allocated_ball_goalie_message(::protos::BallGoalieMessage* value);
  ::protos::BallGoalieMessage* unsafe_arena_release_ball_goalie_message();

  private:
  const ::protos::BallGoalieMessage& _internal_ball_goalie_message() const;
  ::protos::BallGoalieMessage* _internal_mutable_ball_goalie_message();

  public:
  // .protos.OnePlayerMessage one_player_message = 16;
  bool has_one_player_message() const;
  private:
  bool _internal_has_one_player_message() const;

  public:
  void clear_one_player_message() ;
  const ::protos::OnePlayerMessage& one_player_message() const;
  PROTOBUF_NODISCARD ::protos::OnePlayerMessage* release_one_player_message();
  ::protos::OnePlayerMessage* mutable_one_player_message();
  void set_allocated_one_player_message(::protos::OnePlayerMessage* value);
  void unsafe_arena_set_allocated_one_player_message(::protos::OnePlayerMessage* value);
  ::protos::OnePlayerMessage* unsafe_arena_release_one_player_message();

  private:
  const ::protos::OnePlayerMessage& _internal_one_player_message() const;
  ::protos::OnePlayerMessage* _internal_mutable_one_player_message();

  public:
  // .protos.TwoPlayerMessage two_player_message = 17;
  bool has_two_player_message() const;
  private:
  bool _internal_has_two_player_message() const;

  public:
  void clear_two_player_message() ;
  const ::protos::TwoPlayerMessage& two_player_message() const;
  PROTOBUF_NODISCARD ::protos::TwoPlayerMessage* release_two_player_message();
  ::protos::TwoPlayerMessage* mutable_two_player_message();
  void set_allocated_two_player_message(::protos::TwoPlayerMessage* value);
  void unsafe_arena_set_allocated_two_player_message(::protos::TwoPlayerMessage* value);
  ::protos::TwoPlayerMessage* unsafe_arena_release_two_player_message();

  private:
  const ::protos::TwoPlayerMessage& _internal_two_player_message() const;
  ::protos::TwoPlayerMessage* _internal_mutable_two_player_message();

  public:
  // .protos.ThreePlayerMessage three_player_message = 18;
  bool has_three_player_message() const;
  private:
  bool _internal_has_three_player_message() const;

  public:
  void clear_three_player_message() ;
  const ::protos::ThreePlayerMessage& three_player_message() const;
  PROTOBUF_NODISCARD ::protos::ThreePlayerMessage* release_three_player_message();
  ::protos::ThreePlayerMessage* mutable_three_player_message();
  void set_allocated_three_player_message(::protos::ThreePlayerMessage* value);
  void unsafe_arena_set_allocated_three_player_message(::protos::ThreePlayerMessage* value);
  ::protos::ThreePlayerMessage* unsafe_arena_release_three_player_message();

  private:
  const ::protos::ThreePlayerMessage& _internal_three_player_message() const;
  ::protos::ThreePlayerMessage* _internal_mutable_three_player_message();

  public:
  // .protos.SelfMessage self_message = 19;
  bool has_self_message() const;
  private:
  bool _internal_has_self_message() const;

  public:
  void clear_self_message() ;
  const ::protos::SelfMessage& self_message() const;
  PROTOBUF_NODISCARD ::protos::SelfMessage* release_self_message();
  ::protos::SelfMessage* mutable_self_message();
  void set_allocated_self_message(::protos::SelfMessage* value);
  void unsafe_arena_set_allocated_self_message(::protos::SelfMessage* value);
  ::protos::SelfMessage* unsafe_arena_release_self_message();

  private:
  const ::protos::SelfMessage& _internal_self_message() const;
  ::protos::SelfMessage* _internal_mutable_self_message();

  public:
  // .protos.TeammateMessage teammate_message = 20;
  bool has_teammate_message() const;
  private:
  bool _internal_has_teammate_message() const;

  public:
  void clear_teammate_message() ;
  const ::protos::TeammateMessage& teammate_message() const;
  PROTOBUF_NODISCARD ::protos::TeammateMessage* release_teammate_message();
  ::protos::TeammateMessage* mutable_teammate_message();
  void set_allocated_teammate_message(::protos::TeammateMessage* value);
  void unsafe_arena_set_allocated_teammate_message(::protos::TeammateMessage* value);
  ::protos::TeammateMessage* unsafe_arena_release_teammate_message();

  private:
  const ::protos::TeammateMessage& _internal_teammate_message() const;
  ::protos::TeammateMessage* _internal_mutable_teammate_message();

  public:
  // .protos.OpponentMessage opponent_message = 21;
  bool has_opponent_message() const;
  private:
  bool _internal_has_opponent_message() const;

  public:
  void clear_opponent_message() ;
  const ::protos::OpponentMessage& opponent_message() const;
  PROTOBUF_NODISCARD ::protos::OpponentMessage* release_opponent_message();
  ::protos::OpponentMessage* mutable_opponent_message();
  void set_allocated_opponent_message(::protos::OpponentMessage* value);
  void unsafe_arena_set_allocated_opponent_message(::protos::OpponentMessage* value);
  ::protos::OpponentMessage* unsafe_arena_release_opponent_message();

  private:
  const ::protos::OpponentMessage& _internal_opponent_message() const;
  ::protos::OpponentMessage* _internal_mutable_opponent_message();

  public:
  // .protos.BallPlayerMessage ball_player_message = 22;
  bool has_ball_player_message() const;
  private:
  bool _internal_has_ball_player_message() const;

  public:
  void clear_ball_player_message() ;
  const ::protos::BallPlayerMessage& ball_player_message() const;
  PROTOBUF_NODISCARD ::protos::BallPlayerMessage* release_ball_player_message();
  ::protos::BallPlayerMessage* mutable_ball_player_message();
  void set_allocated_ball_player_message(::protos::BallPlayerMessage* value);
  void unsafe_arena_set_allocated_ball_player_message(::protos::BallPlayerMessage* value);
  ::protos::BallPlayerMessage* unsafe_arena_release_ball_player_message();

  private:
  const ::protos::BallPlayerMessage& _internal_ball_player_message() const;
  ::protos::BallPlayerMessage* _internal_mutable_ball_player_message();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:protos.Say)
 private:
  class _Internal;
  void set_has_ball_message();
  void set_has_pass_message();
  void set_has_intercept_message();
  void set_has_goalie_message();
  void set_has_goalie_and_player_message();
  void set_has_offside_line_message();
  void set_has_defense_line_message();
  void set_has_wait_request_message();
  void set_has_setplay_message();
  void set_has_pass_request_message();
  void set_has_stamina_message();
  void set_has_recovery_message();
  void set_has_stamina_capacity_message();
  void set_has_dribble_message();
  void set_has_ball_goalie_message();
  void set_has_one_player_message();
  void set_has_two_player_message();
  void set_has_three_player_message();
  void set_has_self_message();
  void set_has_teammate_message();
  void set_has_opponent_message();
  void set_has_ball_player_message();

  inline bool has_message() const;
  inline void clear_has_message();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 22, 22,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::protos::BallMessage* ball_message_;
      ::protos::PassMessage* pass_message_;
      ::protos::InterceptMessage* intercept_message_;
      ::protos::GoalieMessage* goalie_message_;
      ::protos::GoalieAndPlayerMessage* goalie_and_player_message_;
      ::protos::OffsideLineMessage* offside_line_message_;
      ::protos::DefenseLineMessage* defense_line_message_;
      ::protos::WaitRequestMessage* wait_request_message_;
      ::protos::SetplayMessage* setplay_message_;
      ::protos::PassRequestMessage* pass_request_message_;
      ::protos::StaminaMessage* stamina_message_;
      ::protos::RecoveryMessage* recovery_message_;
      ::protos::StaminaCapacityMessage* stamina_capacity_message_;
      ::protos::DribbleMessage* dribble_message_;
      ::protos::BallGoalieMessage* ball_goalie_message_;
      ::protos::OnePlayerMessage* one_player_message_;
      ::protos::TwoPlayerMessage* two_player_message_;
      ::protos::ThreePlayerMessage* three_player_message_;
      ::protos::SelfMessage* self_message_;
      ::protos::TeammateMessage* teammate_message_;
      ::protos::OpponentMessage* opponent_message_;
      ::protos::BallPlayerMessage* ball_player_message_;
    } message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class Log final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.Log) */ {
 public:
  inline Log() : Log(nullptr) {}
  ~Log() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Log(::google::protobuf::internal::ConstantInitialized);

  inline Log(const Log& from)
      : Log(nullptr, from) {}
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  inline Log& operator=(Log&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Log& default_instance() {
    return *internal_default_instance();
  }
  enum LogCase {
    kAddText = 1,
    kAddPoint = 2,
    kAddLine = 3,
    kAddArc = 4,
    kAddCircle = 5,
    kAddTriangle = 6,
    kAddRectangle = 7,
    kAddSector = 8,
    kAddMessage = 9,
    LOG_NOT_SET = 0,
  };

  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }
  inline void Swap(Log* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Log* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Log* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Log& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Log& from) {
    Log::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Log* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.Log";
  }
  protected:
  explicit Log(::google::protobuf::Arena* arena);
  Log(::google::protobuf::Arena* arena, const Log& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddTextFieldNumber = 1,
    kAddPointFieldNumber = 2,
    kAddLineFieldNumber = 3,
    kAddArcFieldNumber = 4,
    kAddCircleFieldNumber = 5,
    kAddTriangleFieldNumber = 6,
    kAddRectangleFieldNumber = 7,
    kAddSectorFieldNumber = 8,
    kAddMessageFieldNumber = 9,
  };
  // .protos.AddText add_text = 1;
  bool has_add_text() const;
  private:
  bool _internal_has_add_text() const;

  public:
  void clear_add_text() ;
  const ::protos::AddText& add_text() const;
  PROTOBUF_NODISCARD ::protos::AddText* release_add_text();
  ::protos::AddText* mutable_add_text();
  void set_allocated_add_text(::protos::AddText* value);
  void unsafe_arena_set_allocated_add_text(::protos::AddText* value);
  ::protos::AddText* unsafe_arena_release_add_text();

  private:
  const ::protos::AddText& _internal_add_text() const;
  ::protos::AddText* _internal_mutable_add_text();

  public:
  // .protos.AddPoint add_point = 2;
  bool has_add_point() const;
  private:
  bool _internal_has_add_point() const;

  public:
  void clear_add_point() ;
  const ::protos::AddPoint& add_point() const;
  PROTOBUF_NODISCARD ::protos::AddPoint* release_add_point();
  ::protos::AddPoint* mutable_add_point();
  void set_allocated_add_point(::protos::AddPoint* value);
  void unsafe_arena_set_allocated_add_point(::protos::AddPoint* value);
  ::protos::AddPoint* unsafe_arena_release_add_point();

  private:
  const ::protos::AddPoint& _internal_add_point() const;
  ::protos::AddPoint* _internal_mutable_add_point();

  public:
  // .protos.AddLine add_line = 3;
  bool has_add_line() const;
  private:
  bool _internal_has_add_line() const;

  public:
  void clear_add_line() ;
  const ::protos::AddLine& add_line() const;
  PROTOBUF_NODISCARD ::protos::AddLine* release_add_line();
  ::protos::AddLine* mutable_add_line();
  void set_allocated_add_line(::protos::AddLine* value);
  void unsafe_arena_set_allocated_add_line(::protos::AddLine* value);
  ::protos::AddLine* unsafe_arena_release_add_line();

  private:
  const ::protos::AddLine& _internal_add_line() const;
  ::protos::AddLine* _internal_mutable_add_line();

  public:
  // .protos.AddArc add_arc = 4;
  bool has_add_arc() const;
  private:
  bool _internal_has_add_arc() const;

  public:
  void clear_add_arc() ;
  const ::protos::AddArc& add_arc() const;
  PROTOBUF_NODISCARD ::protos::AddArc* release_add_arc();
  ::protos::AddArc* mutable_add_arc();
  void set_allocated_add_arc(::protos::AddArc* value);
  void unsafe_arena_set_allocated_add_arc(::protos::AddArc* value);
  ::protos::AddArc* unsafe_arena_release_add_arc();

  private:
  const ::protos::AddArc& _internal_add_arc() const;
  ::protos::AddArc* _internal_mutable_add_arc();

  public:
  // .protos.AddCircle add_circle = 5;
  bool has_add_circle() const;
  private:
  bool _internal_has_add_circle() const;

  public:
  void clear_add_circle() ;
  const ::protos::AddCircle& add_circle() const;
  PROTOBUF_NODISCARD ::protos::AddCircle* release_add_circle();
  ::protos::AddCircle* mutable_add_circle();
  void set_allocated_add_circle(::protos::AddCircle* value);
  void unsafe_arena_set_allocated_add_circle(::protos::AddCircle* value);
  ::protos::AddCircle* unsafe_arena_release_add_circle();

  private:
  const ::protos::AddCircle& _internal_add_circle() const;
  ::protos::AddCircle* _internal_mutable_add_circle();

  public:
  // .protos.AddTriangle add_triangle = 6;
  bool has_add_triangle() const;
  private:
  bool _internal_has_add_triangle() const;

  public:
  void clear_add_triangle() ;
  const ::protos::AddTriangle& add_triangle() const;
  PROTOBUF_NODISCARD ::protos::AddTriangle* release_add_triangle();
  ::protos::AddTriangle* mutable_add_triangle();
  void set_allocated_add_triangle(::protos::AddTriangle* value);
  void unsafe_arena_set_allocated_add_triangle(::protos::AddTriangle* value);
  ::protos::AddTriangle* unsafe_arena_release_add_triangle();

  private:
  const ::protos::AddTriangle& _internal_add_triangle() const;
  ::protos::AddTriangle* _internal_mutable_add_triangle();

  public:
  // .protos.AddRectangle add_rectangle = 7;
  bool has_add_rectangle() const;
  private:
  bool _internal_has_add_rectangle() const;

  public:
  void clear_add_rectangle() ;
  const ::protos::AddRectangle& add_rectangle() const;
  PROTOBUF_NODISCARD ::protos::AddRectangle* release_add_rectangle();
  ::protos::AddRectangle* mutable_add_rectangle();
  void set_allocated_add_rectangle(::protos::AddRectangle* value);
  void unsafe_arena_set_allocated_add_rectangle(::protos::AddRectangle* value);
  ::protos::AddRectangle* unsafe_arena_release_add_rectangle();

  private:
  const ::protos::AddRectangle& _internal_add_rectangle() const;
  ::protos::AddRectangle* _internal_mutable_add_rectangle();

  public:
  // .protos.AddSector add_sector = 8;
  bool has_add_sector() const;
  private:
  bool _internal_has_add_sector() const;

  public:
  void clear_add_sector() ;
  const ::protos::AddSector& add_sector() const;
  PROTOBUF_NODISCARD ::protos::AddSector* release_add_sector();
  ::protos::AddSector* mutable_add_sector();
  void set_allocated_add_sector(::protos::AddSector* value);
  void unsafe_arena_set_allocated_add_sector(::protos::AddSector* value);
  ::protos::AddSector* unsafe_arena_release_add_sector();

  private:
  const ::protos::AddSector& _internal_add_sector() const;
  ::protos::AddSector* _internal_mutable_add_sector();

  public:
  // .protos.AddMessage add_message = 9;
  bool has_add_message() const;
  private:
  bool _internal_has_add_message() const;

  public:
  void clear_add_message() ;
  const ::protos::AddMessage& add_message() const;
  PROTOBUF_NODISCARD ::protos::AddMessage* release_add_message();
  ::protos::AddMessage* mutable_add_message();
  void set_allocated_add_message(::protos::AddMessage* value);
  void unsafe_arena_set_allocated_add_message(::protos::AddMessage* value);
  ::protos::AddMessage* unsafe_arena_release_add_message();

  private:
  const ::protos::AddMessage& _internal_add_message() const;
  ::protos::AddMessage* _internal_mutable_add_message();

  public:
  void clear_log();
  LogCase log_case() const;
  // @@protoc_insertion_point(class_scope:protos.Log)
 private:
  class _Internal;
  void set_has_add_text();
  void set_has_add_point();
  void set_has_add_line();
  void set_has_add_arc();
  void set_has_add_circle();
  void set_has_add_triangle();
  void set_has_add_rectangle();
  void set_has_add_sector();
  void set_has_add_message();

  inline bool has_log() const;
  inline void clear_has_log();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 9, 9,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union LogUnion {
      constexpr LogUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::protos::AddText* add_text_;
      ::protos::AddPoint* add_point_;
      ::protos::AddLine* add_line_;
      ::protos::AddArc* add_arc_;
      ::protos::AddCircle* add_circle_;
      ::protos::AddTriangle* add_triangle_;
      ::protos::AddRectangle* add_rectangle_;
      ::protos::AddSector* add_sector_;
      ::protos::AddMessage* add_message_;
    } log_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class InterceptTable final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.InterceptTable) */ {
 public:
  inline InterceptTable() : InterceptTable(nullptr) {}
  ~InterceptTable() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterceptTable(::google::protobuf::internal::ConstantInitialized);

  inline InterceptTable(const InterceptTable& from)
      : InterceptTable(nullptr, from) {}
  InterceptTable(InterceptTable&& from) noexcept
    : InterceptTable() {
    *this = ::std::move(from);
  }

  inline InterceptTable& operator=(const InterceptTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterceptTable& operator=(InterceptTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterceptTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterceptTable* internal_default_instance() {
    return reinterpret_cast<const InterceptTable*>(
               &_InterceptTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InterceptTable& a, InterceptTable& b) {
    a.Swap(&b);
  }
  inline void Swap(InterceptTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterceptTable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterceptTable* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterceptTable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InterceptTable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InterceptTable& from) {
    InterceptTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InterceptTable* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.InterceptTable";
  }
  protected:
  explicit InterceptTable(::google::protobuf::Arena* arena);
  InterceptTable(::google::protobuf::Arena* arena, const InterceptTable& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelfInterceptInfoFieldNumber = 10,
    kSelfReachStepsFieldNumber = 1,
    kFirstTeammateReachStepsFieldNumber = 2,
    kSecondTeammateReachStepsFieldNumber = 3,
    kFirstOpponentReachStepsFieldNumber = 4,
    kSecondOpponentReachStepsFieldNumber = 5,
    kFirstTeammateIdFieldNumber = 6,
    kSecondTeammateIdFieldNumber = 7,
    kFirstOpponentIdFieldNumber = 8,
    kSecondOpponentIdFieldNumber = 9,
  };
  // repeated .protos.InterceptInfo self_intercept_info = 10;
  int self_intercept_info_size() const;
  private:
  int _internal_self_intercept_info_size() const;

  public:
  void clear_self_intercept_info() ;
  ::protos::InterceptInfo* mutable_self_intercept_info(int index);
  ::google::protobuf::RepeatedPtrField< ::protos::InterceptInfo >*
      mutable_self_intercept_info();
  private:
  const ::google::protobuf::RepeatedPtrField<::protos::InterceptInfo>& _internal_self_intercept_info() const;
  ::google::protobuf::RepeatedPtrField<::protos::InterceptInfo>* _internal_mutable_self_intercept_info();
  public:
  const ::protos::InterceptInfo& self_intercept_info(int index) const;
  ::protos::InterceptInfo* add_self_intercept_info();
  const ::google::protobuf::RepeatedPtrField< ::protos::InterceptInfo >&
      self_intercept_info() const;
  // int32 self_reach_steps = 1;
  void clear_self_reach_steps() ;
  ::int32_t self_reach_steps() const;
  void set_self_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_self_reach_steps() const;
  void _internal_set_self_reach_steps(::int32_t value);

  public:
  // int32 first_teammate_reach_steps = 2;
  void clear_first_teammate_reach_steps() ;
  ::int32_t first_teammate_reach_steps() const;
  void set_first_teammate_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_first_teammate_reach_steps() const;
  void _internal_set_first_teammate_reach_steps(::int32_t value);

  public:
  // int32 second_teammate_reach_steps = 3;
  void clear_second_teammate_reach_steps() ;
  ::int32_t second_teammate_reach_steps() const;
  void set_second_teammate_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_second_teammate_reach_steps() const;
  void _internal_set_second_teammate_reach_steps(::int32_t value);

  public:
  // int32 first_opponent_reach_steps = 4;
  void clear_first_opponent_reach_steps() ;
  ::int32_t first_opponent_reach_steps() const;
  void set_first_opponent_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_first_opponent_reach_steps() const;
  void _internal_set_first_opponent_reach_steps(::int32_t value);

  public:
  // int32 second_opponent_reach_steps = 5;
  void clear_second_opponent_reach_steps() ;
  ::int32_t second_opponent_reach_steps() const;
  void set_second_opponent_reach_steps(::int32_t value);

  private:
  ::int32_t _internal_second_opponent_reach_steps() const;
  void _internal_set_second_opponent_reach_steps(::int32_t value);

  public:
  // int32 first_teammate_id = 6;
  void clear_first_teammate_id() ;
  ::int32_t first_teammate_id() const;
  void set_first_teammate_id(::int32_t value);

  private:
  ::int32_t _internal_first_teammate_id() const;
  void _internal_set_first_teammate_id(::int32_t value);

  public:
  // int32 second_teammate_id = 7;
  void clear_second_teammate_id() ;
  ::int32_t second_teammate_id() const;
  void set_second_teammate_id(::int32_t value);

  private:
  ::int32_t _internal_second_teammate_id() const;
  void _internal_set_second_teammate_id(::int32_t value);

  public:
  // int32 first_opponent_id = 8;
  void clear_first_opponent_id() ;
  ::int32_t first_opponent_id() const;
  void set_first_opponent_id(::int32_t value);

  private:
  ::int32_t _internal_first_opponent_id() const;
  void _internal_set_first_opponent_id(::int32_t value);

  public:
  // int32 second_opponent_id = 9;
  void clear_second_opponent_id() ;
  ::int32_t second_opponent_id() const;
  void set_second_opponent_id(::int32_t value);

  private:
  ::int32_t _internal_second_opponent_id() const;
  void _internal_set_second_opponent_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.InterceptTable)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::protos::InterceptInfo > self_intercept_info_;
    ::int32_t self_reach_steps_;
    ::int32_t first_teammate_reach_steps_;
    ::int32_t second_teammate_reach_steps_;
    ::int32_t first_opponent_reach_steps_;
    ::int32_t second_opponent_reach_steps_;
    ::int32_t first_teammate_id_;
    ::int32_t second_teammate_id_;
    ::int32_t first_opponent_id_;
    ::int32_t second_opponent_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class CoachActions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.CoachActions) */ {
 public:
  inline CoachActions() : CoachActions(nullptr) {}
  ~CoachActions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CoachActions(::google::protobuf::internal::ConstantInitialized);

  inline CoachActions(const CoachActions& from)
      : CoachActions(nullptr, from) {}
  CoachActions(CoachActions&& from) noexcept
    : CoachActions() {
    *this = ::std::move(from);
  }

  inline CoachActions& operator=(const CoachActions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoachActions& operator=(CoachActions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoachActions& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoachActions* internal_default_instance() {
    return reinterpret_cast<const CoachActions*>(
               &_CoachActions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(CoachActions& a, CoachActions& b) {
    a.Swap(&b);
  }
  inline void Swap(CoachActions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoachActions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoachActions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoachActions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CoachActions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CoachActions& from) {
    CoachActions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CoachActions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.CoachActions";
  }
  protected:
  explicit CoachActions(::google::protobuf::Arena* arena);
  CoachActions(::google::protobuf::Arena* arena, const CoachActions& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
  };
  // repeated .protos.CoachAction actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;

  public:
  void clear_actions() ;
  ::protos::CoachAction* mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::protos::CoachAction >*
      mutable_actions();
  private:
  const ::google::protobuf::RepeatedPtrField<::protos::CoachAction>& _internal_actions() const;
  ::google::protobuf::RepeatedPtrField<::protos::CoachAction>* _internal_mutable_actions();
  public:
  const ::protos::CoachAction& actions(int index) const;
  ::protos::CoachAction* add_actions();
  const ::google::protobuf::RepeatedPtrField< ::protos::CoachAction >&
      actions() const;
  // @@protoc_insertion_point(class_scope:protos.CoachActions)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::protos::CoachAction > actions_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class WorldModel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.WorldModel) */ {
 public:
  inline WorldModel() : WorldModel(nullptr) {}
  ~WorldModel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorldModel(::google::protobuf::internal::ConstantInitialized);

  inline WorldModel(const WorldModel& from)
      : WorldModel(nullptr, from) {}
  WorldModel(WorldModel&& from) noexcept
    : WorldModel() {
    *this = ::std::move(from);
  }

  inline WorldModel& operator=(const WorldModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldModel& operator=(WorldModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldModel* internal_default_instance() {
    return reinterpret_cast<const WorldModel*>(
               &_WorldModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(WorldModel& a, WorldModel& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldModel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorldModel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorldModel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorldModel& from) {
    WorldModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorldModel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.WorldModel";
  }
  protected:
  explicit WorldModel(::google::protobuf::Arena* arena);
  WorldModel(::google::protobuf::Arena* arena, const WorldModel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTeammatesFieldNumber = 8,
    kOpponentsFieldNumber = 9,
    kUnknownsFieldNumber = 10,
    kOurPlayersDictFieldNumber = 11,
    kTheirPlayersDictFieldNumber = 12,
    kHeliosHomePositionsFieldNumber = 31,
    kOurTeamNameFieldNumber = 2,
    kTheirTeamNameFieldNumber = 3,
    kInterceptTableFieldNumber = 1,
    kSelfFieldNumber = 6,
    kBallFieldNumber = 7,
    kOurSideFieldNumber = 4,
    kLastSetPlayStartTimeFieldNumber = 5,
    kOurGoalieUniformNumberFieldNumber = 13,
    kTheirGoalieUniformNumberFieldNumber = 14,
    kOffsideLineXFieldNumber = 15,
    kOfsideLineXCountFieldNumber = 16,
    kKickableTeammateIdFieldNumber = 17,
    kKickableOpponentIdFieldNumber = 18,
    kLastKickSideFieldNumber = 19,
    kLastKickerUniformNumberFieldNumber = 20,
    kCycleFieldNumber = 21,
    kGameModeTypeFieldNumber = 22,
    kLeftTeamScoreFieldNumber = 23,
    kRightTeamScoreFieldNumber = 24,
    kStopedCycleFieldNumber = 27,
    kIsOurSetPlayFieldNumber = 25,
    kIsTheirSetPlayFieldNumber = 26,
    kIsPenaltyKickModeFieldNumber = 30,
    kOurTeamScoreFieldNumber = 28,
    kTheirTeamScoreFieldNumber = 29,
  };
  // repeated .protos.Player teammates = 8;
  int teammates_size() const;
  private:
  int _internal_teammates_size() const;

  public:
  void clear_teammates() ;
  ::protos::Player* mutable_teammates(int index);
  ::google::protobuf::RepeatedPtrField< ::protos::Player >*
      mutable_teammates();
  private:
  const ::google::protobuf::RepeatedPtrField<::protos::Player>& _internal_teammates() const;
  ::google::protobuf::RepeatedPtrField<::protos::Player>* _internal_mutable_teammates();
  public:
  const ::protos::Player& teammates(int index) const;
  ::protos::Player* add_teammates();
  const ::google::protobuf::RepeatedPtrField< ::protos::Player >&
      teammates() const;
  // repeated .protos.Player opponents = 9;
  int opponents_size() const;
  private:
  int _internal_opponents_size() const;

  public:
  void clear_opponents() ;
  ::protos::Player* mutable_opponents(int index);
  ::google::protobuf::RepeatedPtrField< ::protos::Player >*
      mutable_opponents();
  private:
  const ::google::protobuf::RepeatedPtrField<::protos::Player>& _internal_opponents() const;
  ::google::protobuf::RepeatedPtrField<::protos::Player>* _internal_mutable_opponents();
  public:
  const ::protos::Player& opponents(int index) const;
  ::protos::Player* add_opponents();
  const ::google::protobuf::RepeatedPtrField< ::protos::Player >&
      opponents() const;
  // repeated .protos.Player unknowns = 10;
  int unknowns_size() const;
  private:
  int _internal_unknowns_size() const;

  public:
  void clear_unknowns() ;
  ::protos::Player* mutable_unknowns(int index);
  ::google::protobuf::RepeatedPtrField< ::protos::Player >*
      mutable_unknowns();
  private:
  const ::google::protobuf::RepeatedPtrField<::protos::Player>& _internal_unknowns() const;
  ::google::protobuf::RepeatedPtrField<::protos::Player>* _internal_mutable_unknowns();
  public:
  const ::protos::Player& unknowns(int index) const;
  ::protos::Player* add_unknowns();
  const ::google::protobuf::RepeatedPtrField< ::protos::Player >&
      unknowns() const;
  // map<int32, .protos.Player> our_players_dict = 11;
  int our_players_dict_size() const;
  private:
  int _internal_our_players_dict_size() const;

  public:
  void clear_our_players_dict() ;
  const ::google::protobuf::Map<::int32_t, ::protos::Player>& our_players_dict() const;
  ::google::protobuf::Map<::int32_t, ::protos::Player>* mutable_our_players_dict();

  private:
  const ::google::protobuf::Map<::int32_t, ::protos::Player>& _internal_our_players_dict() const;
  ::google::protobuf::Map<::int32_t, ::protos::Player>* _internal_mutable_our_players_dict();

  public:
  // map<int32, .protos.Player> their_players_dict = 12;
  int their_players_dict_size() const;
  private:
  int _internal_their_players_dict_size() const;

  public:
  void clear_their_players_dict() ;
  const ::google::protobuf::Map<::int32_t, ::protos::Player>& their_players_dict() const;
  ::google::protobuf::Map<::int32_t, ::protos::Player>* mutable_their_players_dict();

  private:
  const ::google::protobuf::Map<::int32_t, ::protos::Player>& _internal_their_players_dict() const;
  ::google::protobuf::Map<::int32_t, ::protos::Player>* _internal_mutable_their_players_dict();

  public:
  // map<int32, .protos.Vector2D> helios_home_positions = 31;
  int helios_home_positions_size() const;
  private:
  int _internal_helios_home_positions_size() const;

  public:
  void clear_helios_home_positions() ;
  const ::google::protobuf::Map<::int32_t, ::protos::Vector2D>& helios_home_positions() const;
  ::google::protobuf::Map<::int32_t, ::protos::Vector2D>* mutable_helios_home_positions();

  private:
  const ::google::protobuf::Map<::int32_t, ::protos::Vector2D>& _internal_helios_home_positions() const;
  ::google::protobuf::Map<::int32_t, ::protos::Vector2D>* _internal_mutable_helios_home_positions();

  public:
  // string our_team_name = 2;
  void clear_our_team_name() ;
  const std::string& our_team_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_our_team_name(Arg_&& arg, Args_... args);
  std::string* mutable_our_team_name();
  PROTOBUF_NODISCARD std::string* release_our_team_name();
  void set_allocated_our_team_name(std::string* value);

  private:
  const std::string& _internal_our_team_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_our_team_name(
      const std::string& value);
  std::string* _internal_mutable_our_team_name();

  public:
  // string their_team_name = 3;
  void clear_their_team_name() ;
  const std::string& their_team_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_their_team_name(Arg_&& arg, Args_... args);
  std::string* mutable_their_team_name();
  PROTOBUF_NODISCARD std::string* release_their_team_name();
  void set_allocated_their_team_name(std::string* value);

  private:
  const std::string& _internal_their_team_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_their_team_name(
      const std::string& value);
  std::string* _internal_mutable_their_team_name();

  public:
  // .protos.InterceptTable intercept_table = 1;
  bool has_intercept_table() const;
  void clear_intercept_table() ;
  const ::protos::InterceptTable& intercept_table() const;
  PROTOBUF_NODISCARD ::protos::InterceptTable* release_intercept_table();
  ::protos::InterceptTable* mutable_intercept_table();
  void set_allocated_intercept_table(::protos::InterceptTable* value);
  void unsafe_arena_set_allocated_intercept_table(::protos::InterceptTable* value);
  ::protos::InterceptTable* unsafe_arena_release_intercept_table();

  private:
  const ::protos::InterceptTable& _internal_intercept_table() const;
  ::protos::InterceptTable* _internal_mutable_intercept_table();

  public:
  // .protos.Self self = 6;
  bool has_self() const;
  void clear_self() ;
  const ::protos::Self& self() const;
  PROTOBUF_NODISCARD ::protos::Self* release_self();
  ::protos::Self* mutable_self();
  void set_allocated_self(::protos::Self* value);
  void unsafe_arena_set_allocated_self(::protos::Self* value);
  ::protos::Self* unsafe_arena_release_self();

  private:
  const ::protos::Self& _internal_self() const;
  ::protos::Self* _internal_mutable_self();

  public:
  // .protos.Ball ball = 7;
  bool has_ball() const;
  void clear_ball() ;
  const ::protos::Ball& ball() const;
  PROTOBUF_NODISCARD ::protos::Ball* release_ball();
  ::protos::Ball* mutable_ball();
  void set_allocated_ball(::protos::Ball* value);
  void unsafe_arena_set_allocated_ball(::protos::Ball* value);
  ::protos::Ball* unsafe_arena_release_ball();

  private:
  const ::protos::Ball& _internal_ball() const;
  ::protos::Ball* _internal_mutable_ball();

  public:
  // .protos.Side our_side = 4;
  void clear_our_side() ;
  ::protos::Side our_side() const;
  void set_our_side(::protos::Side value);

  private:
  ::protos::Side _internal_our_side() const;
  void _internal_set_our_side(::protos::Side value);

  public:
  // int32 last_set_play_start_time = 5;
  void clear_last_set_play_start_time() ;
  ::int32_t last_set_play_start_time() const;
  void set_last_set_play_start_time(::int32_t value);

  private:
  ::int32_t _internal_last_set_play_start_time() const;
  void _internal_set_last_set_play_start_time(::int32_t value);

  public:
  // int32 our_goalie_uniform_number = 13;
  void clear_our_goalie_uniform_number() ;
  ::int32_t our_goalie_uniform_number() const;
  void set_our_goalie_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_our_goalie_uniform_number() const;
  void _internal_set_our_goalie_uniform_number(::int32_t value);

  public:
  // int32 their_goalie_uniform_number = 14;
  void clear_their_goalie_uniform_number() ;
  ::int32_t their_goalie_uniform_number() const;
  void set_their_goalie_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_their_goalie_uniform_number() const;
  void _internal_set_their_goalie_uniform_number(::int32_t value);

  public:
  // float offside_line_x = 15;
  void clear_offside_line_x() ;
  float offside_line_x() const;
  void set_offside_line_x(float value);

  private:
  float _internal_offside_line_x() const;
  void _internal_set_offside_line_x(float value);

  public:
  // int32 ofside_line_x_count = 16;
  void clear_ofside_line_x_count() ;
  ::int32_t ofside_line_x_count() const;
  void set_ofside_line_x_count(::int32_t value);

  private:
  ::int32_t _internal_ofside_line_x_count() const;
  void _internal_set_ofside_line_x_count(::int32_t value);

  public:
  // int32 kickable_teammate_id = 17;
  void clear_kickable_teammate_id() ;
  ::int32_t kickable_teammate_id() const;
  void set_kickable_teammate_id(::int32_t value);

  private:
  ::int32_t _internal_kickable_teammate_id() const;
  void _internal_set_kickable_teammate_id(::int32_t value);

  public:
  // int32 kickable_opponent_id = 18;
  void clear_kickable_opponent_id() ;
  ::int32_t kickable_opponent_id() const;
  void set_kickable_opponent_id(::int32_t value);

  private:
  ::int32_t _internal_kickable_opponent_id() const;
  void _internal_set_kickable_opponent_id(::int32_t value);

  public:
  // .protos.Side last_kick_side = 19;
  void clear_last_kick_side() ;
  ::protos::Side last_kick_side() const;
  void set_last_kick_side(::protos::Side value);

  private:
  ::protos::Side _internal_last_kick_side() const;
  void _internal_set_last_kick_side(::protos::Side value);

  public:
  // int32 last_kicker_uniform_number = 20;
  void clear_last_kicker_uniform_number() ;
  ::int32_t last_kicker_uniform_number() const;
  void set_last_kicker_uniform_number(::int32_t value);

  private:
  ::int32_t _internal_last_kicker_uniform_number() const;
  void _internal_set_last_kicker_uniform_number(::int32_t value);

  public:
  // int32 cycle = 21;
  void clear_cycle() ;
  ::int32_t cycle() const;
  void set_cycle(::int32_t value);

  private:
  ::int32_t _internal_cycle() const;
  void _internal_set_cycle(::int32_t value);

  public:
  // .protos.GameModeType game_mode_type = 22;
  void clear_game_mode_type() ;
  ::protos::GameModeType game_mode_type() const;
  void set_game_mode_type(::protos::GameModeType value);

  private:
  ::protos::GameModeType _internal_game_mode_type() const;
  void _internal_set_game_mode_type(::protos::GameModeType value);

  public:
  // int32 left_team_score = 23;
  void clear_left_team_score() ;
  ::int32_t left_team_score() const;
  void set_left_team_score(::int32_t value);

  private:
  ::int32_t _internal_left_team_score() const;
  void _internal_set_left_team_score(::int32_t value);

  public:
  // int32 right_team_score = 24;
  void clear_right_team_score() ;
  ::int32_t right_team_score() const;
  void set_right_team_score(::int32_t value);

  private:
  ::int32_t _internal_right_team_score() const;
  void _internal_set_right_team_score(::int32_t value);

  public:
  // int32 stoped_cycle = 27;
  void clear_stoped_cycle() ;
  ::int32_t stoped_cycle() const;
  void set_stoped_cycle(::int32_t value);

  private:
  ::int32_t _internal_stoped_cycle() const;
  void _internal_set_stoped_cycle(::int32_t value);

  public:
  // bool is_our_set_play = 25;
  void clear_is_our_set_play() ;
  bool is_our_set_play() const;
  void set_is_our_set_play(bool value);

  private:
  bool _internal_is_our_set_play() const;
  void _internal_set_is_our_set_play(bool value);

  public:
  // bool is_their_set_play = 26;
  void clear_is_their_set_play() ;
  bool is_their_set_play() const;
  void set_is_their_set_play(bool value);

  private:
  bool _internal_is_their_set_play() const;
  void _internal_set_is_their_set_play(bool value);

  public:
  // bool is_penalty_kick_mode = 30;
  void clear_is_penalty_kick_mode() ;
  bool is_penalty_kick_mode() const;
  void set_is_penalty_kick_mode(bool value);

  private:
  bool _internal_is_penalty_kick_mode() const;
  void _internal_set_is_penalty_kick_mode(bool value);

  public:
  // int32 our_team_score = 28;
  void clear_our_team_score() ;
  ::int32_t our_team_score() const;
  void set_our_team_score(::int32_t value);

  private:
  ::int32_t _internal_our_team_score() const;
  void _internal_set_our_team_score(::int32_t value);

  public:
  // int32 their_team_score = 29;
  void clear_their_team_score() ;
  ::int32_t their_team_score() const;
  void set_their_team_score(::int32_t value);

  private:
  ::int32_t _internal_their_team_score() const;
  void _internal_set_their_team_score(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:protos.WorldModel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 31, 12,
      78, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::protos::Player > teammates_;
    ::google::protobuf::RepeatedPtrField< ::protos::Player > opponents_;
    ::google::protobuf::RepeatedPtrField< ::protos::Player > unknowns_;
    ::google::protobuf::internal::MapField<WorldModel_OurPlayersDictEntry_DoNotUse, ::int32_t, ::protos::Player,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        our_players_dict_;
    ::google::protobuf::internal::MapField<WorldModel_TheirPlayersDictEntry_DoNotUse, ::int32_t, ::protos::Player,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        their_players_dict_;
    ::google::protobuf::internal::MapField<WorldModel_HeliosHomePositionsEntry_DoNotUse, ::int32_t, ::protos::Vector2D,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        helios_home_positions_;
    ::google::protobuf::internal::ArenaStringPtr our_team_name_;
    ::google::protobuf::internal::ArenaStringPtr their_team_name_;
    ::protos::InterceptTable* intercept_table_;
    ::protos::Self* self_;
    ::protos::Ball* ball_;
    int our_side_;
    ::int32_t last_set_play_start_time_;
    ::int32_t our_goalie_uniform_number_;
    ::int32_t their_goalie_uniform_number_;
    float offside_line_x_;
    ::int32_t ofside_line_x_count_;
    ::int32_t kickable_teammate_id_;
    ::int32_t kickable_opponent_id_;
    int last_kick_side_;
    ::int32_t last_kicker_uniform_number_;
    ::int32_t cycle_;
    int game_mode_type_;
    ::int32_t left_team_score_;
    ::int32_t right_team_score_;
    ::int32_t stoped_cycle_;
    bool is_our_set_play_;
    bool is_their_set_play_;
    bool is_penalty_kick_mode_;
    ::int32_t our_team_score_;
    ::int32_t their_team_score_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class TrainerActions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.TrainerActions) */ {
 public:
  inline TrainerActions() : TrainerActions(nullptr) {}
  ~TrainerActions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrainerActions(::google::protobuf::internal::ConstantInitialized);

  inline TrainerActions(const TrainerActions& from)
      : TrainerActions(nullptr, from) {}
  TrainerActions(TrainerActions&& from) noexcept
    : TrainerActions() {
    *this = ::std::move(from);
  }

  inline TrainerActions& operator=(const TrainerActions& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainerActions& operator=(TrainerActions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrainerActions& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainerActions* internal_default_instance() {
    return reinterpret_cast<const TrainerActions*>(
               &_TrainerActions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(TrainerActions& a, TrainerActions& b) {
    a.Swap(&b);
  }
  inline void Swap(TrainerActions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainerActions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainerActions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainerActions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrainerActions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrainerActions& from) {
    TrainerActions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrainerActions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.TrainerActions";
  }
  protected:
  explicit TrainerActions(::google::protobuf::Arena* arena);
  TrainerActions(::google::protobuf::Arena* arena, const TrainerActions& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
  };
  // repeated .protos.TrainerAction actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;

  public:
  void clear_actions() ;
  ::protos::TrainerAction* mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::protos::TrainerAction >*
      mutable_actions();
  private:
  const ::google::protobuf::RepeatedPtrField<::protos::TrainerAction>& _internal_actions() const;
  ::google::protobuf::RepeatedPtrField<::protos::TrainerAction>* _internal_mutable_actions();
  public:
  const ::protos::TrainerAction& actions(int index) const;
  ::protos::TrainerAction* add_actions();
  const ::google::protobuf::RepeatedPtrField< ::protos::TrainerAction >&
      actions() const;
  // @@protoc_insertion_point(class_scope:protos.TrainerActions)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::protos::TrainerAction > actions_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PlayerAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.PlayerAction) */ {
 public:
  inline PlayerAction() : PlayerAction(nullptr) {}
  ~PlayerAction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerAction(::google::protobuf::internal::ConstantInitialized);

  inline PlayerAction(const PlayerAction& from)
      : PlayerAction(nullptr, from) {}
  PlayerAction(PlayerAction&& from) noexcept
    : PlayerAction() {
    *this = ::std::move(from);
  }

  inline PlayerAction& operator=(const PlayerAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerAction& operator=(PlayerAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerAction& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kDash = 1,
    kTurn = 2,
    kKick = 3,
    kTackle = 4,
    kCatch = 5,
    kMove = 6,
    kTurnNeck = 7,
    kChangeView = 8,
    kSay = 9,
    kPointTo = 10,
    kPointToOf = 11,
    kAttentionTo = 12,
    kAttentionToOf = 13,
    kLog = 14,
    kDebugClient = 15,
    kBodyGoToPoint = 16,
    kBodySmartKick = 17,
    kBhvBeforeKickOff = 18,
    kBhvBodyNeckToBall = 19,
    kBhvBodyNeckToPoint = 20,
    kBhvEmergency = 21,
    kBhvGoToPointLookBall = 22,
    kBhvNeckBodyToBall = 23,
    kBhvNeckBodyToPoint = 24,
    kBhvScanField = 25,
    kBodyAdvanceBall = 26,
    kBodyClearBall = 27,
    kBodyDribble = 28,
    kBodyGoToPointDodge = 29,
    kBodyHoldBall = 30,
    kBodyIntercept = 31,
    kBodyKickOneStep = 32,
    kBodyStopBall = 33,
    kBodyStopDash = 34,
    kBodyTackleToPoint = 35,
    kBodyTurnToAngle = 36,
    kBodyTurnToBall = 37,
    kBodyTurnToPoint = 38,
    kFocusMoveToPoint = 39,
    kFocusReset = 40,
    kNeckScanField = 41,
    kNeckScanPlayers = 42,
    kNeckTurnToBallAndPlayer = 43,
    kNeckTurnToBallOrScan = 44,
    kNeckTurnToBall = 45,
    kNeckTurnToGoalieOrScan = 46,
    kNeckTurnToLowConfTeammate = 47,
    kNeckTurnToPlayerOrScan = 48,
    kNeckTurnToPoint = 49,
    kNeckTurnToRelative = 50,
    kViewChangeWidth = 51,
    kViewNormal = 52,
    kViewSynch = 53,
    kViewWide = 54,
    kHeliosGoalie = 55,
    kHeliosGoalieMove = 56,
    kHeliosGoalieKick = 57,
    kHeliosShoot = 58,
    kHeliosChainAction = 59,
    kHeliosBasicOffensive = 60,
    kHeliosBasicMove = 61,
    kHeliosSetPlay = 62,
    kHeliosPenalty = 63,
    kHeliosCommunication = 64,
    ACTION_NOT_SET = 0,
  };

  static inline const PlayerAction* internal_default_instance() {
    return reinterpret_cast<const PlayerAction*>(
               &_PlayerAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(PlayerAction& a, PlayerAction& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerAction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerAction& from) {
    PlayerAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerAction* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PlayerAction";
  }
  protected:
  explicit PlayerAction(::google::protobuf::Arena* arena);
  PlayerAction(::google::protobuf::Arena* arena, const PlayerAction& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDashFieldNumber = 1,
    kTurnFieldNumber = 2,
    kKickFieldNumber = 3,
    kTackleFieldNumber = 4,
    kCatchFieldNumber = 5,
    kMoveFieldNumber = 6,
    kTurnNeckFieldNumber = 7,
    kChangeViewFieldNumber = 8,
    kSayFieldNumber = 9,
    kPointToFieldNumber = 10,
    kPointToOfFieldNumber = 11,
    kAttentionToFieldNumber = 12,
    kAttentionToOfFieldNumber = 13,
    kLogFieldNumber = 14,
    kDebugClientFieldNumber = 15,
    kBodyGoToPointFieldNumber = 16,
    kBodySmartKickFieldNumber = 17,
    kBhvBeforeKickOffFieldNumber = 18,
    kBhvBodyNeckToBallFieldNumber = 19,
    kBhvBodyNeckToPointFieldNumber = 20,
    kBhvEmergencyFieldNumber = 21,
    kBhvGoToPointLookBallFieldNumber = 22,
    kBhvNeckBodyToBallFieldNumber = 23,
    kBhvNeckBodyToPointFieldNumber = 24,
    kBhvScanFieldFieldNumber = 25,
    kBodyAdvanceBallFieldNumber = 26,
    kBodyClearBallFieldNumber = 27,
    kBodyDribbleFieldNumber = 28,
    kBodyGoToPointDodgeFieldNumber = 29,
    kBodyHoldBallFieldNumber = 30,
    kBodyInterceptFieldNumber = 31,
    kBodyKickOneStepFieldNumber = 32,
    kBodyStopBallFieldNumber = 33,
    kBodyStopDashFieldNumber = 34,
    kBodyTackleToPointFieldNumber = 35,
    kBodyTurnToAngleFieldNumber = 36,
    kBodyTurnToBallFieldNumber = 37,
    kBodyTurnToPointFieldNumber = 38,
    kFocusMoveToPointFieldNumber = 39,
    kFocusResetFieldNumber = 40,
    kNeckScanFieldFieldNumber = 41,
    kNeckScanPlayersFieldNumber = 42,
    kNeckTurnToBallAndPlayerFieldNumber = 43,
    kNeckTurnToBallOrScanFieldNumber = 44,
    kNeckTurnToBallFieldNumber = 45,
    kNeckTurnToGoalieOrScanFieldNumber = 46,
    kNeckTurnToLowConfTeammateFieldNumber = 47,
    kNeckTurnToPlayerOrScanFieldNumber = 48,
    kNeckTurnToPointFieldNumber = 49,
    kNeckTurnToRelativeFieldNumber = 50,
    kViewChangeWidthFieldNumber = 51,
    kViewNormalFieldNumber = 52,
    kViewSynchFieldNumber = 53,
    kViewWideFieldNumber = 54,
    kHeliosGoalieFieldNumber = 55,
    kHeliosGoalieMoveFieldNumber = 56,
    kHeliosGoalieKickFieldNumber = 57,
    kHeliosShootFieldNumber = 58,
    kHeliosChainActionFieldNumber = 59,
    kHeliosBasicOffensiveFieldNumber = 60,
    kHeliosBasicMoveFieldNumber = 61,
    kHeliosSetPlayFieldNumber = 62,
    kHeliosPenaltyFieldNumber = 63,
    kHeliosCommunicationFieldNumber = 64,
  };
  // .protos.Dash dash = 1;
  bool has_dash() const;
  private:
  bool _internal_has_dash() const;

  public:
  void clear_dash() ;
  const ::protos::Dash& dash() const;
  PROTOBUF_NODISCARD ::protos::Dash* release_dash();
  ::protos::Dash* mutable_dash();
  void set_allocated_dash(::protos::Dash* value);
  void unsafe_arena_set_allocated_dash(::protos::Dash* value);
  ::protos::Dash* unsafe_arena_release_dash();

  private:
  const ::protos::Dash& _internal_dash() const;
  ::protos::Dash* _internal_mutable_dash();

  public:
  // .protos.Turn turn = 2;
  bool has_turn() const;
  private:
  bool _internal_has_turn() const;

  public:
  void clear_turn() ;
  const ::protos::Turn& turn() const;
  PROTOBUF_NODISCARD ::protos::Turn* release_turn();
  ::protos::Turn* mutable_turn();
  void set_allocated_turn(::protos::Turn* value);
  void unsafe_arena_set_allocated_turn(::protos::Turn* value);
  ::protos::Turn* unsafe_arena_release_turn();

  private:
  const ::protos::Turn& _internal_turn() const;
  ::protos::Turn* _internal_mutable_turn();

  public:
  // .protos.Kick kick = 3;
  bool has_kick() const;
  private:
  bool _internal_has_kick() const;

  public:
  void clear_kick() ;
  const ::protos::Kick& kick() const;
  PROTOBUF_NODISCARD ::protos::Kick* release_kick();
  ::protos::Kick* mutable_kick();
  void set_allocated_kick(::protos::Kick* value);
  void unsafe_arena_set_allocated_kick(::protos::Kick* value);
  ::protos::Kick* unsafe_arena_release_kick();

  private:
  const ::protos::Kick& _internal_kick() const;
  ::protos::Kick* _internal_mutable_kick();

  public:
  // .protos.Tackle tackle = 4;
  bool has_tackle() const;
  private:
  bool _internal_has_tackle() const;

  public:
  void clear_tackle() ;
  const ::protos::Tackle& tackle() const;
  PROTOBUF_NODISCARD ::protos::Tackle* release_tackle();
  ::protos::Tackle* mutable_tackle();
  void set_allocated_tackle(::protos::Tackle* value);
  void unsafe_arena_set_allocated_tackle(::protos::Tackle* value);
  ::protos::Tackle* unsafe_arena_release_tackle();

  private:
  const ::protos::Tackle& _internal_tackle() const;
  ::protos::Tackle* _internal_mutable_tackle();

  public:
  // .protos.Catch catch = 5;
  bool has_catch_() const;
  private:
  bool _internal_has_catch_() const;

  public:
  void clear_catch_() ;
  const ::protos::Catch& catch_() const;
  PROTOBUF_NODISCARD ::protos::Catch* release_catch_();
  ::protos::Catch* mutable_catch_();
  void set_allocated_catch_(::protos::Catch* value);
  void unsafe_arena_set_allocated_catch_(::protos::Catch* value);
  ::protos::Catch* unsafe_arena_release_catch_();

  private:
  const ::protos::Catch& _internal_catch_() const;
  ::protos::Catch* _internal_mutable_catch_();

  public:
  // .protos.Move move = 6;
  bool has_move() const;
  private:
  bool _internal_has_move() const;

  public:
  void clear_move() ;
  const ::protos::Move& move() const;
  PROTOBUF_NODISCARD ::protos::Move* release_move();
  ::protos::Move* mutable_move();
  void set_allocated_move(::protos::Move* value);
  void unsafe_arena_set_allocated_move(::protos::Move* value);
  ::protos::Move* unsafe_arena_release_move();

  private:
  const ::protos::Move& _internal_move() const;
  ::protos::Move* _internal_mutable_move();

  public:
  // .protos.TurnNeck turn_neck = 7;
  bool has_turn_neck() const;
  private:
  bool _internal_has_turn_neck() const;

  public:
  void clear_turn_neck() ;
  const ::protos::TurnNeck& turn_neck() const;
  PROTOBUF_NODISCARD ::protos::TurnNeck* release_turn_neck();
  ::protos::TurnNeck* mutable_turn_neck();
  void set_allocated_turn_neck(::protos::TurnNeck* value);
  void unsafe_arena_set_allocated_turn_neck(::protos::TurnNeck* value);
  ::protos::TurnNeck* unsafe_arena_release_turn_neck();

  private:
  const ::protos::TurnNeck& _internal_turn_neck() const;
  ::protos::TurnNeck* _internal_mutable_turn_neck();

  public:
  // .protos.ChangeView change_view = 8;
  bool has_change_view() const;
  private:
  bool _internal_has_change_view() const;

  public:
  void clear_change_view() ;
  const ::protos::ChangeView& change_view() const;
  PROTOBUF_NODISCARD ::protos::ChangeView* release_change_view();
  ::protos::ChangeView* mutable_change_view();
  void set_allocated_change_view(::protos::ChangeView* value);
  void unsafe_arena_set_allocated_change_view(::protos::ChangeView* value);
  ::protos::ChangeView* unsafe_arena_release_change_view();

  private:
  const ::protos::ChangeView& _internal_change_view() const;
  ::protos::ChangeView* _internal_mutable_change_view();

  public:
  // .protos.Say say = 9;
  bool has_say() const;
  private:
  bool _internal_has_say() const;

  public:
  void clear_say() ;
  const ::protos::Say& say() const;
  PROTOBUF_NODISCARD ::protos::Say* release_say();
  ::protos::Say* mutable_say();
  void set_allocated_say(::protos::Say* value);
  void unsafe_arena_set_allocated_say(::protos::Say* value);
  ::protos::Say* unsafe_arena_release_say();

  private:
  const ::protos::Say& _internal_say() const;
  ::protos::Say* _internal_mutable_say();

  public:
  // .protos.PointTo point_to = 10;
  bool has_point_to() const;
  private:
  bool _internal_has_point_to() const;

  public:
  void clear_point_to() ;
  const ::protos::PointTo& point_to() const;
  PROTOBUF_NODISCARD ::protos::PointTo* release_point_to();
  ::protos::PointTo* mutable_point_to();
  void set_allocated_point_to(::protos::PointTo* value);
  void unsafe_arena_set_allocated_point_to(::protos::PointTo* value);
  ::protos::PointTo* unsafe_arena_release_point_to();

  private:
  const ::protos::PointTo& _internal_point_to() const;
  ::protos::PointTo* _internal_mutable_point_to();

  public:
  // .protos.PointToOf point_to_of = 11;
  bool has_point_to_of() const;
  private:
  bool _internal_has_point_to_of() const;

  public:
  void clear_point_to_of() ;
  const ::protos::PointToOf& point_to_of() const;
  PROTOBUF_NODISCARD ::protos::PointToOf* release_point_to_of();
  ::protos::PointToOf* mutable_point_to_of();
  void set_allocated_point_to_of(::protos::PointToOf* value);
  void unsafe_arena_set_allocated_point_to_of(::protos::PointToOf* value);
  ::protos::PointToOf* unsafe_arena_release_point_to_of();

  private:
  const ::protos::PointToOf& _internal_point_to_of() const;
  ::protos::PointToOf* _internal_mutable_point_to_of();

  public:
  // .protos.AttentionTo attention_to = 12;
  bool has_attention_to() const;
  private:
  bool _internal_has_attention_to() const;

  public:
  void clear_attention_to() ;
  const ::protos::AttentionTo& attention_to() const;
  PROTOBUF_NODISCARD ::protos::AttentionTo* release_attention_to();
  ::protos::AttentionTo* mutable_attention_to();
  void set_allocated_attention_to(::protos::AttentionTo* value);
  void unsafe_arena_set_allocated_attention_to(::protos::AttentionTo* value);
  ::protos::AttentionTo* unsafe_arena_release_attention_to();

  private:
  const ::protos::AttentionTo& _internal_attention_to() const;
  ::protos::AttentionTo* _internal_mutable_attention_to();

  public:
  // .protos.AttentionToOf attention_to_of = 13;
  bool has_attention_to_of() const;
  private:
  bool _internal_has_attention_to_of() const;

  public:
  void clear_attention_to_of() ;
  const ::protos::AttentionToOf& attention_to_of() const;
  PROTOBUF_NODISCARD ::protos::AttentionToOf* release_attention_to_of();
  ::protos::AttentionToOf* mutable_attention_to_of();
  void set_allocated_attention_to_of(::protos::AttentionToOf* value);
  void unsafe_arena_set_allocated_attention_to_of(::protos::AttentionToOf* value);
  ::protos::AttentionToOf* unsafe_arena_release_attention_to_of();

  private:
  const ::protos::AttentionToOf& _internal_attention_to_of() const;
  ::protos::AttentionToOf* _internal_mutable_attention_to_of();

  public:
  // .protos.Log log = 14;
  bool has_log() const;
  private:
  bool _internal_has_log() const;

  public:
  void clear_log() ;
  const ::protos::Log& log() const;
  PROTOBUF_NODISCARD ::protos::Log* release_log();
  ::protos::Log* mutable_log();
  void set_allocated_log(::protos::Log* value);
  void unsafe_arena_set_allocated_log(::protos::Log* value);
  ::protos::Log* unsafe_arena_release_log();

  private:
  const ::protos::Log& _internal_log() const;
  ::protos::Log* _internal_mutable_log();

  public:
  // .protos.DebugClient debug_client = 15;
  bool has_debug_client() const;
  private:
  bool _internal_has_debug_client() const;

  public:
  void clear_debug_client() ;
  const ::protos::DebugClient& debug_client() const;
  PROTOBUF_NODISCARD ::protos::DebugClient* release_debug_client();
  ::protos::DebugClient* mutable_debug_client();
  void set_allocated_debug_client(::protos::DebugClient* value);
  void unsafe_arena_set_allocated_debug_client(::protos::DebugClient* value);
  ::protos::DebugClient* unsafe_arena_release_debug_client();

  private:
  const ::protos::DebugClient& _internal_debug_client() const;
  ::protos::DebugClient* _internal_mutable_debug_client();

  public:
  // .protos.Body_GoToPoint body_go_to_point = 16;
  bool has_body_go_to_point() const;
  private:
  bool _internal_has_body_go_to_point() const;

  public:
  void clear_body_go_to_point() ;
  const ::protos::Body_GoToPoint& body_go_to_point() const;
  PROTOBUF_NODISCARD ::protos::Body_GoToPoint* release_body_go_to_point();
  ::protos::Body_GoToPoint* mutable_body_go_to_point();
  void set_allocated_body_go_to_point(::protos::Body_GoToPoint* value);
  void unsafe_arena_set_allocated_body_go_to_point(::protos::Body_GoToPoint* value);
  ::protos::Body_GoToPoint* unsafe_arena_release_body_go_to_point();

  private:
  const ::protos::Body_GoToPoint& _internal_body_go_to_point() const;
  ::protos::Body_GoToPoint* _internal_mutable_body_go_to_point();

  public:
  // .protos.Body_SmartKick body_smart_kick = 17;
  bool has_body_smart_kick() const;
  private:
  bool _internal_has_body_smart_kick() const;

  public:
  void clear_body_smart_kick() ;
  const ::protos::Body_SmartKick& body_smart_kick() const;
  PROTOBUF_NODISCARD ::protos::Body_SmartKick* release_body_smart_kick();
  ::protos::Body_SmartKick* mutable_body_smart_kick();
  void set_allocated_body_smart_kick(::protos::Body_SmartKick* value);
  void unsafe_arena_set_allocated_body_smart_kick(::protos::Body_SmartKick* value);
  ::protos::Body_SmartKick* unsafe_arena_release_body_smart_kick();

  private:
  const ::protos::Body_SmartKick& _internal_body_smart_kick() const;
  ::protos::Body_SmartKick* _internal_mutable_body_smart_kick();

  public:
  // .protos.Bhv_BeforeKickOff bhv_before_kick_off = 18;
  bool has_bhv_before_kick_off() const;
  private:
  bool _internal_has_bhv_before_kick_off() const;

  public:
  void clear_bhv_before_kick_off() ;
  const ::protos::Bhv_BeforeKickOff& bhv_before_kick_off() const;
  PROTOBUF_NODISCARD ::protos::Bhv_BeforeKickOff* release_bhv_before_kick_off();
  ::protos::Bhv_BeforeKickOff* mutable_bhv_before_kick_off();
  void set_allocated_bhv_before_kick_off(::protos::Bhv_BeforeKickOff* value);
  void unsafe_arena_set_allocated_bhv_before_kick_off(::protos::Bhv_BeforeKickOff* value);
  ::protos::Bhv_BeforeKickOff* unsafe_arena_release_bhv_before_kick_off();

  private:
  const ::protos::Bhv_BeforeKickOff& _internal_bhv_before_kick_off() const;
  ::protos::Bhv_BeforeKickOff* _internal_mutable_bhv_before_kick_off();

  public:
  // .protos.Bhv_BodyNeckToBall bhv_body_neck_to_ball = 19;
  bool has_bhv_body_neck_to_ball() const;
  private:
  bool _internal_has_bhv_body_neck_to_ball() const;

  public:
  void clear_bhv_body_neck_to_ball() ;
  const ::protos::Bhv_BodyNeckToBall& bhv_body_neck_to_ball() const;
  PROTOBUF_NODISCARD ::protos::Bhv_BodyNeckToBall* release_bhv_body_neck_to_ball();
  ::protos::Bhv_BodyNeckToBall* mutable_bhv_body_neck_to_ball();
  void set_allocated_bhv_body_neck_to_ball(::protos::Bhv_BodyNeckToBall* value);
  void unsafe_arena_set_allocated_bhv_body_neck_to_ball(::protos::Bhv_BodyNeckToBall* value);
  ::protos::Bhv_BodyNeckToBall* unsafe_arena_release_bhv_body_neck_to_ball();

  private:
  const ::protos::Bhv_BodyNeckToBall& _internal_bhv_body_neck_to_ball() const;
  ::protos::Bhv_BodyNeckToBall* _internal_mutable_bhv_body_neck_to_ball();

  public:
  // .protos.Bhv_BodyNeckToPoint bhv_body_neck_to_point = 20;
  bool has_bhv_body_neck_to_point() const;
  private:
  bool _internal_has_bhv_body_neck_to_point() const;

  public:
  void clear_bhv_body_neck_to_point() ;
  const ::protos::Bhv_BodyNeckToPoint& bhv_body_neck_to_point() const;
  PROTOBUF_NODISCARD ::protos::Bhv_BodyNeckToPoint* release_bhv_body_neck_to_point();
  ::protos::Bhv_BodyNeckToPoint* mutable_bhv_body_neck_to_point();
  void set_allocated_bhv_body_neck_to_point(::protos::Bhv_BodyNeckToPoint* value);
  void unsafe_arena_set_allocated_bhv_body_neck_to_point(::protos::Bhv_BodyNeckToPoint* value);
  ::protos::Bhv_BodyNeckToPoint* unsafe_arena_release_bhv_body_neck_to_point();

  private:
  const ::protos::Bhv_BodyNeckToPoint& _internal_bhv_body_neck_to_point() const;
  ::protos::Bhv_BodyNeckToPoint* _internal_mutable_bhv_body_neck_to_point();

  public:
  // .protos.Bhv_Emergency bhv_emergency = 21;
  bool has_bhv_emergency() const;
  private:
  bool _internal_has_bhv_emergency() const;

  public:
  void clear_bhv_emergency() ;
  const ::protos::Bhv_Emergency& bhv_emergency() const;
  PROTOBUF_NODISCARD ::protos::Bhv_Emergency* release_bhv_emergency();
  ::protos::Bhv_Emergency* mutable_bhv_emergency();
  void set_allocated_bhv_emergency(::protos::Bhv_Emergency* value);
  void unsafe_arena_set_allocated_bhv_emergency(::protos::Bhv_Emergency* value);
  ::protos::Bhv_Emergency* unsafe_arena_release_bhv_emergency();

  private:
  const ::protos::Bhv_Emergency& _internal_bhv_emergency() const;
  ::protos::Bhv_Emergency* _internal_mutable_bhv_emergency();

  public:
  // .protos.Bhv_GoToPointLookBall bhv_go_to_point_look_ball = 22;
  bool has_bhv_go_to_point_look_ball() const;
  private:
  bool _internal_has_bhv_go_to_point_look_ball() const;

  public:
  void clear_bhv_go_to_point_look_ball() ;
  const ::protos::Bhv_GoToPointLookBall& bhv_go_to_point_look_ball() const;
  PROTOBUF_NODISCARD ::protos::Bhv_GoToPointLookBall* release_bhv_go_to_point_look_ball();
  ::protos::Bhv_GoToPointLookBall* mutable_bhv_go_to_point_look_ball();
  void set_allocated_bhv_go_to_point_look_ball(::protos::Bhv_GoToPointLookBall* value);
  void unsafe_arena_set_allocated_bhv_go_to_point_look_ball(::protos::Bhv_GoToPointLookBall* value);
  ::protos::Bhv_GoToPointLookBall* unsafe_arena_release_bhv_go_to_point_look_ball();

  private:
  const ::protos::Bhv_GoToPointLookBall& _internal_bhv_go_to_point_look_ball() const;
  ::protos::Bhv_GoToPointLookBall* _internal_mutable_bhv_go_to_point_look_ball();

  public:
  // .protos.Bhv_NeckBodyToBall bhv_neck_body_to_ball = 23;
  bool has_bhv_neck_body_to_ball() const;
  private:
  bool _internal_has_bhv_neck_body_to_ball() const;

  public:
  void clear_bhv_neck_body_to_ball() ;
  const ::protos::Bhv_NeckBodyToBall& bhv_neck_body_to_ball() const;
  PROTOBUF_NODISCARD ::protos::Bhv_NeckBodyToBall* release_bhv_neck_body_to_ball();
  ::protos::Bhv_NeckBodyToBall* mutable_bhv_neck_body_to_ball();
  void set_allocated_bhv_neck_body_to_ball(::protos::Bhv_NeckBodyToBall* value);
  void unsafe_arena_set_allocated_bhv_neck_body_to_ball(::protos::Bhv_NeckBodyToBall* value);
  ::protos::Bhv_NeckBodyToBall* unsafe_arena_release_bhv_neck_body_to_ball();

  private:
  const ::protos::Bhv_NeckBodyToBall& _internal_bhv_neck_body_to_ball() const;
  ::protos::Bhv_NeckBodyToBall* _internal_mutable_bhv_neck_body_to_ball();

  public:
  // .protos.Bhv_NeckBodyToPoint bhv_neck_body_to_point = 24;
  bool has_bhv_neck_body_to_point() const;
  private:
  bool _internal_has_bhv_neck_body_to_point() const;

  public:
  void clear_bhv_neck_body_to_point() ;
  const ::protos::Bhv_NeckBodyToPoint& bhv_neck_body_to_point() const;
  PROTOBUF_NODISCARD ::protos::Bhv_NeckBodyToPoint* release_bhv_neck_body_to_point();
  ::protos::Bhv_NeckBodyToPoint* mutable_bhv_neck_body_to_point();
  void set_allocated_bhv_neck_body_to_point(::protos::Bhv_NeckBodyToPoint* value);
  void unsafe_arena_set_allocated_bhv_neck_body_to_point(::protos::Bhv_NeckBodyToPoint* value);
  ::protos::Bhv_NeckBodyToPoint* unsafe_arena_release_bhv_neck_body_to_point();

  private:
  const ::protos::Bhv_NeckBodyToPoint& _internal_bhv_neck_body_to_point() const;
  ::protos::Bhv_NeckBodyToPoint* _internal_mutable_bhv_neck_body_to_point();

  public:
  // .protos.Bhv_ScanField bhv_scan_field = 25;
  bool has_bhv_scan_field() const;
  private:
  bool _internal_has_bhv_scan_field() const;

  public:
  void clear_bhv_scan_field() ;
  const ::protos::Bhv_ScanField& bhv_scan_field() const;
  PROTOBUF_NODISCARD ::protos::Bhv_ScanField* release_bhv_scan_field();
  ::protos::Bhv_ScanField* mutable_bhv_scan_field();
  void set_allocated_bhv_scan_field(::protos::Bhv_ScanField* value);
  void unsafe_arena_set_allocated_bhv_scan_field(::protos::Bhv_ScanField* value);
  ::protos::Bhv_ScanField* unsafe_arena_release_bhv_scan_field();

  private:
  const ::protos::Bhv_ScanField& _internal_bhv_scan_field() const;
  ::protos::Bhv_ScanField* _internal_mutable_bhv_scan_field();

  public:
  // .protos.Body_AdvanceBall body_advance_ball = 26;
  bool has_body_advance_ball() const;
  private:
  bool _internal_has_body_advance_ball() const;

  public:
  void clear_body_advance_ball() ;
  const ::protos::Body_AdvanceBall& body_advance_ball() const;
  PROTOBUF_NODISCARD ::protos::Body_AdvanceBall* release_body_advance_ball();
  ::protos::Body_AdvanceBall* mutable_body_advance_ball();
  void set_allocated_body_advance_ball(::protos::Body_AdvanceBall* value);
  void unsafe_arena_set_allocated_body_advance_ball(::protos::Body_AdvanceBall* value);
  ::protos::Body_AdvanceBall* unsafe_arena_release_body_advance_ball();

  private:
  const ::protos::Body_AdvanceBall& _internal_body_advance_ball() const;
  ::protos::Body_AdvanceBall* _internal_mutable_body_advance_ball();

  public:
  // .protos.Body_ClearBall body_clear_ball = 27;
  bool has_body_clear_ball() const;
  private:
  bool _internal_has_body_clear_ball() const;

  public:
  void clear_body_clear_ball() ;
  const ::protos::Body_ClearBall& body_clear_ball() const;
  PROTOBUF_NODISCARD ::protos::Body_ClearBall* release_body_clear_ball();
  ::protos::Body_ClearBall* mutable_body_clear_ball();
  void set_allocated_body_clear_ball(::protos::Body_ClearBall* value);
  void unsafe_arena_set_allocated_body_clear_ball(::protos::Body_ClearBall* value);
  ::protos::Body_ClearBall* unsafe_arena_release_body_clear_ball();

  private:
  const ::protos::Body_ClearBall& _internal_body_clear_ball() const;
  ::protos::Body_ClearBall* _internal_mutable_body_clear_ball();

  public:
  // .protos.Body_Dribble body_dribble = 28;
  bool has_body_dribble() const;
  private:
  bool _internal_has_body_dribble() const;

  public:
  void clear_body_dribble() ;
  const ::protos::Body_Dribble& body_dribble() const;
  PROTOBUF_NODISCARD ::protos::Body_Dribble* release_body_dribble();
  ::protos::Body_Dribble* mutable_body_dribble();
  void set_allocated_body_dribble(::protos::Body_Dribble* value);
  void unsafe_arena_set_allocated_body_dribble(::protos::Body_Dribble* value);
  ::protos::Body_Dribble* unsafe_arena_release_body_dribble();

  private:
  const ::protos::Body_Dribble& _internal_body_dribble() const;
  ::protos::Body_Dribble* _internal_mutable_body_dribble();

  public:
  // .protos.Body_GoToPointDodge body_go_to_point_dodge = 29;
  bool has_body_go_to_point_dodge() const;
  private:
  bool _internal_has_body_go_to_point_dodge() const;

  public:
  void clear_body_go_to_point_dodge() ;
  const ::protos::Body_GoToPointDodge& body_go_to_point_dodge() const;
  PROTOBUF_NODISCARD ::protos::Body_GoToPointDodge* release_body_go_to_point_dodge();
  ::protos::Body_GoToPointDodge* mutable_body_go_to_point_dodge();
  void set_allocated_body_go_to_point_dodge(::protos::Body_GoToPointDodge* value);
  void unsafe_arena_set_allocated_body_go_to_point_dodge(::protos::Body_GoToPointDodge* value);
  ::protos::Body_GoToPointDodge* unsafe_arena_release_body_go_to_point_dodge();

  private:
  const ::protos::Body_GoToPointDodge& _internal_body_go_to_point_dodge() const;
  ::protos::Body_GoToPointDodge* _internal_mutable_body_go_to_point_dodge();

  public:
  // .protos.Body_HoldBall body_hold_ball = 30;
  bool has_body_hold_ball() const;
  private:
  bool _internal_has_body_hold_ball() const;

  public:
  void clear_body_hold_ball() ;
  const ::protos::Body_HoldBall& body_hold_ball() const;
  PROTOBUF_NODISCARD ::protos::Body_HoldBall* release_body_hold_ball();
  ::protos::Body_HoldBall* mutable_body_hold_ball();
  void set_allocated_body_hold_ball(::protos::Body_HoldBall* value);
  void unsafe_arena_set_allocated_body_hold_ball(::protos::Body_HoldBall* value);
  ::protos::Body_HoldBall* unsafe_arena_release_body_hold_ball();

  private:
  const ::protos::Body_HoldBall& _internal_body_hold_ball() const;
  ::protos::Body_HoldBall* _internal_mutable_body_hold_ball();

  public:
  // .protos.Body_Intercept body_intercept = 31;
  bool has_body_intercept() const;
  private:
  bool _internal_has_body_intercept() const;

  public:
  void clear_body_intercept() ;
  const ::protos::Body_Intercept& body_intercept() const;
  PROTOBUF_NODISCARD ::protos::Body_Intercept* release_body_intercept();
  ::protos::Body_Intercept* mutable_body_intercept();
  void set_allocated_body_intercept(::protos::Body_Intercept* value);
  void unsafe_arena_set_allocated_body_intercept(::protos::Body_Intercept* value);
  ::protos::Body_Intercept* unsafe_arena_release_body_intercept();

  private:
  const ::protos::Body_Intercept& _internal_body_intercept() const;
  ::protos::Body_Intercept* _internal_mutable_body_intercept();

  public:
  // .protos.Body_KickOneStep body_kick_one_step = 32;
  bool has_body_kick_one_step() const;
  private:
  bool _internal_has_body_kick_one_step() const;

  public:
  void clear_body_kick_one_step() ;
  const ::protos::Body_KickOneStep& body_kick_one_step() const;
  PROTOBUF_NODISCARD ::protos::Body_KickOneStep* release_body_kick_one_step();
  ::protos::Body_KickOneStep* mutable_body_kick_one_step();
  void set_allocated_body_kick_one_step(::protos::Body_KickOneStep* value);
  void unsafe_arena_set_allocated_body_kick_one_step(::protos::Body_KickOneStep* value);
  ::protos::Body_KickOneStep* unsafe_arena_release_body_kick_one_step();

  private:
  const ::protos::Body_KickOneStep& _internal_body_kick_one_step() const;
  ::protos::Body_KickOneStep* _internal_mutable_body_kick_one_step();

  public:
  // .protos.Body_StopBall body_stop_ball = 33;
  bool has_body_stop_ball() const;
  private:
  bool _internal_has_body_stop_ball() const;

  public:
  void clear_body_stop_ball() ;
  const ::protos::Body_StopBall& body_stop_ball() const;
  PROTOBUF_NODISCARD ::protos::Body_StopBall* release_body_stop_ball();
  ::protos::Body_StopBall* mutable_body_stop_ball();
  void set_allocated_body_stop_ball(::protos::Body_StopBall* value);
  void unsafe_arena_set_allocated_body_stop_ball(::protos::Body_StopBall* value);
  ::protos::Body_StopBall* unsafe_arena_release_body_stop_ball();

  private:
  const ::protos::Body_StopBall& _internal_body_stop_ball() const;
  ::protos::Body_StopBall* _internal_mutable_body_stop_ball();

  public:
  // .protos.Body_StopDash body_stop_dash = 34;
  bool has_body_stop_dash() const;
  private:
  bool _internal_has_body_stop_dash() const;

  public:
  void clear_body_stop_dash() ;
  const ::protos::Body_StopDash& body_stop_dash() const;
  PROTOBUF_NODISCARD ::protos::Body_StopDash* release_body_stop_dash();
  ::protos::Body_StopDash* mutable_body_stop_dash();
  void set_allocated_body_stop_dash(::protos::Body_StopDash* value);
  void unsafe_arena_set_allocated_body_stop_dash(::protos::Body_StopDash* value);
  ::protos::Body_StopDash* unsafe_arena_release_body_stop_dash();

  private:
  const ::protos::Body_StopDash& _internal_body_stop_dash() const;
  ::protos::Body_StopDash* _internal_mutable_body_stop_dash();

  public:
  // .protos.Body_TackleToPoint body_tackle_to_point = 35;
  bool has_body_tackle_to_point() const;
  private:
  bool _internal_has_body_tackle_to_point() const;

  public:
  void clear_body_tackle_to_point() ;
  const ::protos::Body_TackleToPoint& body_tackle_to_point() const;
  PROTOBUF_NODISCARD ::protos::Body_TackleToPoint* release_body_tackle_to_point();
  ::protos::Body_TackleToPoint* mutable_body_tackle_to_point();
  void set_allocated_body_tackle_to_point(::protos::Body_TackleToPoint* value);
  void unsafe_arena_set_allocated_body_tackle_to_point(::protos::Body_TackleToPoint* value);
  ::protos::Body_TackleToPoint* unsafe_arena_release_body_tackle_to_point();

  private:
  const ::protos::Body_TackleToPoint& _internal_body_tackle_to_point() const;
  ::protos::Body_TackleToPoint* _internal_mutable_body_tackle_to_point();

  public:
  // .protos.Body_TurnToAngle body_turn_to_angle = 36;
  bool has_body_turn_to_angle() const;
  private:
  bool _internal_has_body_turn_to_angle() const;

  public:
  void clear_body_turn_to_angle() ;
  const ::protos::Body_TurnToAngle& body_turn_to_angle() const;
  PROTOBUF_NODISCARD ::protos::Body_TurnToAngle* release_body_turn_to_angle();
  ::protos::Body_TurnToAngle* mutable_body_turn_to_angle();
  void set_allocated_body_turn_to_angle(::protos::Body_TurnToAngle* value);
  void unsafe_arena_set_allocated_body_turn_to_angle(::protos::Body_TurnToAngle* value);
  ::protos::Body_TurnToAngle* unsafe_arena_release_body_turn_to_angle();

  private:
  const ::protos::Body_TurnToAngle& _internal_body_turn_to_angle() const;
  ::protos::Body_TurnToAngle* _internal_mutable_body_turn_to_angle();

  public:
  // .protos.Body_TurnToBall body_turn_to_ball = 37;
  bool has_body_turn_to_ball() const;
  private:
  bool _internal_has_body_turn_to_ball() const;

  public:
  void clear_body_turn_to_ball() ;
  const ::protos::Body_TurnToBall& body_turn_to_ball() const;
  PROTOBUF_NODISCARD ::protos::Body_TurnToBall* release_body_turn_to_ball();
  ::protos::Body_TurnToBall* mutable_body_turn_to_ball();
  void set_allocated_body_turn_to_ball(::protos::Body_TurnToBall* value);
  void unsafe_arena_set_allocated_body_turn_to_ball(::protos::Body_TurnToBall* value);
  ::protos::Body_TurnToBall* unsafe_arena_release_body_turn_to_ball();

  private:
  const ::protos::Body_TurnToBall& _internal_body_turn_to_ball() const;
  ::protos::Body_TurnToBall* _internal_mutable_body_turn_to_ball();

  public:
  // .protos.Body_TurnToPoint body_turn_to_point = 38;
  bool has_body_turn_to_point() const;
  private:
  bool _internal_has_body_turn_to_point() const;

  public:
  void clear_body_turn_to_point() ;
  const ::protos::Body_TurnToPoint& body_turn_to_point() const;
  PROTOBUF_NODISCARD ::protos::Body_TurnToPoint* release_body_turn_to_point();
  ::protos::Body_TurnToPoint* mutable_body_turn_to_point();
  void set_allocated_body_turn_to_point(::protos::Body_TurnToPoint* value);
  void unsafe_arena_set_allocated_body_turn_to_point(::protos::Body_TurnToPoint* value);
  ::protos::Body_TurnToPoint* unsafe_arena_release_body_turn_to_point();

  private:
  const ::protos::Body_TurnToPoint& _internal_body_turn_to_point() const;
  ::protos::Body_TurnToPoint* _internal_mutable_body_turn_to_point();

  public:
  // .protos.Focus_MoveToPoint focus_move_to_point = 39;
  bool has_focus_move_to_point() const;
  private:
  bool _internal_has_focus_move_to_point() const;

  public:
  void clear_focus_move_to_point() ;
  const ::protos::Focus_MoveToPoint& focus_move_to_point() const;
  PROTOBUF_NODISCARD ::protos::Focus_MoveToPoint* release_focus_move_to_point();
  ::protos::Focus_MoveToPoint* mutable_focus_move_to_point();
  void set_allocated_focus_move_to_point(::protos::Focus_MoveToPoint* value);
  void unsafe_arena_set_allocated_focus_move_to_point(::protos::Focus_MoveToPoint* value);
  ::protos::Focus_MoveToPoint* unsafe_arena_release_focus_move_to_point();

  private:
  const ::protos::Focus_MoveToPoint& _internal_focus_move_to_point() const;
  ::protos::Focus_MoveToPoint* _internal_mutable_focus_move_to_point();

  public:
  // .protos.Focus_Reset focus_reset = 40;
  bool has_focus_reset() const;
  private:
  bool _internal_has_focus_reset() const;

  public:
  void clear_focus_reset() ;
  const ::protos::Focus_Reset& focus_reset() const;
  PROTOBUF_NODISCARD ::protos::Focus_Reset* release_focus_reset();
  ::protos::Focus_Reset* mutable_focus_reset();
  void set_allocated_focus_reset(::protos::Focus_Reset* value);
  void unsafe_arena_set_allocated_focus_reset(::protos::Focus_Reset* value);
  ::protos::Focus_Reset* unsafe_arena_release_focus_reset();

  private:
  const ::protos::Focus_Reset& _internal_focus_reset() const;
  ::protos::Focus_Reset* _internal_mutable_focus_reset();

  public:
  // .protos.Neck_ScanField neck_scan_field = 41;
  bool has_neck_scan_field() const;
  private:
  bool _internal_has_neck_scan_field() const;

  public:
  void clear_neck_scan_field() ;
  const ::protos::Neck_ScanField& neck_scan_field() const;
  PROTOBUF_NODISCARD ::protos::Neck_ScanField* release_neck_scan_field();
  ::protos::Neck_ScanField* mutable_neck_scan_field();
  void set_allocated_neck_scan_field(::protos::Neck_ScanField* value);
  void unsafe_arena_set_allocated_neck_scan_field(::protos::Neck_ScanField* value);
  ::protos::Neck_ScanField* unsafe_arena_release_neck_scan_field();

  private:
  const ::protos::Neck_ScanField& _internal_neck_scan_field() const;
  ::protos::Neck_ScanField* _internal_mutable_neck_scan_field();

  public:
  // .protos.Neck_ScanPlayers neck_scan_players = 42;
  bool has_neck_scan_players() const;
  private:
  bool _internal_has_neck_scan_players() const;

  public:
  void clear_neck_scan_players() ;
  const ::protos::Neck_ScanPlayers& neck_scan_players() const;
  PROTOBUF_NODISCARD ::protos::Neck_ScanPlayers* release_neck_scan_players();
  ::protos::Neck_ScanPlayers* mutable_neck_scan_players();
  void set_allocated_neck_scan_players(::protos::Neck_ScanPlayers* value);
  void unsafe_arena_set_allocated_neck_scan_players(::protos::Neck_ScanPlayers* value);
  ::protos::Neck_ScanPlayers* unsafe_arena_release_neck_scan_players();

  private:
  const ::protos::Neck_ScanPlayers& _internal_neck_scan_players() const;
  ::protos::Neck_ScanPlayers* _internal_mutable_neck_scan_players();

  public:
  // .protos.Neck_TurnToBallAndPlayer neck_turn_to_ball_and_player = 43;
  bool has_neck_turn_to_ball_and_player() const;
  private:
  bool _internal_has_neck_turn_to_ball_and_player() const;

  public:
  void clear_neck_turn_to_ball_and_player() ;
  const ::protos::Neck_TurnToBallAndPlayer& neck_turn_to_ball_and_player() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToBallAndPlayer* release_neck_turn_to_ball_and_player();
  ::protos::Neck_TurnToBallAndPlayer* mutable_neck_turn_to_ball_and_player();
  void set_allocated_neck_turn_to_ball_and_player(::protos::Neck_TurnToBallAndPlayer* value);
  void unsafe_arena_set_allocated_neck_turn_to_ball_and_player(::protos::Neck_TurnToBallAndPlayer* value);
  ::protos::Neck_TurnToBallAndPlayer* unsafe_arena_release_neck_turn_to_ball_and_player();

  private:
  const ::protos::Neck_TurnToBallAndPlayer& _internal_neck_turn_to_ball_and_player() const;
  ::protos::Neck_TurnToBallAndPlayer* _internal_mutable_neck_turn_to_ball_and_player();

  public:
  // .protos.Neck_TurnToBallOrScan neck_turn_to_ball_or_scan = 44;
  bool has_neck_turn_to_ball_or_scan() const;
  private:
  bool _internal_has_neck_turn_to_ball_or_scan() const;

  public:
  void clear_neck_turn_to_ball_or_scan() ;
  const ::protos::Neck_TurnToBallOrScan& neck_turn_to_ball_or_scan() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToBallOrScan* release_neck_turn_to_ball_or_scan();
  ::protos::Neck_TurnToBallOrScan* mutable_neck_turn_to_ball_or_scan();
  void set_allocated_neck_turn_to_ball_or_scan(::protos::Neck_TurnToBallOrScan* value);
  void unsafe_arena_set_allocated_neck_turn_to_ball_or_scan(::protos::Neck_TurnToBallOrScan* value);
  ::protos::Neck_TurnToBallOrScan* unsafe_arena_release_neck_turn_to_ball_or_scan();

  private:
  const ::protos::Neck_TurnToBallOrScan& _internal_neck_turn_to_ball_or_scan() const;
  ::protos::Neck_TurnToBallOrScan* _internal_mutable_neck_turn_to_ball_or_scan();

  public:
  // .protos.Neck_TurnToBall neck_turn_to_ball = 45;
  bool has_neck_turn_to_ball() const;
  private:
  bool _internal_has_neck_turn_to_ball() const;

  public:
  void clear_neck_turn_to_ball() ;
  const ::protos::Neck_TurnToBall& neck_turn_to_ball() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToBall* release_neck_turn_to_ball();
  ::protos::Neck_TurnToBall* mutable_neck_turn_to_ball();
  void set_allocated_neck_turn_to_ball(::protos::Neck_TurnToBall* value);
  void unsafe_arena_set_allocated_neck_turn_to_ball(::protos::Neck_TurnToBall* value);
  ::protos::Neck_TurnToBall* unsafe_arena_release_neck_turn_to_ball();

  private:
  const ::protos::Neck_TurnToBall& _internal_neck_turn_to_ball() const;
  ::protos::Neck_TurnToBall* _internal_mutable_neck_turn_to_ball();

  public:
  // .protos.Neck_TurnToGoalieOrScan neck_turn_to_goalie_or_scan = 46;
  bool has_neck_turn_to_goalie_or_scan() const;
  private:
  bool _internal_has_neck_turn_to_goalie_or_scan() const;

  public:
  void clear_neck_turn_to_goalie_or_scan() ;
  const ::protos::Neck_TurnToGoalieOrScan& neck_turn_to_goalie_or_scan() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToGoalieOrScan* release_neck_turn_to_goalie_or_scan();
  ::protos::Neck_TurnToGoalieOrScan* mutable_neck_turn_to_goalie_or_scan();
  void set_allocated_neck_turn_to_goalie_or_scan(::protos::Neck_TurnToGoalieOrScan* value);
  void unsafe_arena_set_allocated_neck_turn_to_goalie_or_scan(::protos::Neck_TurnToGoalieOrScan* value);
  ::protos::Neck_TurnToGoalieOrScan* unsafe_arena_release_neck_turn_to_goalie_or_scan();

  private:
  const ::protos::Neck_TurnToGoalieOrScan& _internal_neck_turn_to_goalie_or_scan() const;
  ::protos::Neck_TurnToGoalieOrScan* _internal_mutable_neck_turn_to_goalie_or_scan();

  public:
  // .protos.Neck_TurnToLowConfTeammate neck_turn_to_low_conf_teammate = 47;
  bool has_neck_turn_to_low_conf_teammate() const;
  private:
  bool _internal_has_neck_turn_to_low_conf_teammate() const;

  public:
  void clear_neck_turn_to_low_conf_teammate() ;
  const ::protos::Neck_TurnToLowConfTeammate& neck_turn_to_low_conf_teammate() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToLowConfTeammate* release_neck_turn_to_low_conf_teammate();
  ::protos::Neck_TurnToLowConfTeammate* mutable_neck_turn_to_low_conf_teammate();
  void set_allocated_neck_turn_to_low_conf_teammate(::protos::Neck_TurnToLowConfTeammate* value);
  void unsafe_arena_set_allocated_neck_turn_to_low_conf_teammate(::protos::Neck_TurnToLowConfTeammate* value);
  ::protos::Neck_TurnToLowConfTeammate* unsafe_arena_release_neck_turn_to_low_conf_teammate();

  private:
  const ::protos::Neck_TurnToLowConfTeammate& _internal_neck_turn_to_low_conf_teammate() const;
  ::protos::Neck_TurnToLowConfTeammate* _internal_mutable_neck_turn_to_low_conf_teammate();

  public:
  // .protos.Neck_TurnToPlayerOrScan neck_turn_to_player_or_scan = 48;
  bool has_neck_turn_to_player_or_scan() const;
  private:
  bool _internal_has_neck_turn_to_player_or_scan() const;

  public:
  void clear_neck_turn_to_player_or_scan() ;
  const ::protos::Neck_TurnToPlayerOrScan& neck_turn_to_player_or_scan() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToPlayerOrScan* release_neck_turn_to_player_or_scan();
  ::protos::Neck_TurnToPlayerOrScan* mutable_neck_turn_to_player_or_scan();
  void set_allocated_neck_turn_to_player_or_scan(::protos::Neck_TurnToPlayerOrScan* value);
  void unsafe_arena_set_allocated_neck_turn_to_player_or_scan(::protos::Neck_TurnToPlayerOrScan* value);
  ::protos::Neck_TurnToPlayerOrScan* unsafe_arena_release_neck_turn_to_player_or_scan();

  private:
  const ::protos::Neck_TurnToPlayerOrScan& _internal_neck_turn_to_player_or_scan() const;
  ::protos::Neck_TurnToPlayerOrScan* _internal_mutable_neck_turn_to_player_or_scan();

  public:
  // .protos.Neck_TurnToPoint neck_turn_to_point = 49;
  bool has_neck_turn_to_point() const;
  private:
  bool _internal_has_neck_turn_to_point() const;

  public:
  void clear_neck_turn_to_point() ;
  const ::protos::Neck_TurnToPoint& neck_turn_to_point() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToPoint* release_neck_turn_to_point();
  ::protos::Neck_TurnToPoint* mutable_neck_turn_to_point();
  void set_allocated_neck_turn_to_point(::protos::Neck_TurnToPoint* value);
  void unsafe_arena_set_allocated_neck_turn_to_point(::protos::Neck_TurnToPoint* value);
  ::protos::Neck_TurnToPoint* unsafe_arena_release_neck_turn_to_point();

  private:
  const ::protos::Neck_TurnToPoint& _internal_neck_turn_to_point() const;
  ::protos::Neck_TurnToPoint* _internal_mutable_neck_turn_to_point();

  public:
  // .protos.Neck_TurnToRelative neck_turn_to_relative = 50;
  bool has_neck_turn_to_relative() const;
  private:
  bool _internal_has_neck_turn_to_relative() const;

  public:
  void clear_neck_turn_to_relative() ;
  const ::protos::Neck_TurnToRelative& neck_turn_to_relative() const;
  PROTOBUF_NODISCARD ::protos::Neck_TurnToRelative* release_neck_turn_to_relative();
  ::protos::Neck_TurnToRelative* mutable_neck_turn_to_relative();
  void set_allocated_neck_turn_to_relative(::protos::Neck_TurnToRelative* value);
  void unsafe_arena_set_allocated_neck_turn_to_relative(::protos::Neck_TurnToRelative* value);
  ::protos::Neck_TurnToRelative* unsafe_arena_release_neck_turn_to_relative();

  private:
  const ::protos::Neck_TurnToRelative& _internal_neck_turn_to_relative() const;
  ::protos::Neck_TurnToRelative* _internal_mutable_neck_turn_to_relative();

  public:
  // .protos.View_ChangeWidth view_change_width = 51;
  bool has_view_change_width() const;
  private:
  bool _internal_has_view_change_width() const;

  public:
  void clear_view_change_width() ;
  const ::protos::View_ChangeWidth& view_change_width() const;
  PROTOBUF_NODISCARD ::protos::View_ChangeWidth* release_view_change_width();
  ::protos::View_ChangeWidth* mutable_view_change_width();
  void set_allocated_view_change_width(::protos::View_ChangeWidth* value);
  void unsafe_arena_set_allocated_view_change_width(::protos::View_ChangeWidth* value);
  ::protos::View_ChangeWidth* unsafe_arena_release_view_change_width();

  private:
  const ::protos::View_ChangeWidth& _internal_view_change_width() const;
  ::protos::View_ChangeWidth* _internal_mutable_view_change_width();

  public:
  // .protos.View_Normal view_normal = 52;
  bool has_view_normal() const;
  private:
  bool _internal_has_view_normal() const;

  public:
  void clear_view_normal() ;
  const ::protos::View_Normal& view_normal() const;
  PROTOBUF_NODISCARD ::protos::View_Normal* release_view_normal();
  ::protos::View_Normal* mutable_view_normal();
  void set_allocated_view_normal(::protos::View_Normal* value);
  void unsafe_arena_set_allocated_view_normal(::protos::View_Normal* value);
  ::protos::View_Normal* unsafe_arena_release_view_normal();

  private:
  const ::protos::View_Normal& _internal_view_normal() const;
  ::protos::View_Normal* _internal_mutable_view_normal();

  public:
  // .protos.View_Synch view_synch = 53;
  bool has_view_synch() const;
  private:
  bool _internal_has_view_synch() const;

  public:
  void clear_view_synch() ;
  const ::protos::View_Synch& view_synch() const;
  PROTOBUF_NODISCARD ::protos::View_Synch* release_view_synch();
  ::protos::View_Synch* mutable_view_synch();
  void set_allocated_view_synch(::protos::View_Synch* value);
  void unsafe_arena_set_allocated_view_synch(::protos::View_Synch* value);
  ::protos::View_Synch* unsafe_arena_release_view_synch();

  private:
  const ::protos::View_Synch& _internal_view_synch() const;
  ::protos::View_Synch* _internal_mutable_view_synch();

  public:
  // .protos.View_Wide view_wide = 54;
  bool has_view_wide() const;
  private:
  bool _internal_has_view_wide() const;

  public:
  void clear_view_wide() ;
  const ::protos::View_Wide& view_wide() const;
  PROTOBUF_NODISCARD ::protos::View_Wide* release_view_wide();
  ::protos::View_Wide* mutable_view_wide();
  void set_allocated_view_wide(::protos::View_Wide* value);
  void unsafe_arena_set_allocated_view_wide(::protos::View_Wide* value);
  ::protos::View_Wide* unsafe_arena_release_view_wide();

  private:
  const ::protos::View_Wide& _internal_view_wide() const;
  ::protos::View_Wide* _internal_mutable_view_wide();

  public:
  // .protos.HeliosGoalie helios_goalie = 55;
  bool has_helios_goalie() const;
  private:
  bool _internal_has_helios_goalie() const;

  public:
  void clear_helios_goalie() ;
  const ::protos::HeliosGoalie& helios_goalie() const;
  PROTOBUF_NODISCARD ::protos::HeliosGoalie* release_helios_goalie();
  ::protos::HeliosGoalie* mutable_helios_goalie();
  void set_allocated_helios_goalie(::protos::HeliosGoalie* value);
  void unsafe_arena_set_allocated_helios_goalie(::protos::HeliosGoalie* value);
  ::protos::HeliosGoalie* unsafe_arena_release_helios_goalie();

  private:
  const ::protos::HeliosGoalie& _internal_helios_goalie() const;
  ::protos::HeliosGoalie* _internal_mutable_helios_goalie();

  public:
  // .protos.HeliosGoalieMove helios_goalie_move = 56;
  bool has_helios_goalie_move() const;
  private:
  bool _internal_has_helios_goalie_move() const;

  public:
  void clear_helios_goalie_move() ;
  const ::protos::HeliosGoalieMove& helios_goalie_move() const;
  PROTOBUF_NODISCARD ::protos::HeliosGoalieMove* release_helios_goalie_move();
  ::protos::HeliosGoalieMove* mutable_helios_goalie_move();
  void set_allocated_helios_goalie_move(::protos::HeliosGoalieMove* value);
  void unsafe_arena_set_allocated_helios_goalie_move(::protos::HeliosGoalieMove* value);
  ::protos::HeliosGoalieMove* unsafe_arena_release_helios_goalie_move();

  private:
  const ::protos::HeliosGoalieMove& _internal_helios_goalie_move() const;
  ::protos::HeliosGoalieMove* _internal_mutable_helios_goalie_move();

  public:
  // .protos.HeliosGoalieKick helios_goalie_kick = 57;
  bool has_helios_goalie_kick() const;
  private:
  bool _internal_has_helios_goalie_kick() const;

  public:
  void clear_helios_goalie_kick() ;
  const ::protos::HeliosGoalieKick& helios_goalie_kick() const;
  PROTOBUF_NODISCARD ::protos::HeliosGoalieKick* release_helios_goalie_kick();
  ::protos::HeliosGoalieKick* mutable_helios_goalie_kick();
  void set_allocated_helios_goalie_kick(::protos::HeliosGoalieKick* value);
  void unsafe_arena_set_allocated_helios_goalie_kick(::protos::HeliosGoalieKick* value);
  ::protos::HeliosGoalieKick* unsafe_arena_release_helios_goalie_kick();

  private:
  const ::protos::HeliosGoalieKick& _internal_helios_goalie_kick() const;
  ::protos::HeliosGoalieKick* _internal_mutable_helios_goalie_kick();

  public:
  // .protos.HeliosShoot helios_shoot = 58;
  bool has_helios_shoot() const;
  private:
  bool _internal_has_helios_shoot() const;

  public:
  void clear_helios_shoot() ;
  const ::protos::HeliosShoot& helios_shoot() const;
  PROTOBUF_NODISCARD ::protos::HeliosShoot* release_helios_shoot();
  ::protos::HeliosShoot* mutable_helios_shoot();
  void set_allocated_helios_shoot(::protos::HeliosShoot* value);
  void unsafe_arena_set_allocated_helios_shoot(::protos::HeliosShoot* value);
  ::protos::HeliosShoot* unsafe_arena_release_helios_shoot();

  private:
  const ::protos::HeliosShoot& _internal_helios_shoot() const;
  ::protos::HeliosShoot* _internal_mutable_helios_shoot();

  public:
  // .protos.HeliosChainAction helios_chain_action = 59;
  bool has_helios_chain_action() const;
  private:
  bool _internal_has_helios_chain_action() const;

  public:
  void clear_helios_chain_action() ;
  const ::protos::HeliosChainAction& helios_chain_action() const;
  PROTOBUF_NODISCARD ::protos::HeliosChainAction* release_helios_chain_action();
  ::protos::HeliosChainAction* mutable_helios_chain_action();
  void set_allocated_helios_chain_action(::protos::HeliosChainAction* value);
  void unsafe_arena_set_allocated_helios_chain_action(::protos::HeliosChainAction* value);
  ::protos::HeliosChainAction* unsafe_arena_release_helios_chain_action();

  private:
  const ::protos::HeliosChainAction& _internal_helios_chain_action() const;
  ::protos::HeliosChainAction* _internal_mutable_helios_chain_action();

  public:
  // .protos.HeliosBasicOffensive helios_basic_offensive = 60;
  bool has_helios_basic_offensive() const;
  private:
  bool _internal_has_helios_basic_offensive() const;

  public:
  void clear_helios_basic_offensive() ;
  const ::protos::HeliosBasicOffensive& helios_basic_offensive() const;
  PROTOBUF_NODISCARD ::protos::HeliosBasicOffensive* release_helios_basic_offensive();
  ::protos::HeliosBasicOffensive* mutable_helios_basic_offensive();
  void set_allocated_helios_basic_offensive(::protos::HeliosBasicOffensive* value);
  void unsafe_arena_set_allocated_helios_basic_offensive(::protos::HeliosBasicOffensive* value);
  ::protos::HeliosBasicOffensive* unsafe_arena_release_helios_basic_offensive();

  private:
  const ::protos::HeliosBasicOffensive& _internal_helios_basic_offensive() const;
  ::protos::HeliosBasicOffensive* _internal_mutable_helios_basic_offensive();

  public:
  // .protos.HeliosBasicMove helios_basic_move = 61;
  bool has_helios_basic_move() const;
  private:
  bool _internal_has_helios_basic_move() const;

  public:
  void clear_helios_basic_move() ;
  const ::protos::HeliosBasicMove& helios_basic_move() const;
  PROTOBUF_NODISCARD ::protos::HeliosBasicMove* release_helios_basic_move();
  ::protos::HeliosBasicMove* mutable_helios_basic_move();
  void set_allocated_helios_basic_move(::protos::HeliosBasicMove* value);
  void unsafe_arena_set_allocated_helios_basic_move(::protos::HeliosBasicMove* value);
  ::protos::HeliosBasicMove* unsafe_arena_release_helios_basic_move();

  private:
  const ::protos::HeliosBasicMove& _internal_helios_basic_move() const;
  ::protos::HeliosBasicMove* _internal_mutable_helios_basic_move();

  public:
  // .protos.HeliosSetPlay helios_set_play = 62;
  bool has_helios_set_play() const;
  private:
  bool _internal_has_helios_set_play() const;

  public:
  void clear_helios_set_play() ;
  const ::protos::HeliosSetPlay& helios_set_play() const;
  PROTOBUF_NODISCARD ::protos::HeliosSetPlay* release_helios_set_play();
  ::protos::HeliosSetPlay* mutable_helios_set_play();
  void set_allocated_helios_set_play(::protos::HeliosSetPlay* value);
  void unsafe_arena_set_allocated_helios_set_play(::protos::HeliosSetPlay* value);
  ::protos::HeliosSetPlay* unsafe_arena_release_helios_set_play();

  private:
  const ::protos::HeliosSetPlay& _internal_helios_set_play() const;
  ::protos::HeliosSetPlay* _internal_mutable_helios_set_play();

  public:
  // .protos.HeliosPenalty helios_penalty = 63;
  bool has_helios_penalty() const;
  private:
  bool _internal_has_helios_penalty() const;

  public:
  void clear_helios_penalty() ;
  const ::protos::HeliosPenalty& helios_penalty() const;
  PROTOBUF_NODISCARD ::protos::HeliosPenalty* release_helios_penalty();
  ::protos::HeliosPenalty* mutable_helios_penalty();
  void set_allocated_helios_penalty(::protos::HeliosPenalty* value);
  void unsafe_arena_set_allocated_helios_penalty(::protos::HeliosPenalty* value);
  ::protos::HeliosPenalty* unsafe_arena_release_helios_penalty();

  private:
  const ::protos::HeliosPenalty& _internal_helios_penalty() const;
  ::protos::HeliosPenalty* _internal_mutable_helios_penalty();

  public:
  // .protos.HeliosCommunicaion helios_communication = 64;
  bool has_helios_communication() const;
  private:
  bool _internal_has_helios_communication() const;

  public:
  void clear_helios_communication() ;
  const ::protos::HeliosCommunicaion& helios_communication() const;
  PROTOBUF_NODISCARD ::protos::HeliosCommunicaion* release_helios_communication();
  ::protos::HeliosCommunicaion* mutable_helios_communication();
  void set_allocated_helios_communication(::protos::HeliosCommunicaion* value);
  void unsafe_arena_set_allocated_helios_communication(::protos::HeliosCommunicaion* value);
  ::protos::HeliosCommunicaion* unsafe_arena_release_helios_communication();

  private:
  const ::protos::HeliosCommunicaion& _internal_helios_communication() const;
  ::protos::HeliosCommunicaion* _internal_mutable_helios_communication();

  public:
  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:protos.PlayerAction)
 private:
  class _Internal;
  void set_has_dash();
  void set_has_turn();
  void set_has_kick();
  void set_has_tackle();
  void set_has_catch_();
  void set_has_move();
  void set_has_turn_neck();
  void set_has_change_view();
  void set_has_say();
  void set_has_point_to();
  void set_has_point_to_of();
  void set_has_attention_to();
  void set_has_attention_to_of();
  void set_has_log();
  void set_has_debug_client();
  void set_has_body_go_to_point();
  void set_has_body_smart_kick();
  void set_has_bhv_before_kick_off();
  void set_has_bhv_body_neck_to_ball();
  void set_has_bhv_body_neck_to_point();
  void set_has_bhv_emergency();
  void set_has_bhv_go_to_point_look_ball();
  void set_has_bhv_neck_body_to_ball();
  void set_has_bhv_neck_body_to_point();
  void set_has_bhv_scan_field();
  void set_has_body_advance_ball();
  void set_has_body_clear_ball();
  void set_has_body_dribble();
  void set_has_body_go_to_point_dodge();
  void set_has_body_hold_ball();
  void set_has_body_intercept();
  void set_has_body_kick_one_step();
  void set_has_body_stop_ball();
  void set_has_body_stop_dash();
  void set_has_body_tackle_to_point();
  void set_has_body_turn_to_angle();
  void set_has_body_turn_to_ball();
  void set_has_body_turn_to_point();
  void set_has_focus_move_to_point();
  void set_has_focus_reset();
  void set_has_neck_scan_field();
  void set_has_neck_scan_players();
  void set_has_neck_turn_to_ball_and_player();
  void set_has_neck_turn_to_ball_or_scan();
  void set_has_neck_turn_to_ball();
  void set_has_neck_turn_to_goalie_or_scan();
  void set_has_neck_turn_to_low_conf_teammate();
  void set_has_neck_turn_to_player_or_scan();
  void set_has_neck_turn_to_point();
  void set_has_neck_turn_to_relative();
  void set_has_view_change_width();
  void set_has_view_normal();
  void set_has_view_synch();
  void set_has_view_wide();
  void set_has_helios_goalie();
  void set_has_helios_goalie_move();
  void set_has_helios_goalie_kick();
  void set_has_helios_shoot();
  void set_has_helios_chain_action();
  void set_has_helios_basic_offensive();
  void set_has_helios_basic_move();
  void set_has_helios_set_play();
  void set_has_helios_penalty();
  void set_has_helios_communication();

  inline bool has_action() const;
  inline void clear_has_action();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 64, 64,
      0, 9>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::protos::Dash* dash_;
      ::protos::Turn* turn_;
      ::protos::Kick* kick_;
      ::protos::Tackle* tackle_;
      ::protos::Catch* catch__;
      ::protos::Move* move_;
      ::protos::TurnNeck* turn_neck_;
      ::protos::ChangeView* change_view_;
      ::protos::Say* say_;
      ::protos::PointTo* point_to_;
      ::protos::PointToOf* point_to_of_;
      ::protos::AttentionTo* attention_to_;
      ::protos::AttentionToOf* attention_to_of_;
      ::protos::Log* log_;
      ::protos::DebugClient* debug_client_;
      ::protos::Body_GoToPoint* body_go_to_point_;
      ::protos::Body_SmartKick* body_smart_kick_;
      ::protos::Bhv_BeforeKickOff* bhv_before_kick_off_;
      ::protos::Bhv_BodyNeckToBall* bhv_body_neck_to_ball_;
      ::protos::Bhv_BodyNeckToPoint* bhv_body_neck_to_point_;
      ::protos::Bhv_Emergency* bhv_emergency_;
      ::protos::Bhv_GoToPointLookBall* bhv_go_to_point_look_ball_;
      ::protos::Bhv_NeckBodyToBall* bhv_neck_body_to_ball_;
      ::protos::Bhv_NeckBodyToPoint* bhv_neck_body_to_point_;
      ::protos::Bhv_ScanField* bhv_scan_field_;
      ::protos::Body_AdvanceBall* body_advance_ball_;
      ::protos::Body_ClearBall* body_clear_ball_;
      ::protos::Body_Dribble* body_dribble_;
      ::protos::Body_GoToPointDodge* body_go_to_point_dodge_;
      ::protos::Body_HoldBall* body_hold_ball_;
      ::protos::Body_Intercept* body_intercept_;
      ::protos::Body_KickOneStep* body_kick_one_step_;
      ::protos::Body_StopBall* body_stop_ball_;
      ::protos::Body_StopDash* body_stop_dash_;
      ::protos::Body_TackleToPoint* body_tackle_to_point_;
      ::protos::Body_TurnToAngle* body_turn_to_angle_;
      ::protos::Body_TurnToBall* body_turn_to_ball_;
      ::protos::Body_TurnToPoint* body_turn_to_point_;
      ::protos::Focus_MoveToPoint* focus_move_to_point_;
      ::protos::Focus_Reset* focus_reset_;
      ::protos::Neck_ScanField* neck_scan_field_;
      ::protos::Neck_ScanPlayers* neck_scan_players_;
      ::protos::Neck_TurnToBallAndPlayer* neck_turn_to_ball_and_player_;
      ::protos::Neck_TurnToBallOrScan* neck_turn_to_ball_or_scan_;
      ::protos::Neck_TurnToBall* neck_turn_to_ball_;
      ::protos::Neck_TurnToGoalieOrScan* neck_turn_to_goalie_or_scan_;
      ::protos::Neck_TurnToLowConfTeammate* neck_turn_to_low_conf_teammate_;
      ::protos::Neck_TurnToPlayerOrScan* neck_turn_to_player_or_scan_;
      ::protos::Neck_TurnToPoint* neck_turn_to_point_;
      ::protos::Neck_TurnToRelative* neck_turn_to_relative_;
      ::protos::View_ChangeWidth* view_change_width_;
      ::protos::View_Normal* view_normal_;
      ::protos::View_Synch* view_synch_;
      ::protos::View_Wide* view_wide_;
      ::protos::HeliosGoalie* helios_goalie_;
      ::protos::HeliosGoalieMove* helios_goalie_move_;
      ::protos::HeliosGoalieKick* helios_goalie_kick_;
      ::protos::HeliosShoot* helios_shoot_;
      ::protos::HeliosChainAction* helios_chain_action_;
      ::protos::HeliosBasicOffensive* helios_basic_offensive_;
      ::protos::HeliosBasicMove* helios_basic_move_;
      ::protos::HeliosSetPlay* helios_set_play_;
      ::protos::HeliosPenalty* helios_penalty_;
      ::protos::HeliosCommunicaion* helios_communication_;
    } action_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class State final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.State) */ {
 public:
  inline State() : State(nullptr) {}
  ~State() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR State(::google::protobuf::internal::ConstantInitialized);

  inline State(const State& from)
      : State(nullptr, from) {}
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  inline State& operator=(State&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const State& default_instance() {
    return *internal_default_instance();
  }
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }
  inline void Swap(State* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  State* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<State>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const State& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const State& from) {
    State::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(State* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.State";
  }
  protected:
  explicit State(::google::protobuf::Arena* arena);
  State(::google::protobuf::Arena* arena, const State& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldModelFieldNumber = 2,
    kFullWorldModelFieldNumber = 3,
    kAgentTypeFieldNumber = 1,
  };
  // .protos.WorldModel world_model = 2;
  bool has_world_model() const;
  void clear_world_model() ;
  const ::protos::WorldModel& world_model() const;
  PROTOBUF_NODISCARD ::protos::WorldModel* release_world_model();
  ::protos::WorldModel* mutable_world_model();
  void set_allocated_world_model(::protos::WorldModel* value);
  void unsafe_arena_set_allocated_world_model(::protos::WorldModel* value);
  ::protos::WorldModel* unsafe_arena_release_world_model();

  private:
  const ::protos::WorldModel& _internal_world_model() const;
  ::protos::WorldModel* _internal_mutable_world_model();

  public:
  // .protos.WorldModel full_world_model = 3;
  bool has_full_world_model() const;
  void clear_full_world_model() ;
  const ::protos::WorldModel& full_world_model() const;
  PROTOBUF_NODISCARD ::protos::WorldModel* release_full_world_model();
  ::protos::WorldModel* mutable_full_world_model();
  void set_allocated_full_world_model(::protos::WorldModel* value);
  void unsafe_arena_set_allocated_full_world_model(::protos::WorldModel* value);
  ::protos::WorldModel* unsafe_arena_release_full_world_model();

  private:
  const ::protos::WorldModel& _internal_full_world_model() const;
  ::protos::WorldModel* _internal_mutable_full_world_model();

  public:
  // .protos.AgentType agent_type = 1;
  void clear_agent_type() ;
  ::protos::AgentType agent_type() const;
  void set_agent_type(::protos::AgentType value);

  private:
  ::protos::AgentType _internal_agent_type() const;
  void _internal_set_agent_type(::protos::AgentType value);

  public:
  // @@protoc_insertion_point(class_scope:protos.State)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::protos::WorldModel* world_model_;
    ::protos::WorldModel* full_world_model_;
    int agent_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};// -------------------------------------------------------------------

class PlayerActions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protos.PlayerActions) */ {
 public:
  inline PlayerActions() : PlayerActions(nullptr) {}
  ~PlayerActions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerActions(::google::protobuf::internal::ConstantInitialized);

  inline PlayerActions(const PlayerActions& from)
      : PlayerActions(nullptr, from) {}
  PlayerActions(PlayerActions&& from) noexcept
    : PlayerActions() {
    *this = ::std::move(from);
  }

  inline PlayerActions& operator=(const PlayerActions& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerActions& operator=(PlayerActions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerActions& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerActions* internal_default_instance() {
    return reinterpret_cast<const PlayerActions*>(
               &_PlayerActions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(PlayerActions& a, PlayerActions& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerActions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerActions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerActions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerActions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerActions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerActions& from) {
    PlayerActions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerActions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "protos.PlayerActions";
  }
  protected:
  explicit PlayerActions(::google::protobuf::Arena* arena);
  PlayerActions(::google::protobuf::Arena* arena, const PlayerActions& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
  };
  // repeated .protos.PlayerAction actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;

  public:
  void clear_actions() ;
  ::protos::PlayerAction* mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::protos::PlayerAction >*
      mutable_actions();
  private:
  const ::google::protobuf::RepeatedPtrField<::protos::PlayerAction>& _internal_actions() const;
  ::google::protobuf::RepeatedPtrField<::protos::PlayerAction>* _internal_mutable_actions();
  public:
  const ::protos::PlayerAction& actions(int index) const;
  ::protos::PlayerAction* add_actions();
  const ::google::protobuf::RepeatedPtrField< ::protos::PlayerAction >&
      actions() const;
  // @@protoc_insertion_point(class_scope:protos.PlayerActions)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::protos::PlayerAction > actions_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector2D

// float x = 1;
inline void Vector2D::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline float Vector2D::x() const {
  // @@protoc_insertion_point(field_get:protos.Vector2D.x)
  return _internal_x();
}
inline void Vector2D::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:protos.Vector2D.x)
}
inline float Vector2D::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Vector2D::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector2D::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float Vector2D::y() const {
  // @@protoc_insertion_point(field_get:protos.Vector2D.y)
  return _internal_y();
}
inline void Vector2D::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:protos.Vector2D.y)
}
inline float Vector2D::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Vector2D::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// float dist = 3;
inline void Vector2D::clear_dist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dist_ = 0;
}
inline float Vector2D::dist() const {
  // @@protoc_insertion_point(field_get:protos.Vector2D.dist)
  return _internal_dist();
}
inline void Vector2D::set_dist(float value) {
  _internal_set_dist(value);
  // @@protoc_insertion_point(field_set:protos.Vector2D.dist)
}
inline float Vector2D::_internal_dist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dist_;
}
inline void Vector2D::_internal_set_dist(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dist_ = value;
}

// float angle = 4;
inline void Vector2D::clear_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_ = 0;
}
inline float Vector2D::angle() const {
  // @@protoc_insertion_point(field_get:protos.Vector2D.angle)
  return _internal_angle();
}
inline void Vector2D::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:protos.Vector2D.angle)
}
inline float Vector2D::_internal_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angle_;
}
inline void Vector2D::_internal_set_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// Ball

// .protos.Vector2D position = 1;
inline bool Ball::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Ball::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Ball::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Ball.position)
  return _internal_position();
}
inline void Ball::unsafe_arena_set_allocated_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.position)
}
inline ::protos::Vector2D* Ball::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Ball.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* Ball::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.Ball.position)
  return _msg;
}
inline void Ball::set_allocated_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.position)
}

// .protos.Vector2D relative_position = 2;
inline bool Ball::has_relative_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relative_position_ != nullptr);
  return value;
}
inline void Ball::clear_relative_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.relative_position_ != nullptr) _impl_.relative_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& Ball::_internal_relative_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.relative_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::relative_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Ball.relative_position)
  return _internal_relative_position();
}
inline void Ball::unsafe_arena_set_allocated_relative_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relative_position_);
  }
  _impl_.relative_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.relative_position)
}
inline ::protos::Vector2D* Ball::release_relative_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.relative_position_;
  _impl_.relative_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_relative_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Ball.relative_position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.relative_position_;
  _impl_.relative_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_relative_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.relative_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.relative_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.relative_position_;
}
inline ::protos::Vector2D* Ball::mutable_relative_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_relative_position();
  // @@protoc_insertion_point(field_mutable:protos.Ball.relative_position)
  return _msg;
}
inline void Ball::set_allocated_relative_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.relative_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.relative_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.relative_position)
}

// .protos.Vector2D seen_position = 3;
inline bool Ball::has_seen_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_position_ != nullptr);
  return value;
}
inline void Ball::clear_seen_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.seen_position_ != nullptr) _impl_.seen_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& Ball::_internal_seen_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.seen_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::seen_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Ball.seen_position)
  return _internal_seen_position();
}
inline void Ball::unsafe_arena_set_allocated_seen_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.seen_position_);
  }
  _impl_.seen_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.seen_position)
}
inline ::protos::Vector2D* Ball::release_seen_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* released = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_seen_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Ball.seen_position)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_seen_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.seen_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.seen_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.seen_position_;
}
inline ::protos::Vector2D* Ball::mutable_seen_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_seen_position();
  // @@protoc_insertion_point(field_mutable:protos.Ball.seen_position)
  return _msg;
}
inline void Ball::set_allocated_seen_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.seen_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.seen_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.seen_position)
}

// .protos.Vector2D heard_position = 4;
inline bool Ball::has_heard_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heard_position_ != nullptr);
  return value;
}
inline void Ball::clear_heard_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.heard_position_ != nullptr) _impl_.heard_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::protos::Vector2D& Ball::_internal_heard_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.heard_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::heard_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Ball.heard_position)
  return _internal_heard_position();
}
inline void Ball::unsafe_arena_set_allocated_heard_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.heard_position_);
  }
  _impl_.heard_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.heard_position)
}
inline ::protos::Vector2D* Ball::release_heard_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* released = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_heard_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Ball.heard_position)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_heard_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.heard_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.heard_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.heard_position_;
}
inline ::protos::Vector2D* Ball::mutable_heard_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_heard_position();
  // @@protoc_insertion_point(field_mutable:protos.Ball.heard_position)
  return _msg;
}
inline void Ball::set_allocated_heard_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.heard_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.heard_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.heard_position)
}

// .protos.Vector2D velocity = 5;
inline bool Ball::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void Ball::clear_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::protos::Vector2D& Ball::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Ball.velocity)
  return _internal_velocity();
}
inline void Ball::unsafe_arena_set_allocated_velocity(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.velocity)
}
inline ::protos::Vector2D* Ball::release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Ball.velocity)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.velocity_;
}
inline ::protos::Vector2D* Ball::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Ball.velocity)
  return _msg;
}
inline void Ball::set_allocated_velocity(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.velocity)
}

// .protos.Vector2D seen_velocity = 6;
inline bool Ball::has_seen_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_velocity_ != nullptr);
  return value;
}
inline void Ball::clear_seen_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.seen_velocity_ != nullptr) _impl_.seen_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::protos::Vector2D& Ball::_internal_seen_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.seen_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::seen_velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Ball.seen_velocity)
  return _internal_seen_velocity();
}
inline void Ball::unsafe_arena_set_allocated_seen_velocity(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.seen_velocity_);
  }
  _impl_.seen_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.seen_velocity)
}
inline ::protos::Vector2D* Ball::release_seen_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::protos::Vector2D* released = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_seen_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Ball.seen_velocity)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_seen_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.seen_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.seen_velocity_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.seen_velocity_;
}
inline ::protos::Vector2D* Ball::mutable_seen_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_seen_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Ball.seen_velocity)
  return _msg;
}
inline void Ball::set_allocated_seen_velocity(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.seen_velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.seen_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.seen_velocity)
}

// .protos.Vector2D heard_velocity = 7;
inline bool Ball::has_heard_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heard_velocity_ != nullptr);
  return value;
}
inline void Ball::clear_heard_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.heard_velocity_ != nullptr) _impl_.heard_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::protos::Vector2D& Ball::_internal_heard_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.heard_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Ball::heard_velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Ball.heard_velocity)
  return _internal_heard_velocity();
}
inline void Ball::unsafe_arena_set_allocated_heard_velocity(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.heard_velocity_);
  }
  _impl_.heard_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Ball.heard_velocity)
}
inline ::protos::Vector2D* Ball::release_heard_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::protos::Vector2D* released = _impl_.heard_velocity_;
  _impl_.heard_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Ball::unsafe_arena_release_heard_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Ball.heard_velocity)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::protos::Vector2D* temp = _impl_.heard_velocity_;
  _impl_.heard_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Ball::_internal_mutable_heard_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.heard_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.heard_velocity_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.heard_velocity_;
}
inline ::protos::Vector2D* Ball::mutable_heard_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_heard_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Ball.heard_velocity)
  return _msg;
}
inline void Ball::set_allocated_heard_velocity(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.heard_velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.heard_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Ball.heard_velocity)
}

// int32 pos_count = 8;
inline void Ball::clear_pos_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_count_ = 0;
}
inline ::int32_t Ball::pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.pos_count)
  return _internal_pos_count();
}
inline void Ball::set_pos_count(::int32_t value) {
  _internal_set_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.pos_count)
}
inline ::int32_t Ball::_internal_pos_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pos_count_;
}
inline void Ball::_internal_set_pos_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pos_count_ = value;
}

// int32 seen_pos_count = 9;
inline void Ball::clear_seen_pos_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seen_pos_count_ = 0;
}
inline ::int32_t Ball::seen_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.seen_pos_count)
  return _internal_seen_pos_count();
}
inline void Ball::set_seen_pos_count(::int32_t value) {
  _internal_set_seen_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.seen_pos_count)
}
inline ::int32_t Ball::_internal_seen_pos_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seen_pos_count_;
}
inline void Ball::_internal_set_seen_pos_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seen_pos_count_ = value;
}

// int32 heard_pos_count = 10;
inline void Ball::clear_heard_pos_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heard_pos_count_ = 0;
}
inline ::int32_t Ball::heard_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.heard_pos_count)
  return _internal_heard_pos_count();
}
inline void Ball::set_heard_pos_count(::int32_t value) {
  _internal_set_heard_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.heard_pos_count)
}
inline ::int32_t Ball::_internal_heard_pos_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heard_pos_count_;
}
inline void Ball::_internal_set_heard_pos_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.heard_pos_count_ = value;
}

// int32 vel_count = 11;
inline void Ball::clear_vel_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vel_count_ = 0;
}
inline ::int32_t Ball::vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.vel_count)
  return _internal_vel_count();
}
inline void Ball::set_vel_count(::int32_t value) {
  _internal_set_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.vel_count)
}
inline ::int32_t Ball::_internal_vel_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vel_count_;
}
inline void Ball::_internal_set_vel_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vel_count_ = value;
}

// int32 seen_vel_count = 12;
inline void Ball::clear_seen_vel_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seen_vel_count_ = 0;
}
inline ::int32_t Ball::seen_vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.seen_vel_count)
  return _internal_seen_vel_count();
}
inline void Ball::set_seen_vel_count(::int32_t value) {
  _internal_set_seen_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.seen_vel_count)
}
inline ::int32_t Ball::_internal_seen_vel_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seen_vel_count_;
}
inline void Ball::_internal_set_seen_vel_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seen_vel_count_ = value;
}

// int32 heard_vel_count = 13;
inline void Ball::clear_heard_vel_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heard_vel_count_ = 0;
}
inline ::int32_t Ball::heard_vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.heard_vel_count)
  return _internal_heard_vel_count();
}
inline void Ball::set_heard_vel_count(::int32_t value) {
  _internal_set_heard_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.heard_vel_count)
}
inline ::int32_t Ball::_internal_heard_vel_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heard_vel_count_;
}
inline void Ball::_internal_set_heard_vel_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.heard_vel_count_ = value;
}

// int32 lost_count = 14;
inline void Ball::clear_lost_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lost_count_ = 0;
}
inline ::int32_t Ball::lost_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.lost_count)
  return _internal_lost_count();
}
inline void Ball::set_lost_count(::int32_t value) {
  _internal_set_lost_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.lost_count)
}
inline ::int32_t Ball::_internal_lost_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lost_count_;
}
inline void Ball::_internal_set_lost_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lost_count_ = value;
}

// int32 ghost_count = 15;
inline void Ball::clear_ghost_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ghost_count_ = 0;
}
inline ::int32_t Ball::ghost_count() const {
  // @@protoc_insertion_point(field_get:protos.Ball.ghost_count)
  return _internal_ghost_count();
}
inline void Ball::set_ghost_count(::int32_t value) {
  _internal_set_ghost_count(value);
  // @@protoc_insertion_point(field_set:protos.Ball.ghost_count)
}
inline ::int32_t Ball::_internal_ghost_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ghost_count_;
}
inline void Ball::_internal_set_ghost_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ghost_count_ = value;
}

// float dist_from_self = 16;
inline void Ball::clear_dist_from_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dist_from_self_ = 0;
}
inline float Ball::dist_from_self() const {
  // @@protoc_insertion_point(field_get:protos.Ball.dist_from_self)
  return _internal_dist_from_self();
}
inline void Ball::set_dist_from_self(float value) {
  _internal_set_dist_from_self(value);
  // @@protoc_insertion_point(field_set:protos.Ball.dist_from_self)
}
inline float Ball::_internal_dist_from_self() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dist_from_self_;
}
inline void Ball::_internal_set_dist_from_self(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dist_from_self_ = value;
}

// float angle_from_self = 17;
inline void Ball::clear_angle_from_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_from_self_ = 0;
}
inline float Ball::angle_from_self() const {
  // @@protoc_insertion_point(field_get:protos.Ball.angle_from_self)
  return _internal_angle_from_self();
}
inline void Ball::set_angle_from_self(float value) {
  _internal_set_angle_from_self(value);
  // @@protoc_insertion_point(field_set:protos.Ball.angle_from_self)
}
inline float Ball::_internal_angle_from_self() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angle_from_self_;
}
inline void Ball::_internal_set_angle_from_self(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.angle_from_self_ = value;
}

// -------------------------------------------------------------------

// Player

// .protos.Vector2D position = 1;
inline bool Player::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Player::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Player::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Player.position)
  return _internal_position();
}
inline void Player::unsafe_arena_set_allocated_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.position)
}
inline ::protos::Vector2D* Player::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Player.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* Player::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.Player.position)
  return _msg;
}
inline void Player::set_allocated_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Player.position)
}

// .protos.Vector2D seen_position = 2;
inline bool Player::has_seen_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_position_ != nullptr);
  return value;
}
inline void Player::clear_seen_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.seen_position_ != nullptr) _impl_.seen_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& Player::_internal_seen_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.seen_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::seen_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Player.seen_position)
  return _internal_seen_position();
}
inline void Player::unsafe_arena_set_allocated_seen_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.seen_position_);
  }
  _impl_.seen_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.seen_position)
}
inline ::protos::Vector2D* Player::release_seen_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_seen_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Player.seen_position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_seen_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.seen_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.seen_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.seen_position_;
}
inline ::protos::Vector2D* Player::mutable_seen_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_seen_position();
  // @@protoc_insertion_point(field_mutable:protos.Player.seen_position)
  return _msg;
}
inline void Player::set_allocated_seen_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.seen_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.seen_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Player.seen_position)
}

// .protos.Vector2D heard_position = 3;
inline bool Player::has_heard_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heard_position_ != nullptr);
  return value;
}
inline void Player::clear_heard_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.heard_position_ != nullptr) _impl_.heard_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& Player::_internal_heard_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.heard_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::heard_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Player.heard_position)
  return _internal_heard_position();
}
inline void Player::unsafe_arena_set_allocated_heard_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.heard_position_);
  }
  _impl_.heard_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.heard_position)
}
inline ::protos::Vector2D* Player::release_heard_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* released = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_heard_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Player.heard_position)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_heard_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.heard_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.heard_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.heard_position_;
}
inline ::protos::Vector2D* Player::mutable_heard_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_heard_position();
  // @@protoc_insertion_point(field_mutable:protos.Player.heard_position)
  return _msg;
}
inline void Player::set_allocated_heard_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.heard_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.heard_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Player.heard_position)
}

// .protos.Vector2D velocity = 4;
inline bool Player::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void Player::clear_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::protos::Vector2D& Player::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Player.velocity)
  return _internal_velocity();
}
inline void Player::unsafe_arena_set_allocated_velocity(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.velocity)
}
inline ::protos::Vector2D* Player::release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Player.velocity)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.velocity_;
}
inline ::protos::Vector2D* Player::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Player.velocity)
  return _msg;
}
inline void Player::set_allocated_velocity(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Player.velocity)
}

// .protos.Vector2D seen_velocity = 5;
inline bool Player::has_seen_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_velocity_ != nullptr);
  return value;
}
inline void Player::clear_seen_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.seen_velocity_ != nullptr) _impl_.seen_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::protos::Vector2D& Player::_internal_seen_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.seen_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Player::seen_velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Player.seen_velocity)
  return _internal_seen_velocity();
}
inline void Player::unsafe_arena_set_allocated_seen_velocity(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.seen_velocity_);
  }
  _impl_.seen_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Player.seen_velocity)
}
inline ::protos::Vector2D* Player::release_seen_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* released = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Player::unsafe_arena_release_seen_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Player.seen_velocity)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Player::_internal_mutable_seen_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.seen_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.seen_velocity_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.seen_velocity_;
}
inline ::protos::Vector2D* Player::mutable_seen_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_seen_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Player.seen_velocity)
  return _msg;
}
inline void Player::set_allocated_seen_velocity(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.seen_velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.seen_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Player.seen_velocity)
}

// int32 pos_count = 6;
inline void Player::clear_pos_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_count_ = 0;
}
inline ::int32_t Player::pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.pos_count)
  return _internal_pos_count();
}
inline void Player::set_pos_count(::int32_t value) {
  _internal_set_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.pos_count)
}
inline ::int32_t Player::_internal_pos_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pos_count_;
}
inline void Player::_internal_set_pos_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pos_count_ = value;
}

// int32 seen_pos_count = 7;
inline void Player::clear_seen_pos_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seen_pos_count_ = 0;
}
inline ::int32_t Player::seen_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.seen_pos_count)
  return _internal_seen_pos_count();
}
inline void Player::set_seen_pos_count(::int32_t value) {
  _internal_set_seen_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.seen_pos_count)
}
inline ::int32_t Player::_internal_seen_pos_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seen_pos_count_;
}
inline void Player::_internal_set_seen_pos_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seen_pos_count_ = value;
}

// int32 heard_pos_count = 8;
inline void Player::clear_heard_pos_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heard_pos_count_ = 0;
}
inline ::int32_t Player::heard_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.heard_pos_count)
  return _internal_heard_pos_count();
}
inline void Player::set_heard_pos_count(::int32_t value) {
  _internal_set_heard_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.heard_pos_count)
}
inline ::int32_t Player::_internal_heard_pos_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heard_pos_count_;
}
inline void Player::_internal_set_heard_pos_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.heard_pos_count_ = value;
}

// int32 vel_count = 9;
inline void Player::clear_vel_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vel_count_ = 0;
}
inline ::int32_t Player::vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.vel_count)
  return _internal_vel_count();
}
inline void Player::set_vel_count(::int32_t value) {
  _internal_set_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.vel_count)
}
inline ::int32_t Player::_internal_vel_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vel_count_;
}
inline void Player::_internal_set_vel_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vel_count_ = value;
}

// int32 seen_vel_count = 10;
inline void Player::clear_seen_vel_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seen_vel_count_ = 0;
}
inline ::int32_t Player::seen_vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.seen_vel_count)
  return _internal_seen_vel_count();
}
inline void Player::set_seen_vel_count(::int32_t value) {
  _internal_set_seen_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.seen_vel_count)
}
inline ::int32_t Player::_internal_seen_vel_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seen_vel_count_;
}
inline void Player::_internal_set_seen_vel_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seen_vel_count_ = value;
}

// int32 ghost_count = 11;
inline void Player::clear_ghost_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ghost_count_ = 0;
}
inline ::int32_t Player::ghost_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.ghost_count)
  return _internal_ghost_count();
}
inline void Player::set_ghost_count(::int32_t value) {
  _internal_set_ghost_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.ghost_count)
}
inline ::int32_t Player::_internal_ghost_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ghost_count_;
}
inline void Player::_internal_set_ghost_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ghost_count_ = value;
}

// float dist_from_self = 12;
inline void Player::clear_dist_from_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dist_from_self_ = 0;
}
inline float Player::dist_from_self() const {
  // @@protoc_insertion_point(field_get:protos.Player.dist_from_self)
  return _internal_dist_from_self();
}
inline void Player::set_dist_from_self(float value) {
  _internal_set_dist_from_self(value);
  // @@protoc_insertion_point(field_set:protos.Player.dist_from_self)
}
inline float Player::_internal_dist_from_self() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dist_from_self_;
}
inline void Player::_internal_set_dist_from_self(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dist_from_self_ = value;
}

// float angle_from_self = 13;
inline void Player::clear_angle_from_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_from_self_ = 0;
}
inline float Player::angle_from_self() const {
  // @@protoc_insertion_point(field_get:protos.Player.angle_from_self)
  return _internal_angle_from_self();
}
inline void Player::set_angle_from_self(float value) {
  _internal_set_angle_from_self(value);
  // @@protoc_insertion_point(field_set:protos.Player.angle_from_self)
}
inline float Player::_internal_angle_from_self() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angle_from_self_;
}
inline void Player::_internal_set_angle_from_self(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.angle_from_self_ = value;
}

// int32 id = 14;
inline void Player::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t Player::id() const {
  // @@protoc_insertion_point(field_get:protos.Player.id)
  return _internal_id();
}
inline void Player::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:protos.Player.id)
}
inline ::int32_t Player::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Player::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// .protos.Side side = 15;
inline void Player::clear_side() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_ = 0;
}
inline ::protos::Side Player::side() const {
  // @@protoc_insertion_point(field_get:protos.Player.side)
  return _internal_side();
}
inline void Player::set_side(::protos::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.Player.side)
}
inline ::protos::Side Player::_internal_side() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void Player::_internal_set_side(::protos::Side value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.side_ = value;
}

// int32 uniform_number = 16;
inline void Player::clear_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_ = 0;
}
inline ::int32_t Player::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.Player.uniform_number)
  return _internal_uniform_number();
}
inline void Player::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.Player.uniform_number)
}
inline ::int32_t Player::_internal_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_;
}
inline void Player::_internal_set_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_ = value;
}

// int32 uniform_number_count = 17;
inline void Player::clear_uniform_number_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_count_ = 0;
}
inline ::int32_t Player::uniform_number_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.uniform_number_count)
  return _internal_uniform_number_count();
}
inline void Player::set_uniform_number_count(::int32_t value) {
  _internal_set_uniform_number_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.uniform_number_count)
}
inline ::int32_t Player::_internal_uniform_number_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_count_;
}
inline void Player::_internal_set_uniform_number_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_count_ = value;
}

// bool is_goalie = 18;
inline void Player::clear_is_goalie() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_goalie_ = false;
}
inline bool Player::is_goalie() const {
  // @@protoc_insertion_point(field_get:protos.Player.is_goalie)
  return _internal_is_goalie();
}
inline void Player::set_is_goalie(bool value) {
  _internal_set_is_goalie(value);
  // @@protoc_insertion_point(field_set:protos.Player.is_goalie)
}
inline bool Player::_internal_is_goalie() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_goalie_;
}
inline void Player::_internal_set_is_goalie(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_goalie_ = value;
}

// float body_direction = 19;
inline void Player::clear_body_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_direction_ = 0;
}
inline float Player::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.Player.body_direction)
  return _internal_body_direction();
}
inline void Player::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.Player.body_direction)
}
inline float Player::_internal_body_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_direction_;
}
inline void Player::_internal_set_body_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.body_direction_ = value;
}

// int32 body_direction_count = 20;
inline void Player::clear_body_direction_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_direction_count_ = 0;
}
inline ::int32_t Player::body_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.body_direction_count)
  return _internal_body_direction_count();
}
inline void Player::set_body_direction_count(::int32_t value) {
  _internal_set_body_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.body_direction_count)
}
inline ::int32_t Player::_internal_body_direction_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_direction_count_;
}
inline void Player::_internal_set_body_direction_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.body_direction_count_ = value;
}

// float face_direction = 21;
inline void Player::clear_face_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.face_direction_ = 0;
}
inline float Player::face_direction() const {
  // @@protoc_insertion_point(field_get:protos.Player.face_direction)
  return _internal_face_direction();
}
inline void Player::set_face_direction(float value) {
  _internal_set_face_direction(value);
  // @@protoc_insertion_point(field_set:protos.Player.face_direction)
}
inline float Player::_internal_face_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.face_direction_;
}
inline void Player::_internal_set_face_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.face_direction_ = value;
}

// int32 face_direction_count = 22;
inline void Player::clear_face_direction_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.face_direction_count_ = 0;
}
inline ::int32_t Player::face_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.face_direction_count)
  return _internal_face_direction_count();
}
inline void Player::set_face_direction_count(::int32_t value) {
  _internal_set_face_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.face_direction_count)
}
inline ::int32_t Player::_internal_face_direction_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.face_direction_count_;
}
inline void Player::_internal_set_face_direction_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.face_direction_count_ = value;
}

// float point_to_direction = 23;
inline void Player::clear_point_to_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.point_to_direction_ = 0;
}
inline float Player::point_to_direction() const {
  // @@protoc_insertion_point(field_get:protos.Player.point_to_direction)
  return _internal_point_to_direction();
}
inline void Player::set_point_to_direction(float value) {
  _internal_set_point_to_direction(value);
  // @@protoc_insertion_point(field_set:protos.Player.point_to_direction)
}
inline float Player::_internal_point_to_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.point_to_direction_;
}
inline void Player::_internal_set_point_to_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.point_to_direction_ = value;
}

// int32 point_to_direction_count = 24;
inline void Player::clear_point_to_direction_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.point_to_direction_count_ = 0;
}
inline ::int32_t Player::point_to_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Player.point_to_direction_count)
  return _internal_point_to_direction_count();
}
inline void Player::set_point_to_direction_count(::int32_t value) {
  _internal_set_point_to_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Player.point_to_direction_count)
}
inline ::int32_t Player::_internal_point_to_direction_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.point_to_direction_count_;
}
inline void Player::_internal_set_point_to_direction_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.point_to_direction_count_ = value;
}

// bool is_kicking = 25;
inline void Player::clear_is_kicking() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_kicking_ = false;
}
inline bool Player::is_kicking() const {
  // @@protoc_insertion_point(field_get:protos.Player.is_kicking)
  return _internal_is_kicking();
}
inline void Player::set_is_kicking(bool value) {
  _internal_set_is_kicking(value);
  // @@protoc_insertion_point(field_set:protos.Player.is_kicking)
}
inline bool Player::_internal_is_kicking() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_kicking_;
}
inline void Player::_internal_set_is_kicking(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_kicking_ = value;
}

// float dist_from_ball = 26;
inline void Player::clear_dist_from_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dist_from_ball_ = 0;
}
inline float Player::dist_from_ball() const {
  // @@protoc_insertion_point(field_get:protos.Player.dist_from_ball)
  return _internal_dist_from_ball();
}
inline void Player::set_dist_from_ball(float value) {
  _internal_set_dist_from_ball(value);
  // @@protoc_insertion_point(field_set:protos.Player.dist_from_ball)
}
inline float Player::_internal_dist_from_ball() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dist_from_ball_;
}
inline void Player::_internal_set_dist_from_ball(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dist_from_ball_ = value;
}

// float angle_from_ball = 27;
inline void Player::clear_angle_from_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_from_ball_ = 0;
}
inline float Player::angle_from_ball() const {
  // @@protoc_insertion_point(field_get:protos.Player.angle_from_ball)
  return _internal_angle_from_ball();
}
inline void Player::set_angle_from_ball(float value) {
  _internal_set_angle_from_ball(value);
  // @@protoc_insertion_point(field_set:protos.Player.angle_from_ball)
}
inline float Player::_internal_angle_from_ball() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angle_from_ball_;
}
inline void Player::_internal_set_angle_from_ball(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.angle_from_ball_ = value;
}

// int32 ball_reach_steps = 28;
inline void Player::clear_ball_reach_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ball_reach_steps_ = 0;
}
inline ::int32_t Player::ball_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.Player.ball_reach_steps)
  return _internal_ball_reach_steps();
}
inline void Player::set_ball_reach_steps(::int32_t value) {
  _internal_set_ball_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.Player.ball_reach_steps)
}
inline ::int32_t Player::_internal_ball_reach_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ball_reach_steps_;
}
inline void Player::_internal_set_ball_reach_steps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ball_reach_steps_ = value;
}

// bool is_tackling = 29;
inline void Player::clear_is_tackling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_tackling_ = false;
}
inline bool Player::is_tackling() const {
  // @@protoc_insertion_point(field_get:protos.Player.is_tackling)
  return _internal_is_tackling();
}
inline void Player::set_is_tackling(bool value) {
  _internal_set_is_tackling(value);
  // @@protoc_insertion_point(field_set:protos.Player.is_tackling)
}
inline bool Player::_internal_is_tackling() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_tackling_;
}
inline void Player::_internal_set_is_tackling(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_tackling_ = value;
}

// int32 type_id = 30;
inline void Player::clear_type_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_id_ = 0;
}
inline ::int32_t Player::type_id() const {
  // @@protoc_insertion_point(field_get:protos.Player.type_id)
  return _internal_type_id();
}
inline void Player::set_type_id(::int32_t value) {
  _internal_set_type_id(value);
  // @@protoc_insertion_point(field_set:protos.Player.type_id)
}
inline ::int32_t Player::_internal_type_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_id_;
}
inline void Player::_internal_set_type_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_id_ = value;
}

// -------------------------------------------------------------------

// Self

// .protos.Vector2D position = 1;
inline bool Self::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Self::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Self::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Self.position)
  return _internal_position();
}
inline void Self::unsafe_arena_set_allocated_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.position)
}
inline ::protos::Vector2D* Self::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Self.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* Self::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.Self.position)
  return _msg;
}
inline void Self::set_allocated_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Self.position)
}

// .protos.Vector2D seen_position = 2;
inline bool Self::has_seen_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_position_ != nullptr);
  return value;
}
inline void Self::clear_seen_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.seen_position_ != nullptr) _impl_.seen_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& Self::_internal_seen_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.seen_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::seen_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Self.seen_position)
  return _internal_seen_position();
}
inline void Self::unsafe_arena_set_allocated_seen_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.seen_position_);
  }
  _impl_.seen_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.seen_position)
}
inline ::protos::Vector2D* Self::release_seen_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_seen_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Self.seen_position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.seen_position_;
  _impl_.seen_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_seen_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.seen_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.seen_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.seen_position_;
}
inline ::protos::Vector2D* Self::mutable_seen_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_seen_position();
  // @@protoc_insertion_point(field_mutable:protos.Self.seen_position)
  return _msg;
}
inline void Self::set_allocated_seen_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.seen_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.seen_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Self.seen_position)
}

// .protos.Vector2D heard_position = 3;
inline bool Self::has_heard_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heard_position_ != nullptr);
  return value;
}
inline void Self::clear_heard_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.heard_position_ != nullptr) _impl_.heard_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& Self::_internal_heard_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.heard_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::heard_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Self.heard_position)
  return _internal_heard_position();
}
inline void Self::unsafe_arena_set_allocated_heard_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.heard_position_);
  }
  _impl_.heard_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.heard_position)
}
inline ::protos::Vector2D* Self::release_heard_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* released = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_heard_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Self.heard_position)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.heard_position_;
  _impl_.heard_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_heard_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.heard_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.heard_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.heard_position_;
}
inline ::protos::Vector2D* Self::mutable_heard_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_heard_position();
  // @@protoc_insertion_point(field_mutable:protos.Self.heard_position)
  return _msg;
}
inline void Self::set_allocated_heard_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.heard_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.heard_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Self.heard_position)
}

// .protos.Vector2D velocity = 4;
inline bool Self::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void Self::clear_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::protos::Vector2D& Self::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Self.velocity)
  return _internal_velocity();
}
inline void Self::unsafe_arena_set_allocated_velocity(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.velocity)
}
inline ::protos::Vector2D* Self::release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Self.velocity)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.velocity_;
}
inline ::protos::Vector2D* Self::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Self.velocity)
  return _msg;
}
inline void Self::set_allocated_velocity(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Self.velocity)
}

// .protos.Vector2D seen_velocity = 5;
inline bool Self::has_seen_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seen_velocity_ != nullptr);
  return value;
}
inline void Self::clear_seen_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.seen_velocity_ != nullptr) _impl_.seen_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::protos::Vector2D& Self::_internal_seen_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.seen_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Self::seen_velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Self.seen_velocity)
  return _internal_seen_velocity();
}
inline void Self::unsafe_arena_set_allocated_seen_velocity(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.seen_velocity_);
  }
  _impl_.seen_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Self.seen_velocity)
}
inline ::protos::Vector2D* Self::release_seen_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* released = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Self::unsafe_arena_release_seen_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Self.seen_velocity)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::protos::Vector2D* temp = _impl_.seen_velocity_;
  _impl_.seen_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Self::_internal_mutable_seen_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.seen_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.seen_velocity_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.seen_velocity_;
}
inline ::protos::Vector2D* Self::mutable_seen_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_seen_velocity();
  // @@protoc_insertion_point(field_mutable:protos.Self.seen_velocity)
  return _msg;
}
inline void Self::set_allocated_seen_velocity(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.seen_velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.seen_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Self.seen_velocity)
}

// int32 pos_count = 6;
inline void Self::clear_pos_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_count_ = 0;
}
inline ::int32_t Self::pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.pos_count)
  return _internal_pos_count();
}
inline void Self::set_pos_count(::int32_t value) {
  _internal_set_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.pos_count)
}
inline ::int32_t Self::_internal_pos_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pos_count_;
}
inline void Self::_internal_set_pos_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pos_count_ = value;
}

// int32 seen_pos_count = 7;
inline void Self::clear_seen_pos_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seen_pos_count_ = 0;
}
inline ::int32_t Self::seen_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.seen_pos_count)
  return _internal_seen_pos_count();
}
inline void Self::set_seen_pos_count(::int32_t value) {
  _internal_set_seen_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.seen_pos_count)
}
inline ::int32_t Self::_internal_seen_pos_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seen_pos_count_;
}
inline void Self::_internal_set_seen_pos_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seen_pos_count_ = value;
}

// int32 heard_pos_count = 8;
inline void Self::clear_heard_pos_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heard_pos_count_ = 0;
}
inline ::int32_t Self::heard_pos_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.heard_pos_count)
  return _internal_heard_pos_count();
}
inline void Self::set_heard_pos_count(::int32_t value) {
  _internal_set_heard_pos_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.heard_pos_count)
}
inline ::int32_t Self::_internal_heard_pos_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heard_pos_count_;
}
inline void Self::_internal_set_heard_pos_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.heard_pos_count_ = value;
}

// int32 vel_count = 9;
inline void Self::clear_vel_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vel_count_ = 0;
}
inline ::int32_t Self::vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.vel_count)
  return _internal_vel_count();
}
inline void Self::set_vel_count(::int32_t value) {
  _internal_set_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.vel_count)
}
inline ::int32_t Self::_internal_vel_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vel_count_;
}
inline void Self::_internal_set_vel_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vel_count_ = value;
}

// int32 seen_vel_count = 10;
inline void Self::clear_seen_vel_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seen_vel_count_ = 0;
}
inline ::int32_t Self::seen_vel_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.seen_vel_count)
  return _internal_seen_vel_count();
}
inline void Self::set_seen_vel_count(::int32_t value) {
  _internal_set_seen_vel_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.seen_vel_count)
}
inline ::int32_t Self::_internal_seen_vel_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seen_vel_count_;
}
inline void Self::_internal_set_seen_vel_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seen_vel_count_ = value;
}

// int32 ghost_count = 11;
inline void Self::clear_ghost_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ghost_count_ = 0;
}
inline ::int32_t Self::ghost_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.ghost_count)
  return _internal_ghost_count();
}
inline void Self::set_ghost_count(::int32_t value) {
  _internal_set_ghost_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.ghost_count)
}
inline ::int32_t Self::_internal_ghost_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ghost_count_;
}
inline void Self::_internal_set_ghost_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ghost_count_ = value;
}

// int32 id = 12;
inline void Self::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t Self::id() const {
  // @@protoc_insertion_point(field_get:protos.Self.id)
  return _internal_id();
}
inline void Self::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:protos.Self.id)
}
inline ::int32_t Self::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Self::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// .protos.Side side = 13;
inline void Self::clear_side() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_ = 0;
}
inline ::protos::Side Self::side() const {
  // @@protoc_insertion_point(field_get:protos.Self.side)
  return _internal_side();
}
inline void Self::set_side(::protos::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.Self.side)
}
inline ::protos::Side Self::_internal_side() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void Self::_internal_set_side(::protos::Side value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.side_ = value;
}

// int32 uniform_number = 14;
inline void Self::clear_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_ = 0;
}
inline ::int32_t Self::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.Self.uniform_number)
  return _internal_uniform_number();
}
inline void Self::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.Self.uniform_number)
}
inline ::int32_t Self::_internal_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_;
}
inline void Self::_internal_set_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_ = value;
}

// int32 uniform_number_count = 15;
inline void Self::clear_uniform_number_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_count_ = 0;
}
inline ::int32_t Self::uniform_number_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.uniform_number_count)
  return _internal_uniform_number_count();
}
inline void Self::set_uniform_number_count(::int32_t value) {
  _internal_set_uniform_number_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.uniform_number_count)
}
inline ::int32_t Self::_internal_uniform_number_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_count_;
}
inline void Self::_internal_set_uniform_number_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_count_ = value;
}

// bool is_goalie = 16;
inline void Self::clear_is_goalie() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_goalie_ = false;
}
inline bool Self::is_goalie() const {
  // @@protoc_insertion_point(field_get:protos.Self.is_goalie)
  return _internal_is_goalie();
}
inline void Self::set_is_goalie(bool value) {
  _internal_set_is_goalie(value);
  // @@protoc_insertion_point(field_set:protos.Self.is_goalie)
}
inline bool Self::_internal_is_goalie() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_goalie_;
}
inline void Self::_internal_set_is_goalie(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_goalie_ = value;
}

// float body_direction = 17;
inline void Self::clear_body_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_direction_ = 0;
}
inline float Self::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.Self.body_direction)
  return _internal_body_direction();
}
inline void Self::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.Self.body_direction)
}
inline float Self::_internal_body_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_direction_;
}
inline void Self::_internal_set_body_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.body_direction_ = value;
}

// int32 body_direction_count = 18;
inline void Self::clear_body_direction_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_direction_count_ = 0;
}
inline ::int32_t Self::body_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.body_direction_count)
  return _internal_body_direction_count();
}
inline void Self::set_body_direction_count(::int32_t value) {
  _internal_set_body_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.body_direction_count)
}
inline ::int32_t Self::_internal_body_direction_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_direction_count_;
}
inline void Self::_internal_set_body_direction_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.body_direction_count_ = value;
}

// float face_direction = 19;
inline void Self::clear_face_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.face_direction_ = 0;
}
inline float Self::face_direction() const {
  // @@protoc_insertion_point(field_get:protos.Self.face_direction)
  return _internal_face_direction();
}
inline void Self::set_face_direction(float value) {
  _internal_set_face_direction(value);
  // @@protoc_insertion_point(field_set:protos.Self.face_direction)
}
inline float Self::_internal_face_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.face_direction_;
}
inline void Self::_internal_set_face_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.face_direction_ = value;
}

// int32 face_direction_count = 20;
inline void Self::clear_face_direction_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.face_direction_count_ = 0;
}
inline ::int32_t Self::face_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.face_direction_count)
  return _internal_face_direction_count();
}
inline void Self::set_face_direction_count(::int32_t value) {
  _internal_set_face_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.face_direction_count)
}
inline ::int32_t Self::_internal_face_direction_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.face_direction_count_;
}
inline void Self::_internal_set_face_direction_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.face_direction_count_ = value;
}

// float point_to_direction = 21;
inline void Self::clear_point_to_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.point_to_direction_ = 0;
}
inline float Self::point_to_direction() const {
  // @@protoc_insertion_point(field_get:protos.Self.point_to_direction)
  return _internal_point_to_direction();
}
inline void Self::set_point_to_direction(float value) {
  _internal_set_point_to_direction(value);
  // @@protoc_insertion_point(field_set:protos.Self.point_to_direction)
}
inline float Self::_internal_point_to_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.point_to_direction_;
}
inline void Self::_internal_set_point_to_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.point_to_direction_ = value;
}

// int32 point_to_direction_count = 22;
inline void Self::clear_point_to_direction_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.point_to_direction_count_ = 0;
}
inline ::int32_t Self::point_to_direction_count() const {
  // @@protoc_insertion_point(field_get:protos.Self.point_to_direction_count)
  return _internal_point_to_direction_count();
}
inline void Self::set_point_to_direction_count(::int32_t value) {
  _internal_set_point_to_direction_count(value);
  // @@protoc_insertion_point(field_set:protos.Self.point_to_direction_count)
}
inline ::int32_t Self::_internal_point_to_direction_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.point_to_direction_count_;
}
inline void Self::_internal_set_point_to_direction_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.point_to_direction_count_ = value;
}

// bool is_kicking = 23;
inline void Self::clear_is_kicking() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_kicking_ = false;
}
inline bool Self::is_kicking() const {
  // @@protoc_insertion_point(field_get:protos.Self.is_kicking)
  return _internal_is_kicking();
}
inline void Self::set_is_kicking(bool value) {
  _internal_set_is_kicking(value);
  // @@protoc_insertion_point(field_set:protos.Self.is_kicking)
}
inline bool Self::_internal_is_kicking() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_kicking_;
}
inline void Self::_internal_set_is_kicking(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_kicking_ = value;
}

// float dist_from_ball = 24;
inline void Self::clear_dist_from_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dist_from_ball_ = 0;
}
inline float Self::dist_from_ball() const {
  // @@protoc_insertion_point(field_get:protos.Self.dist_from_ball)
  return _internal_dist_from_ball();
}
inline void Self::set_dist_from_ball(float value) {
  _internal_set_dist_from_ball(value);
  // @@protoc_insertion_point(field_set:protos.Self.dist_from_ball)
}
inline float Self::_internal_dist_from_ball() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dist_from_ball_;
}
inline void Self::_internal_set_dist_from_ball(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dist_from_ball_ = value;
}

// float angle_from_ball = 25;
inline void Self::clear_angle_from_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_from_ball_ = 0;
}
inline float Self::angle_from_ball() const {
  // @@protoc_insertion_point(field_get:protos.Self.angle_from_ball)
  return _internal_angle_from_ball();
}
inline void Self::set_angle_from_ball(float value) {
  _internal_set_angle_from_ball(value);
  // @@protoc_insertion_point(field_set:protos.Self.angle_from_ball)
}
inline float Self::_internal_angle_from_ball() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angle_from_ball_;
}
inline void Self::_internal_set_angle_from_ball(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.angle_from_ball_ = value;
}

// int32 ball_reach_steps = 26;
inline void Self::clear_ball_reach_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ball_reach_steps_ = 0;
}
inline ::int32_t Self::ball_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.Self.ball_reach_steps)
  return _internal_ball_reach_steps();
}
inline void Self::set_ball_reach_steps(::int32_t value) {
  _internal_set_ball_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.Self.ball_reach_steps)
}
inline ::int32_t Self::_internal_ball_reach_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ball_reach_steps_;
}
inline void Self::_internal_set_ball_reach_steps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ball_reach_steps_ = value;
}

// bool is_tackling = 27;
inline void Self::clear_is_tackling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_tackling_ = false;
}
inline bool Self::is_tackling() const {
  // @@protoc_insertion_point(field_get:protos.Self.is_tackling)
  return _internal_is_tackling();
}
inline void Self::set_is_tackling(bool value) {
  _internal_set_is_tackling(value);
  // @@protoc_insertion_point(field_set:protos.Self.is_tackling)
}
inline bool Self::_internal_is_tackling() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_tackling_;
}
inline void Self::_internal_set_is_tackling(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_tackling_ = value;
}

// float relative_neck_direction = 28;
inline void Self::clear_relative_neck_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relative_neck_direction_ = 0;
}
inline float Self::relative_neck_direction() const {
  // @@protoc_insertion_point(field_get:protos.Self.relative_neck_direction)
  return _internal_relative_neck_direction();
}
inline void Self::set_relative_neck_direction(float value) {
  _internal_set_relative_neck_direction(value);
  // @@protoc_insertion_point(field_set:protos.Self.relative_neck_direction)
}
inline float Self::_internal_relative_neck_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.relative_neck_direction_;
}
inline void Self::_internal_set_relative_neck_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.relative_neck_direction_ = value;
}

// float stamina = 29;
inline void Self::clear_stamina() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stamina_ = 0;
}
inline float Self::stamina() const {
  // @@protoc_insertion_point(field_get:protos.Self.stamina)
  return _internal_stamina();
}
inline void Self::set_stamina(float value) {
  _internal_set_stamina(value);
  // @@protoc_insertion_point(field_set:protos.Self.stamina)
}
inline float Self::_internal_stamina() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stamina_;
}
inline void Self::_internal_set_stamina(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stamina_ = value;
}

// bool is_kickable = 30;
inline void Self::clear_is_kickable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_kickable_ = false;
}
inline bool Self::is_kickable() const {
  // @@protoc_insertion_point(field_get:protos.Self.is_kickable)
  return _internal_is_kickable();
}
inline void Self::set_is_kickable(bool value) {
  _internal_set_is_kickable(value);
  // @@protoc_insertion_point(field_set:protos.Self.is_kickable)
}
inline bool Self::_internal_is_kickable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_kickable_;
}
inline void Self::_internal_set_is_kickable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_kickable_ = value;
}

// float catch_probability = 31;
inline void Self::clear_catch_probability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catch_probability_ = 0;
}
inline float Self::catch_probability() const {
  // @@protoc_insertion_point(field_get:protos.Self.catch_probability)
  return _internal_catch_probability();
}
inline void Self::set_catch_probability(float value) {
  _internal_set_catch_probability(value);
  // @@protoc_insertion_point(field_set:protos.Self.catch_probability)
}
inline float Self::_internal_catch_probability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.catch_probability_;
}
inline void Self::_internal_set_catch_probability(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.catch_probability_ = value;
}

// float tackle_probability = 32;
inline void Self::clear_tackle_probability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tackle_probability_ = 0;
}
inline float Self::tackle_probability() const {
  // @@protoc_insertion_point(field_get:protos.Self.tackle_probability)
  return _internal_tackle_probability();
}
inline void Self::set_tackle_probability(float value) {
  _internal_set_tackle_probability(value);
  // @@protoc_insertion_point(field_set:protos.Self.tackle_probability)
}
inline float Self::_internal_tackle_probability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tackle_probability_;
}
inline void Self::_internal_set_tackle_probability(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tackle_probability_ = value;
}

// float foul_probability = 33;
inline void Self::clear_foul_probability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.foul_probability_ = 0;
}
inline float Self::foul_probability() const {
  // @@protoc_insertion_point(field_get:protos.Self.foul_probability)
  return _internal_foul_probability();
}
inline void Self::set_foul_probability(float value) {
  _internal_set_foul_probability(value);
  // @@protoc_insertion_point(field_set:protos.Self.foul_probability)
}
inline float Self::_internal_foul_probability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.foul_probability_;
}
inline void Self::_internal_set_foul_probability(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.foul_probability_ = value;
}

// .protos.ViewWidth view_width = 34;
inline void Self::clear_view_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.view_width_ = 0;
}
inline ::protos::ViewWidth Self::view_width() const {
  // @@protoc_insertion_point(field_get:protos.Self.view_width)
  return _internal_view_width();
}
inline void Self::set_view_width(::protos::ViewWidth value) {
  _internal_set_view_width(value);
  // @@protoc_insertion_point(field_set:protos.Self.view_width)
}
inline ::protos::ViewWidth Self::_internal_view_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::ViewWidth>(_impl_.view_width_);
}
inline void Self::_internal_set_view_width(::protos::ViewWidth value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.view_width_ = value;
}

// int32 type_id = 35;
inline void Self::clear_type_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_id_ = 0;
}
inline ::int32_t Self::type_id() const {
  // @@protoc_insertion_point(field_get:protos.Self.type_id)
  return _internal_type_id();
}
inline void Self::set_type_id(::int32_t value) {
  _internal_set_type_id(value);
  // @@protoc_insertion_point(field_set:protos.Self.type_id)
}
inline ::int32_t Self::_internal_type_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_id_;
}
inline void Self::_internal_set_type_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_id_ = value;
}

// float kick_rate = 36;
inline void Self::clear_kick_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kick_rate_ = 0;
}
inline float Self::kick_rate() const {
  // @@protoc_insertion_point(field_get:protos.Self.kick_rate)
  return _internal_kick_rate();
}
inline void Self::set_kick_rate(float value) {
  _internal_set_kick_rate(value);
  // @@protoc_insertion_point(field_set:protos.Self.kick_rate)
}
inline float Self::_internal_kick_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kick_rate_;
}
inline void Self::_internal_set_kick_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kick_rate_ = value;
}

// -------------------------------------------------------------------

// InterceptInfo

// .protos.InterceptActionType action_type = 1;
inline void InterceptInfo::clear_action_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_type_ = 0;
}
inline ::protos::InterceptActionType InterceptInfo::action_type() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.action_type)
  return _internal_action_type();
}
inline void InterceptInfo::set_action_type(::protos::InterceptActionType value) {
  _internal_set_action_type(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.action_type)
}
inline ::protos::InterceptActionType InterceptInfo::_internal_action_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::InterceptActionType>(_impl_.action_type_);
}
inline void InterceptInfo::_internal_set_action_type(::protos::InterceptActionType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_type_ = value;
}

// int32 turn_steps = 2;
inline void InterceptInfo::clear_turn_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.turn_steps_ = 0;
}
inline ::int32_t InterceptInfo::turn_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.turn_steps)
  return _internal_turn_steps();
}
inline void InterceptInfo::set_turn_steps(::int32_t value) {
  _internal_set_turn_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.turn_steps)
}
inline ::int32_t InterceptInfo::_internal_turn_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.turn_steps_;
}
inline void InterceptInfo::_internal_set_turn_steps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.turn_steps_ = value;
}

// float turn_angle = 3;
inline void InterceptInfo::clear_turn_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.turn_angle_ = 0;
}
inline float InterceptInfo::turn_angle() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.turn_angle)
  return _internal_turn_angle();
}
inline void InterceptInfo::set_turn_angle(float value) {
  _internal_set_turn_angle(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.turn_angle)
}
inline float InterceptInfo::_internal_turn_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.turn_angle_;
}
inline void InterceptInfo::_internal_set_turn_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.turn_angle_ = value;
}

// int32 dash_steps = 4;
inline void InterceptInfo::clear_dash_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_steps_ = 0;
}
inline ::int32_t InterceptInfo::dash_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.dash_steps)
  return _internal_dash_steps();
}
inline void InterceptInfo::set_dash_steps(::int32_t value) {
  _internal_set_dash_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.dash_steps)
}
inline ::int32_t InterceptInfo::_internal_dash_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_steps_;
}
inline void InterceptInfo::_internal_set_dash_steps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dash_steps_ = value;
}

// float dash_power = 5;
inline void InterceptInfo::clear_dash_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_power_ = 0;
}
inline float InterceptInfo::dash_power() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.dash_power)
  return _internal_dash_power();
}
inline void InterceptInfo::set_dash_power(float value) {
  _internal_set_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.dash_power)
}
inline float InterceptInfo::_internal_dash_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_power_;
}
inline void InterceptInfo::_internal_set_dash_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dash_power_ = value;
}

// float dash_dir = 6;
inline void InterceptInfo::clear_dash_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_dir_ = 0;
}
inline float InterceptInfo::dash_dir() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.dash_dir)
  return _internal_dash_dir();
}
inline void InterceptInfo::set_dash_dir(float value) {
  _internal_set_dash_dir(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.dash_dir)
}
inline float InterceptInfo::_internal_dash_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_dir_;
}
inline void InterceptInfo::_internal_set_dash_dir(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dash_dir_ = value;
}

// .protos.Vector2D final_self_position = 7;
inline bool InterceptInfo::has_final_self_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.final_self_position_ != nullptr);
  return value;
}
inline void InterceptInfo::clear_final_self_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.final_self_position_ != nullptr) _impl_.final_self_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& InterceptInfo::_internal_final_self_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.final_self_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& InterceptInfo::final_self_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.final_self_position)
  return _internal_final_self_position();
}
inline void InterceptInfo::unsafe_arena_set_allocated_final_self_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.final_self_position_);
  }
  _impl_.final_self_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.InterceptInfo.final_self_position)
}
inline ::protos::Vector2D* InterceptInfo::release_final_self_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.final_self_position_;
  _impl_.final_self_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* InterceptInfo::unsafe_arena_release_final_self_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.InterceptInfo.final_self_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.final_self_position_;
  _impl_.final_self_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* InterceptInfo::_internal_mutable_final_self_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.final_self_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.final_self_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.final_self_position_;
}
inline ::protos::Vector2D* InterceptInfo::mutable_final_self_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_final_self_position();
  // @@protoc_insertion_point(field_mutable:protos.InterceptInfo.final_self_position)
  return _msg;
}
inline void InterceptInfo::set_allocated_final_self_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.final_self_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.final_self_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.InterceptInfo.final_self_position)
}

// float final_ball_dist = 8;
inline void InterceptInfo::clear_final_ball_dist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.final_ball_dist_ = 0;
}
inline float InterceptInfo::final_ball_dist() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.final_ball_dist)
  return _internal_final_ball_dist();
}
inline void InterceptInfo::set_final_ball_dist(float value) {
  _internal_set_final_ball_dist(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.final_ball_dist)
}
inline float InterceptInfo::_internal_final_ball_dist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.final_ball_dist_;
}
inline void InterceptInfo::_internal_set_final_ball_dist(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.final_ball_dist_ = value;
}

// float final_stamina = 9;
inline void InterceptInfo::clear_final_stamina() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.final_stamina_ = 0;
}
inline float InterceptInfo::final_stamina() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.final_stamina)
  return _internal_final_stamina();
}
inline void InterceptInfo::set_final_stamina(float value) {
  _internal_set_final_stamina(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.final_stamina)
}
inline float InterceptInfo::_internal_final_stamina() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.final_stamina_;
}
inline void InterceptInfo::_internal_set_final_stamina(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.final_stamina_ = value;
}

// float value = 10;
inline void InterceptInfo::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline float InterceptInfo::value() const {
  // @@protoc_insertion_point(field_get:protos.InterceptInfo.value)
  return _internal_value();
}
inline void InterceptInfo::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:protos.InterceptInfo.value)
}
inline float InterceptInfo::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void InterceptInfo::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// InterceptTable

// int32 self_reach_steps = 1;
inline void InterceptTable::clear_self_reach_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.self_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::self_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.self_reach_steps)
  return _internal_self_reach_steps();
}
inline void InterceptTable::set_self_reach_steps(::int32_t value) {
  _internal_set_self_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.self_reach_steps)
}
inline ::int32_t InterceptTable::_internal_self_reach_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.self_reach_steps_;
}
inline void InterceptTable::_internal_set_self_reach_steps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.self_reach_steps_ = value;
}

// int32 first_teammate_reach_steps = 2;
inline void InterceptTable::clear_first_teammate_reach_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.first_teammate_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::first_teammate_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.first_teammate_reach_steps)
  return _internal_first_teammate_reach_steps();
}
inline void InterceptTable::set_first_teammate_reach_steps(::int32_t value) {
  _internal_set_first_teammate_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.first_teammate_reach_steps)
}
inline ::int32_t InterceptTable::_internal_first_teammate_reach_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.first_teammate_reach_steps_;
}
inline void InterceptTable::_internal_set_first_teammate_reach_steps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.first_teammate_reach_steps_ = value;
}

// int32 second_teammate_reach_steps = 3;
inline void InterceptTable::clear_second_teammate_reach_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.second_teammate_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::second_teammate_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.second_teammate_reach_steps)
  return _internal_second_teammate_reach_steps();
}
inline void InterceptTable::set_second_teammate_reach_steps(::int32_t value) {
  _internal_set_second_teammate_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.second_teammate_reach_steps)
}
inline ::int32_t InterceptTable::_internal_second_teammate_reach_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.second_teammate_reach_steps_;
}
inline void InterceptTable::_internal_set_second_teammate_reach_steps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.second_teammate_reach_steps_ = value;
}

// int32 first_opponent_reach_steps = 4;
inline void InterceptTable::clear_first_opponent_reach_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.first_opponent_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::first_opponent_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.first_opponent_reach_steps)
  return _internal_first_opponent_reach_steps();
}
inline void InterceptTable::set_first_opponent_reach_steps(::int32_t value) {
  _internal_set_first_opponent_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.first_opponent_reach_steps)
}
inline ::int32_t InterceptTable::_internal_first_opponent_reach_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.first_opponent_reach_steps_;
}
inline void InterceptTable::_internal_set_first_opponent_reach_steps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.first_opponent_reach_steps_ = value;
}

// int32 second_opponent_reach_steps = 5;
inline void InterceptTable::clear_second_opponent_reach_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.second_opponent_reach_steps_ = 0;
}
inline ::int32_t InterceptTable::second_opponent_reach_steps() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.second_opponent_reach_steps)
  return _internal_second_opponent_reach_steps();
}
inline void InterceptTable::set_second_opponent_reach_steps(::int32_t value) {
  _internal_set_second_opponent_reach_steps(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.second_opponent_reach_steps)
}
inline ::int32_t InterceptTable::_internal_second_opponent_reach_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.second_opponent_reach_steps_;
}
inline void InterceptTable::_internal_set_second_opponent_reach_steps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.second_opponent_reach_steps_ = value;
}

// int32 first_teammate_id = 6;
inline void InterceptTable::clear_first_teammate_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.first_teammate_id_ = 0;
}
inline ::int32_t InterceptTable::first_teammate_id() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.first_teammate_id)
  return _internal_first_teammate_id();
}
inline void InterceptTable::set_first_teammate_id(::int32_t value) {
  _internal_set_first_teammate_id(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.first_teammate_id)
}
inline ::int32_t InterceptTable::_internal_first_teammate_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.first_teammate_id_;
}
inline void InterceptTable::_internal_set_first_teammate_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.first_teammate_id_ = value;
}

// int32 second_teammate_id = 7;
inline void InterceptTable::clear_second_teammate_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.second_teammate_id_ = 0;
}
inline ::int32_t InterceptTable::second_teammate_id() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.second_teammate_id)
  return _internal_second_teammate_id();
}
inline void InterceptTable::set_second_teammate_id(::int32_t value) {
  _internal_set_second_teammate_id(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.second_teammate_id)
}
inline ::int32_t InterceptTable::_internal_second_teammate_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.second_teammate_id_;
}
inline void InterceptTable::_internal_set_second_teammate_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.second_teammate_id_ = value;
}

// int32 first_opponent_id = 8;
inline void InterceptTable::clear_first_opponent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.first_opponent_id_ = 0;
}
inline ::int32_t InterceptTable::first_opponent_id() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.first_opponent_id)
  return _internal_first_opponent_id();
}
inline void InterceptTable::set_first_opponent_id(::int32_t value) {
  _internal_set_first_opponent_id(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.first_opponent_id)
}
inline ::int32_t InterceptTable::_internal_first_opponent_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.first_opponent_id_;
}
inline void InterceptTable::_internal_set_first_opponent_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.first_opponent_id_ = value;
}

// int32 second_opponent_id = 9;
inline void InterceptTable::clear_second_opponent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.second_opponent_id_ = 0;
}
inline ::int32_t InterceptTable::second_opponent_id() const {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.second_opponent_id)
  return _internal_second_opponent_id();
}
inline void InterceptTable::set_second_opponent_id(::int32_t value) {
  _internal_set_second_opponent_id(value);
  // @@protoc_insertion_point(field_set:protos.InterceptTable.second_opponent_id)
}
inline ::int32_t InterceptTable::_internal_second_opponent_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.second_opponent_id_;
}
inline void InterceptTable::_internal_set_second_opponent_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.second_opponent_id_ = value;
}

// repeated .protos.InterceptInfo self_intercept_info = 10;
inline int InterceptTable::_internal_self_intercept_info_size() const {
  return _internal_self_intercept_info().size();
}
inline int InterceptTable::self_intercept_info_size() const {
  return _internal_self_intercept_info_size();
}
inline void InterceptTable::clear_self_intercept_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.self_intercept_info_.Clear();
}
inline ::protos::InterceptInfo* InterceptTable::mutable_self_intercept_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:protos.InterceptTable.self_intercept_info)
  return _internal_mutable_self_intercept_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::protos::InterceptInfo>* InterceptTable::mutable_self_intercept_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:protos.InterceptTable.self_intercept_info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_self_intercept_info();
}
inline const ::protos::InterceptInfo& InterceptTable::self_intercept_info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.InterceptTable.self_intercept_info)
  return _internal_self_intercept_info().Get(index);
}
inline ::protos::InterceptInfo* InterceptTable::add_self_intercept_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::protos::InterceptInfo* _add = _internal_mutable_self_intercept_info()->Add();
  // @@protoc_insertion_point(field_add:protos.InterceptTable.self_intercept_info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::protos::InterceptInfo>& InterceptTable::self_intercept_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:protos.InterceptTable.self_intercept_info)
  return _internal_self_intercept_info();
}
inline const ::google::protobuf::RepeatedPtrField<::protos::InterceptInfo>&
InterceptTable::_internal_self_intercept_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.self_intercept_info_;
}
inline ::google::protobuf::RepeatedPtrField<::protos::InterceptInfo>*
InterceptTable::_internal_mutable_self_intercept_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.self_intercept_info_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WorldModel

// .protos.InterceptTable intercept_table = 1;
inline bool WorldModel::has_intercept_table() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.intercept_table_ != nullptr);
  return value;
}
inline void WorldModel::clear_intercept_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.intercept_table_ != nullptr) _impl_.intercept_table_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::InterceptTable& WorldModel::_internal_intercept_table() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::InterceptTable* p = _impl_.intercept_table_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::InterceptTable&>(::protos::_InterceptTable_default_instance_);
}
inline const ::protos::InterceptTable& WorldModel::intercept_table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.WorldModel.intercept_table)
  return _internal_intercept_table();
}
inline void WorldModel::unsafe_arena_set_allocated_intercept_table(::protos::InterceptTable* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.intercept_table_);
  }
  _impl_.intercept_table_ = reinterpret_cast<::protos::InterceptTable*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.WorldModel.intercept_table)
}
inline ::protos::InterceptTable* WorldModel::release_intercept_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::InterceptTable* released = _impl_.intercept_table_;
  _impl_.intercept_table_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::InterceptTable* WorldModel::unsafe_arena_release_intercept_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.WorldModel.intercept_table)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::InterceptTable* temp = _impl_.intercept_table_;
  _impl_.intercept_table_ = nullptr;
  return temp;
}
inline ::protos::InterceptTable* WorldModel::_internal_mutable_intercept_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.intercept_table_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::InterceptTable>(GetArena());
    _impl_.intercept_table_ = reinterpret_cast<::protos::InterceptTable*>(p);
  }
  return _impl_.intercept_table_;
}
inline ::protos::InterceptTable* WorldModel::mutable_intercept_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::InterceptTable* _msg = _internal_mutable_intercept_table();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.intercept_table)
  return _msg;
}
inline void WorldModel::set_allocated_intercept_table(::protos::InterceptTable* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::InterceptTable*>(_impl_.intercept_table_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::InterceptTable*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.intercept_table_ = reinterpret_cast<::protos::InterceptTable*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.intercept_table)
}

// string our_team_name = 2;
inline void WorldModel::clear_our_team_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.our_team_name_.ClearToEmpty();
}
inline const std::string& WorldModel::our_team_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.WorldModel.our_team_name)
  return _internal_our_team_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldModel::set_our_team_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.our_team_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.WorldModel.our_team_name)
}
inline std::string* WorldModel::mutable_our_team_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_our_team_name();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.our_team_name)
  return _s;
}
inline const std::string& WorldModel::_internal_our_team_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.our_team_name_.Get();
}
inline void WorldModel::_internal_set_our_team_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.our_team_name_.Set(value, GetArena());
}
inline std::string* WorldModel::_internal_mutable_our_team_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.our_team_name_.Mutable( GetArena());
}
inline std::string* WorldModel::release_our_team_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.WorldModel.our_team_name)
  return _impl_.our_team_name_.Release();
}
inline void WorldModel::set_allocated_our_team_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.our_team_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.our_team_name_.IsDefault()) {
          _impl_.our_team_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.our_team_name)
}

// string their_team_name = 3;
inline void WorldModel::clear_their_team_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.their_team_name_.ClearToEmpty();
}
inline const std::string& WorldModel::their_team_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.WorldModel.their_team_name)
  return _internal_their_team_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldModel::set_their_team_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.their_team_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.WorldModel.their_team_name)
}
inline std::string* WorldModel::mutable_their_team_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_their_team_name();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.their_team_name)
  return _s;
}
inline const std::string& WorldModel::_internal_their_team_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.their_team_name_.Get();
}
inline void WorldModel::_internal_set_their_team_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.their_team_name_.Set(value, GetArena());
}
inline std::string* WorldModel::_internal_mutable_their_team_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.their_team_name_.Mutable( GetArena());
}
inline std::string* WorldModel::release_their_team_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.WorldModel.their_team_name)
  return _impl_.their_team_name_.Release();
}
inline void WorldModel::set_allocated_their_team_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.their_team_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.their_team_name_.IsDefault()) {
          _impl_.their_team_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.their_team_name)
}

// .protos.Side our_side = 4;
inline void WorldModel::clear_our_side() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.our_side_ = 0;
}
inline ::protos::Side WorldModel::our_side() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.our_side)
  return _internal_our_side();
}
inline void WorldModel::set_our_side(::protos::Side value) {
  _internal_set_our_side(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.our_side)
}
inline ::protos::Side WorldModel::_internal_our_side() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::Side>(_impl_.our_side_);
}
inline void WorldModel::_internal_set_our_side(::protos::Side value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.our_side_ = value;
}

// int32 last_set_play_start_time = 5;
inline void WorldModel::clear_last_set_play_start_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_set_play_start_time_ = 0;
}
inline ::int32_t WorldModel::last_set_play_start_time() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.last_set_play_start_time)
  return _internal_last_set_play_start_time();
}
inline void WorldModel::set_last_set_play_start_time(::int32_t value) {
  _internal_set_last_set_play_start_time(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.last_set_play_start_time)
}
inline ::int32_t WorldModel::_internal_last_set_play_start_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_set_play_start_time_;
}
inline void WorldModel::_internal_set_last_set_play_start_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.last_set_play_start_time_ = value;
}

// .protos.Self self = 6;
inline bool WorldModel::has_self() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.self_ != nullptr);
  return value;
}
inline void WorldModel::clear_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.self_ != nullptr) _impl_.self_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Self& WorldModel::_internal_self() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Self* p = _impl_.self_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Self&>(::protos::_Self_default_instance_);
}
inline const ::protos::Self& WorldModel::self() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.WorldModel.self)
  return _internal_self();
}
inline void WorldModel::unsafe_arena_set_allocated_self(::protos::Self* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.self_);
  }
  _impl_.self_ = reinterpret_cast<::protos::Self*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.WorldModel.self)
}
inline ::protos::Self* WorldModel::release_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Self* released = _impl_.self_;
  _impl_.self_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Self* WorldModel::unsafe_arena_release_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.WorldModel.self)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Self* temp = _impl_.self_;
  _impl_.self_ = nullptr;
  return temp;
}
inline ::protos::Self* WorldModel::_internal_mutable_self() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.self_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Self>(GetArena());
    _impl_.self_ = reinterpret_cast<::protos::Self*>(p);
  }
  return _impl_.self_;
}
inline ::protos::Self* WorldModel::mutable_self() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Self* _msg = _internal_mutable_self();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.self)
  return _msg;
}
inline void WorldModel::set_allocated_self(::protos::Self* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Self*>(_impl_.self_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Self*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.self_ = reinterpret_cast<::protos::Self*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.self)
}

// .protos.Ball ball = 7;
inline bool WorldModel::has_ball() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_ != nullptr);
  return value;
}
inline void WorldModel::clear_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ball_ != nullptr) _impl_.ball_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Ball& WorldModel::_internal_ball() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Ball* p = _impl_.ball_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Ball&>(::protos::_Ball_default_instance_);
}
inline const ::protos::Ball& WorldModel::ball() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.WorldModel.ball)
  return _internal_ball();
}
inline void WorldModel::unsafe_arena_set_allocated_ball(::protos::Ball* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ball_);
  }
  _impl_.ball_ = reinterpret_cast<::protos::Ball*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.WorldModel.ball)
}
inline ::protos::Ball* WorldModel::release_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Ball* released = _impl_.ball_;
  _impl_.ball_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Ball* WorldModel::unsafe_arena_release_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.WorldModel.ball)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Ball* temp = _impl_.ball_;
  _impl_.ball_ = nullptr;
  return temp;
}
inline ::protos::Ball* WorldModel::_internal_mutable_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ball_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Ball>(GetArena());
    _impl_.ball_ = reinterpret_cast<::protos::Ball*>(p);
  }
  return _impl_.ball_;
}
inline ::protos::Ball* WorldModel::mutable_ball() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Ball* _msg = _internal_mutable_ball();
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.ball)
  return _msg;
}
inline void WorldModel::set_allocated_ball(::protos::Ball* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Ball*>(_impl_.ball_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Ball*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.ball_ = reinterpret_cast<::protos::Ball*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.WorldModel.ball)
}

// repeated .protos.Player teammates = 8;
inline int WorldModel::_internal_teammates_size() const {
  return _internal_teammates().size();
}
inline int WorldModel::teammates_size() const {
  return _internal_teammates_size();
}
inline void WorldModel::clear_teammates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.teammates_.Clear();
}
inline ::protos::Player* WorldModel::mutable_teammates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.teammates)
  return _internal_mutable_teammates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::protos::Player>* WorldModel::mutable_teammates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:protos.WorldModel.teammates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_teammates();
}
inline const ::protos::Player& WorldModel::teammates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.WorldModel.teammates)
  return _internal_teammates().Get(index);
}
inline ::protos::Player* WorldModel::add_teammates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::protos::Player* _add = _internal_mutable_teammates()->Add();
  // @@protoc_insertion_point(field_add:protos.WorldModel.teammates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::protos::Player>& WorldModel::teammates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:protos.WorldModel.teammates)
  return _internal_teammates();
}
inline const ::google::protobuf::RepeatedPtrField<::protos::Player>&
WorldModel::_internal_teammates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.teammates_;
}
inline ::google::protobuf::RepeatedPtrField<::protos::Player>*
WorldModel::_internal_mutable_teammates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.teammates_;
}

// repeated .protos.Player opponents = 9;
inline int WorldModel::_internal_opponents_size() const {
  return _internal_opponents().size();
}
inline int WorldModel::opponents_size() const {
  return _internal_opponents_size();
}
inline void WorldModel::clear_opponents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.opponents_.Clear();
}
inline ::protos::Player* WorldModel::mutable_opponents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.opponents)
  return _internal_mutable_opponents()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::protos::Player>* WorldModel::mutable_opponents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:protos.WorldModel.opponents)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_opponents();
}
inline const ::protos::Player& WorldModel::opponents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.WorldModel.opponents)
  return _internal_opponents().Get(index);
}
inline ::protos::Player* WorldModel::add_opponents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::protos::Player* _add = _internal_mutable_opponents()->Add();
  // @@protoc_insertion_point(field_add:protos.WorldModel.opponents)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::protos::Player>& WorldModel::opponents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:protos.WorldModel.opponents)
  return _internal_opponents();
}
inline const ::google::protobuf::RepeatedPtrField<::protos::Player>&
WorldModel::_internal_opponents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.opponents_;
}
inline ::google::protobuf::RepeatedPtrField<::protos::Player>*
WorldModel::_internal_mutable_opponents() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.opponents_;
}

// repeated .protos.Player unknowns = 10;
inline int WorldModel::_internal_unknowns_size() const {
  return _internal_unknowns().size();
}
inline int WorldModel::unknowns_size() const {
  return _internal_unknowns_size();
}
inline void WorldModel::clear_unknowns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unknowns_.Clear();
}
inline ::protos::Player* WorldModel::mutable_unknowns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:protos.WorldModel.unknowns)
  return _internal_mutable_unknowns()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::protos::Player>* WorldModel::mutable_unknowns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:protos.WorldModel.unknowns)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_unknowns();
}
inline const ::protos::Player& WorldModel::unknowns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.WorldModel.unknowns)
  return _internal_unknowns().Get(index);
}
inline ::protos::Player* WorldModel::add_unknowns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::protos::Player* _add = _internal_mutable_unknowns()->Add();
  // @@protoc_insertion_point(field_add:protos.WorldModel.unknowns)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::protos::Player>& WorldModel::unknowns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:protos.WorldModel.unknowns)
  return _internal_unknowns();
}
inline const ::google::protobuf::RepeatedPtrField<::protos::Player>&
WorldModel::_internal_unknowns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unknowns_;
}
inline ::google::protobuf::RepeatedPtrField<::protos::Player>*
WorldModel::_internal_mutable_unknowns() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.unknowns_;
}

// map<int32, .protos.Player> our_players_dict = 11;
inline int WorldModel::_internal_our_players_dict_size() const {
  return _internal_our_players_dict().size();
}
inline int WorldModel::our_players_dict_size() const {
  return _internal_our_players_dict_size();
}
inline void WorldModel::clear_our_players_dict() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.our_players_dict_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::protos::Player>& WorldModel::_internal_our_players_dict() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.our_players_dict_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::protos::Player>& WorldModel::our_players_dict() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:protos.WorldModel.our_players_dict)
  return _internal_our_players_dict();
}
inline ::google::protobuf::Map<::int32_t, ::protos::Player>* WorldModel::_internal_mutable_our_players_dict() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.our_players_dict_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::protos::Player>* WorldModel::mutable_our_players_dict() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:protos.WorldModel.our_players_dict)
  return _internal_mutable_our_players_dict();
}

// map<int32, .protos.Player> their_players_dict = 12;
inline int WorldModel::_internal_their_players_dict_size() const {
  return _internal_their_players_dict().size();
}
inline int WorldModel::their_players_dict_size() const {
  return _internal_their_players_dict_size();
}
inline void WorldModel::clear_their_players_dict() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.their_players_dict_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::protos::Player>& WorldModel::_internal_their_players_dict() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.their_players_dict_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::protos::Player>& WorldModel::their_players_dict() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:protos.WorldModel.their_players_dict)
  return _internal_their_players_dict();
}
inline ::google::protobuf::Map<::int32_t, ::protos::Player>* WorldModel::_internal_mutable_their_players_dict() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.their_players_dict_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::protos::Player>* WorldModel::mutable_their_players_dict() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:protos.WorldModel.their_players_dict)
  return _internal_mutable_their_players_dict();
}

// int32 our_goalie_uniform_number = 13;
inline void WorldModel::clear_our_goalie_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.our_goalie_uniform_number_ = 0;
}
inline ::int32_t WorldModel::our_goalie_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.our_goalie_uniform_number)
  return _internal_our_goalie_uniform_number();
}
inline void WorldModel::set_our_goalie_uniform_number(::int32_t value) {
  _internal_set_our_goalie_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.our_goalie_uniform_number)
}
inline ::int32_t WorldModel::_internal_our_goalie_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.our_goalie_uniform_number_;
}
inline void WorldModel::_internal_set_our_goalie_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.our_goalie_uniform_number_ = value;
}

// int32 their_goalie_uniform_number = 14;
inline void WorldModel::clear_their_goalie_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.their_goalie_uniform_number_ = 0;
}
inline ::int32_t WorldModel::their_goalie_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.their_goalie_uniform_number)
  return _internal_their_goalie_uniform_number();
}
inline void WorldModel::set_their_goalie_uniform_number(::int32_t value) {
  _internal_set_their_goalie_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.their_goalie_uniform_number)
}
inline ::int32_t WorldModel::_internal_their_goalie_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.their_goalie_uniform_number_;
}
inline void WorldModel::_internal_set_their_goalie_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.their_goalie_uniform_number_ = value;
}

// float offside_line_x = 15;
inline void WorldModel::clear_offside_line_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offside_line_x_ = 0;
}
inline float WorldModel::offside_line_x() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.offside_line_x)
  return _internal_offside_line_x();
}
inline void WorldModel::set_offside_line_x(float value) {
  _internal_set_offside_line_x(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.offside_line_x)
}
inline float WorldModel::_internal_offside_line_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offside_line_x_;
}
inline void WorldModel::_internal_set_offside_line_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.offside_line_x_ = value;
}

// int32 ofside_line_x_count = 16;
inline void WorldModel::clear_ofside_line_x_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ofside_line_x_count_ = 0;
}
inline ::int32_t WorldModel::ofside_line_x_count() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.ofside_line_x_count)
  return _internal_ofside_line_x_count();
}
inline void WorldModel::set_ofside_line_x_count(::int32_t value) {
  _internal_set_ofside_line_x_count(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.ofside_line_x_count)
}
inline ::int32_t WorldModel::_internal_ofside_line_x_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ofside_line_x_count_;
}
inline void WorldModel::_internal_set_ofside_line_x_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ofside_line_x_count_ = value;
}

// int32 kickable_teammate_id = 17;
inline void WorldModel::clear_kickable_teammate_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kickable_teammate_id_ = 0;
}
inline ::int32_t WorldModel::kickable_teammate_id() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.kickable_teammate_id)
  return _internal_kickable_teammate_id();
}
inline void WorldModel::set_kickable_teammate_id(::int32_t value) {
  _internal_set_kickable_teammate_id(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.kickable_teammate_id)
}
inline ::int32_t WorldModel::_internal_kickable_teammate_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kickable_teammate_id_;
}
inline void WorldModel::_internal_set_kickable_teammate_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kickable_teammate_id_ = value;
}

// int32 kickable_opponent_id = 18;
inline void WorldModel::clear_kickable_opponent_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kickable_opponent_id_ = 0;
}
inline ::int32_t WorldModel::kickable_opponent_id() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.kickable_opponent_id)
  return _internal_kickable_opponent_id();
}
inline void WorldModel::set_kickable_opponent_id(::int32_t value) {
  _internal_set_kickable_opponent_id(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.kickable_opponent_id)
}
inline ::int32_t WorldModel::_internal_kickable_opponent_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kickable_opponent_id_;
}
inline void WorldModel::_internal_set_kickable_opponent_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kickable_opponent_id_ = value;
}

// .protos.Side last_kick_side = 19;
inline void WorldModel::clear_last_kick_side() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_kick_side_ = 0;
}
inline ::protos::Side WorldModel::last_kick_side() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.last_kick_side)
  return _internal_last_kick_side();
}
inline void WorldModel::set_last_kick_side(::protos::Side value) {
  _internal_set_last_kick_side(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.last_kick_side)
}
inline ::protos::Side WorldModel::_internal_last_kick_side() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::Side>(_impl_.last_kick_side_);
}
inline void WorldModel::_internal_set_last_kick_side(::protos::Side value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.last_kick_side_ = value;
}

// int32 last_kicker_uniform_number = 20;
inline void WorldModel::clear_last_kicker_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_kicker_uniform_number_ = 0;
}
inline ::int32_t WorldModel::last_kicker_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.last_kicker_uniform_number)
  return _internal_last_kicker_uniform_number();
}
inline void WorldModel::set_last_kicker_uniform_number(::int32_t value) {
  _internal_set_last_kicker_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.last_kicker_uniform_number)
}
inline ::int32_t WorldModel::_internal_last_kicker_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_kicker_uniform_number_;
}
inline void WorldModel::_internal_set_last_kicker_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.last_kicker_uniform_number_ = value;
}

// int32 cycle = 21;
inline void WorldModel::clear_cycle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cycle_ = 0;
}
inline ::int32_t WorldModel::cycle() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.cycle)
  return _internal_cycle();
}
inline void WorldModel::set_cycle(::int32_t value) {
  _internal_set_cycle(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.cycle)
}
inline ::int32_t WorldModel::_internal_cycle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cycle_;
}
inline void WorldModel::_internal_set_cycle(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cycle_ = value;
}

// .protos.GameModeType game_mode_type = 22;
inline void WorldModel::clear_game_mode_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_mode_type_ = 0;
}
inline ::protos::GameModeType WorldModel::game_mode_type() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.game_mode_type)
  return _internal_game_mode_type();
}
inline void WorldModel::set_game_mode_type(::protos::GameModeType value) {
  _internal_set_game_mode_type(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.game_mode_type)
}
inline ::protos::GameModeType WorldModel::_internal_game_mode_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::GameModeType>(_impl_.game_mode_type_);
}
inline void WorldModel::_internal_set_game_mode_type(::protos::GameModeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.game_mode_type_ = value;
}

// int32 left_team_score = 23;
inline void WorldModel::clear_left_team_score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.left_team_score_ = 0;
}
inline ::int32_t WorldModel::left_team_score() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.left_team_score)
  return _internal_left_team_score();
}
inline void WorldModel::set_left_team_score(::int32_t value) {
  _internal_set_left_team_score(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.left_team_score)
}
inline ::int32_t WorldModel::_internal_left_team_score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.left_team_score_;
}
inline void WorldModel::_internal_set_left_team_score(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.left_team_score_ = value;
}

// int32 right_team_score = 24;
inline void WorldModel::clear_right_team_score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.right_team_score_ = 0;
}
inline ::int32_t WorldModel::right_team_score() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.right_team_score)
  return _internal_right_team_score();
}
inline void WorldModel::set_right_team_score(::int32_t value) {
  _internal_set_right_team_score(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.right_team_score)
}
inline ::int32_t WorldModel::_internal_right_team_score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.right_team_score_;
}
inline void WorldModel::_internal_set_right_team_score(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.right_team_score_ = value;
}

// bool is_our_set_play = 25;
inline void WorldModel::clear_is_our_set_play() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_our_set_play_ = false;
}
inline bool WorldModel::is_our_set_play() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.is_our_set_play)
  return _internal_is_our_set_play();
}
inline void WorldModel::set_is_our_set_play(bool value) {
  _internal_set_is_our_set_play(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.is_our_set_play)
}
inline bool WorldModel::_internal_is_our_set_play() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_our_set_play_;
}
inline void WorldModel::_internal_set_is_our_set_play(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_our_set_play_ = value;
}

// bool is_their_set_play = 26;
inline void WorldModel::clear_is_their_set_play() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_their_set_play_ = false;
}
inline bool WorldModel::is_their_set_play() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.is_their_set_play)
  return _internal_is_their_set_play();
}
inline void WorldModel::set_is_their_set_play(bool value) {
  _internal_set_is_their_set_play(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.is_their_set_play)
}
inline bool WorldModel::_internal_is_their_set_play() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_their_set_play_;
}
inline void WorldModel::_internal_set_is_their_set_play(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_their_set_play_ = value;
}

// int32 stoped_cycle = 27;
inline void WorldModel::clear_stoped_cycle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stoped_cycle_ = 0;
}
inline ::int32_t WorldModel::stoped_cycle() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.stoped_cycle)
  return _internal_stoped_cycle();
}
inline void WorldModel::set_stoped_cycle(::int32_t value) {
  _internal_set_stoped_cycle(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.stoped_cycle)
}
inline ::int32_t WorldModel::_internal_stoped_cycle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stoped_cycle_;
}
inline void WorldModel::_internal_set_stoped_cycle(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stoped_cycle_ = value;
}

// int32 our_team_score = 28;
inline void WorldModel::clear_our_team_score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.our_team_score_ = 0;
}
inline ::int32_t WorldModel::our_team_score() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.our_team_score)
  return _internal_our_team_score();
}
inline void WorldModel::set_our_team_score(::int32_t value) {
  _internal_set_our_team_score(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.our_team_score)
}
inline ::int32_t WorldModel::_internal_our_team_score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.our_team_score_;
}
inline void WorldModel::_internal_set_our_team_score(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.our_team_score_ = value;
}

// int32 their_team_score = 29;
inline void WorldModel::clear_their_team_score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.their_team_score_ = 0;
}
inline ::int32_t WorldModel::their_team_score() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.their_team_score)
  return _internal_their_team_score();
}
inline void WorldModel::set_their_team_score(::int32_t value) {
  _internal_set_their_team_score(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.their_team_score)
}
inline ::int32_t WorldModel::_internal_their_team_score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.their_team_score_;
}
inline void WorldModel::_internal_set_their_team_score(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.their_team_score_ = value;
}

// bool is_penalty_kick_mode = 30;
inline void WorldModel::clear_is_penalty_kick_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_penalty_kick_mode_ = false;
}
inline bool WorldModel::is_penalty_kick_mode() const {
  // @@protoc_insertion_point(field_get:protos.WorldModel.is_penalty_kick_mode)
  return _internal_is_penalty_kick_mode();
}
inline void WorldModel::set_is_penalty_kick_mode(bool value) {
  _internal_set_is_penalty_kick_mode(value);
  // @@protoc_insertion_point(field_set:protos.WorldModel.is_penalty_kick_mode)
}
inline bool WorldModel::_internal_is_penalty_kick_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_penalty_kick_mode_;
}
inline void WorldModel::_internal_set_is_penalty_kick_mode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_penalty_kick_mode_ = value;
}

// map<int32, .protos.Vector2D> helios_home_positions = 31;
inline int WorldModel::_internal_helios_home_positions_size() const {
  return _internal_helios_home_positions().size();
}
inline int WorldModel::helios_home_positions_size() const {
  return _internal_helios_home_positions_size();
}
inline void WorldModel::clear_helios_home_positions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.helios_home_positions_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::protos::Vector2D>& WorldModel::_internal_helios_home_positions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.helios_home_positions_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::protos::Vector2D>& WorldModel::helios_home_positions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:protos.WorldModel.helios_home_positions)
  return _internal_helios_home_positions();
}
inline ::google::protobuf::Map<::int32_t, ::protos::Vector2D>* WorldModel::_internal_mutable_helios_home_positions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.helios_home_positions_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::protos::Vector2D>* WorldModel::mutable_helios_home_positions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:protos.WorldModel.helios_home_positions)
  return _internal_mutable_helios_home_positions();
}

// -------------------------------------------------------------------

// State

// .protos.AgentType agent_type = 1;
inline void State::clear_agent_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_type_ = 0;
}
inline ::protos::AgentType State::agent_type() const {
  // @@protoc_insertion_point(field_get:protos.State.agent_type)
  return _internal_agent_type();
}
inline void State::set_agent_type(::protos::AgentType value) {
  _internal_set_agent_type(value);
  // @@protoc_insertion_point(field_set:protos.State.agent_type)
}
inline ::protos::AgentType State::_internal_agent_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::AgentType>(_impl_.agent_type_);
}
inline void State::_internal_set_agent_type(::protos::AgentType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_type_ = value;
}

// .protos.WorldModel world_model = 2;
inline bool State::has_world_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.world_model_ != nullptr);
  return value;
}
inline void State::clear_world_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.world_model_ != nullptr) _impl_.world_model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::WorldModel& State::_internal_world_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::WorldModel* p = _impl_.world_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::WorldModel&>(::protos::_WorldModel_default_instance_);
}
inline const ::protos::WorldModel& State::world_model() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.State.world_model)
  return _internal_world_model();
}
inline void State::unsafe_arena_set_allocated_world_model(::protos::WorldModel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.world_model_);
  }
  _impl_.world_model_ = reinterpret_cast<::protos::WorldModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.State.world_model)
}
inline ::protos::WorldModel* State::release_world_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::WorldModel* released = _impl_.world_model_;
  _impl_.world_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::WorldModel* State::unsafe_arena_release_world_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.State.world_model)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::WorldModel* temp = _impl_.world_model_;
  _impl_.world_model_ = nullptr;
  return temp;
}
inline ::protos::WorldModel* State::_internal_mutable_world_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.world_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::WorldModel>(GetArena());
    _impl_.world_model_ = reinterpret_cast<::protos::WorldModel*>(p);
  }
  return _impl_.world_model_;
}
inline ::protos::WorldModel* State::mutable_world_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::WorldModel* _msg = _internal_mutable_world_model();
  // @@protoc_insertion_point(field_mutable:protos.State.world_model)
  return _msg;
}
inline void State::set_allocated_world_model(::protos::WorldModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::WorldModel*>(_impl_.world_model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::WorldModel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.world_model_ = reinterpret_cast<::protos::WorldModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.State.world_model)
}

// .protos.WorldModel full_world_model = 3;
inline bool State::has_full_world_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.full_world_model_ != nullptr);
  return value;
}
inline void State::clear_full_world_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.full_world_model_ != nullptr) _impl_.full_world_model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::WorldModel& State::_internal_full_world_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::WorldModel* p = _impl_.full_world_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::WorldModel&>(::protos::_WorldModel_default_instance_);
}
inline const ::protos::WorldModel& State::full_world_model() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.State.full_world_model)
  return _internal_full_world_model();
}
inline void State::unsafe_arena_set_allocated_full_world_model(::protos::WorldModel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.full_world_model_);
  }
  _impl_.full_world_model_ = reinterpret_cast<::protos::WorldModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.State.full_world_model)
}
inline ::protos::WorldModel* State::release_full_world_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::WorldModel* released = _impl_.full_world_model_;
  _impl_.full_world_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::WorldModel* State::unsafe_arena_release_full_world_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.State.full_world_model)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::WorldModel* temp = _impl_.full_world_model_;
  _impl_.full_world_model_ = nullptr;
  return temp;
}
inline ::protos::WorldModel* State::_internal_mutable_full_world_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.full_world_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::WorldModel>(GetArena());
    _impl_.full_world_model_ = reinterpret_cast<::protos::WorldModel*>(p);
  }
  return _impl_.full_world_model_;
}
inline ::protos::WorldModel* State::mutable_full_world_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::WorldModel* _msg = _internal_mutable_full_world_model();
  // @@protoc_insertion_point(field_mutable:protos.State.full_world_model)
  return _msg;
}
inline void State::set_allocated_full_world_model(::protos::WorldModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::WorldModel*>(_impl_.full_world_model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::WorldModel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.full_world_model_ = reinterpret_cast<::protos::WorldModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.State.full_world_model)
}

// -------------------------------------------------------------------

// InitMessage

// .protos.AgentType agent_type = 1;
inline void InitMessage::clear_agent_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_type_ = 0;
}
inline ::protos::AgentType InitMessage::agent_type() const {
  // @@protoc_insertion_point(field_get:protos.InitMessage.agent_type)
  return _internal_agent_type();
}
inline void InitMessage::set_agent_type(::protos::AgentType value) {
  _internal_set_agent_type(value);
  // @@protoc_insertion_point(field_set:protos.InitMessage.agent_type)
}
inline ::protos::AgentType InitMessage::_internal_agent_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::AgentType>(_impl_.agent_type_);
}
inline void InitMessage::_internal_set_agent_type(::protos::AgentType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_type_ = value;
}

// bool debug_mode = 2;
inline void InitMessage::clear_debug_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.debug_mode_ = false;
}
inline bool InitMessage::debug_mode() const {
  // @@protoc_insertion_point(field_get:protos.InitMessage.debug_mode)
  return _internal_debug_mode();
}
inline void InitMessage::set_debug_mode(bool value) {
  _internal_set_debug_mode(value);
  // @@protoc_insertion_point(field_set:protos.InitMessage.debug_mode)
}
inline bool InitMessage::_internal_debug_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.debug_mode_;
}
inline void InitMessage::_internal_set_debug_mode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.debug_mode_ = value;
}

// -------------------------------------------------------------------

// Dash

// float power = 1;
inline void Dash::clear_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.power_ = 0;
}
inline float Dash::power() const {
  // @@protoc_insertion_point(field_get:protos.Dash.power)
  return _internal_power();
}
inline void Dash::set_power(float value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:protos.Dash.power)
}
inline float Dash::_internal_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.power_;
}
inline void Dash::_internal_set_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.power_ = value;
}

// float relative_direction = 2;
inline void Dash::clear_relative_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relative_direction_ = 0;
}
inline float Dash::relative_direction() const {
  // @@protoc_insertion_point(field_get:protos.Dash.relative_direction)
  return _internal_relative_direction();
}
inline void Dash::set_relative_direction(float value) {
  _internal_set_relative_direction(value);
  // @@protoc_insertion_point(field_set:protos.Dash.relative_direction)
}
inline float Dash::_internal_relative_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.relative_direction_;
}
inline void Dash::_internal_set_relative_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.relative_direction_ = value;
}

// -------------------------------------------------------------------

// Turn

// float relative_direction = 1;
inline void Turn::clear_relative_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relative_direction_ = 0;
}
inline float Turn::relative_direction() const {
  // @@protoc_insertion_point(field_get:protos.Turn.relative_direction)
  return _internal_relative_direction();
}
inline void Turn::set_relative_direction(float value) {
  _internal_set_relative_direction(value);
  // @@protoc_insertion_point(field_set:protos.Turn.relative_direction)
}
inline float Turn::_internal_relative_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.relative_direction_;
}
inline void Turn::_internal_set_relative_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.relative_direction_ = value;
}

// -------------------------------------------------------------------

// Kick

// float power = 1;
inline void Kick::clear_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.power_ = 0;
}
inline float Kick::power() const {
  // @@protoc_insertion_point(field_get:protos.Kick.power)
  return _internal_power();
}
inline void Kick::set_power(float value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:protos.Kick.power)
}
inline float Kick::_internal_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.power_;
}
inline void Kick::_internal_set_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.power_ = value;
}

// float relative_direction = 2;
inline void Kick::clear_relative_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relative_direction_ = 0;
}
inline float Kick::relative_direction() const {
  // @@protoc_insertion_point(field_get:protos.Kick.relative_direction)
  return _internal_relative_direction();
}
inline void Kick::set_relative_direction(float value) {
  _internal_set_relative_direction(value);
  // @@protoc_insertion_point(field_set:protos.Kick.relative_direction)
}
inline float Kick::_internal_relative_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.relative_direction_;
}
inline void Kick::_internal_set_relative_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.relative_direction_ = value;
}

// -------------------------------------------------------------------

// Tackle

// float power_or_dir = 1;
inline void Tackle::clear_power_or_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.power_or_dir_ = 0;
}
inline float Tackle::power_or_dir() const {
  // @@protoc_insertion_point(field_get:protos.Tackle.power_or_dir)
  return _internal_power_or_dir();
}
inline void Tackle::set_power_or_dir(float value) {
  _internal_set_power_or_dir(value);
  // @@protoc_insertion_point(field_set:protos.Tackle.power_or_dir)
}
inline float Tackle::_internal_power_or_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.power_or_dir_;
}
inline void Tackle::_internal_set_power_or_dir(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.power_or_dir_ = value;
}

// bool foul = 2;
inline void Tackle::clear_foul() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.foul_ = false;
}
inline bool Tackle::foul() const {
  // @@protoc_insertion_point(field_get:protos.Tackle.foul)
  return _internal_foul();
}
inline void Tackle::set_foul(bool value) {
  _internal_set_foul(value);
  // @@protoc_insertion_point(field_set:protos.Tackle.foul)
}
inline bool Tackle::_internal_foul() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.foul_;
}
inline void Tackle::_internal_set_foul(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.foul_ = value;
}

// -------------------------------------------------------------------

// Catch

// -------------------------------------------------------------------

// Move

// float x = 1;
inline void Move::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline float Move::x() const {
  // @@protoc_insertion_point(field_get:protos.Move.x)
  return _internal_x();
}
inline void Move::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:protos.Move.x)
}
inline float Move::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Move::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void Move::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float Move::y() const {
  // @@protoc_insertion_point(field_get:protos.Move.y)
  return _internal_y();
}
inline void Move::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:protos.Move.y)
}
inline float Move::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Move::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// TurnNeck

// float moment = 1;
inline void TurnNeck::clear_moment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.moment_ = 0;
}
inline float TurnNeck::moment() const {
  // @@protoc_insertion_point(field_get:protos.TurnNeck.moment)
  return _internal_moment();
}
inline void TurnNeck::set_moment(float value) {
  _internal_set_moment(value);
  // @@protoc_insertion_point(field_set:protos.TurnNeck.moment)
}
inline float TurnNeck::_internal_moment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.moment_;
}
inline void TurnNeck::_internal_set_moment(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.moment_ = value;
}

// -------------------------------------------------------------------

// ChangeView

// .protos.ViewWidth view_width = 1;
inline void ChangeView::clear_view_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.view_width_ = 0;
}
inline ::protos::ViewWidth ChangeView::view_width() const {
  // @@protoc_insertion_point(field_get:protos.ChangeView.view_width)
  return _internal_view_width();
}
inline void ChangeView::set_view_width(::protos::ViewWidth value) {
  _internal_set_view_width(value);
  // @@protoc_insertion_point(field_set:protos.ChangeView.view_width)
}
inline ::protos::ViewWidth ChangeView::_internal_view_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::ViewWidth>(_impl_.view_width_);
}
inline void ChangeView::_internal_set_view_width(::protos::ViewWidth value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.view_width_ = value;
}

// -------------------------------------------------------------------

// BallMessage

// .protos.Vector2D ball_position = 1;
inline bool BallMessage::has_ball_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_position_ != nullptr);
  return value;
}
inline void BallMessage::clear_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ball_position_ != nullptr) _impl_.ball_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& BallMessage::_internal_ball_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.ball_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallMessage::ball_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.BallMessage.ball_position)
  return _internal_ball_position();
}
inline void BallMessage::unsafe_arena_set_allocated_ball_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ball_position_);
  }
  _impl_.ball_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallMessage.ball_position)
}
inline ::protos::Vector2D* BallMessage::release_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* BallMessage::unsafe_arena_release_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.BallMessage.ball_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallMessage::_internal_mutable_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ball_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.ball_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.ball_position_;
}
inline ::protos::Vector2D* BallMessage::mutable_ball_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_ball_position();
  // @@protoc_insertion_point(field_mutable:protos.BallMessage.ball_position)
  return _msg;
}
inline void BallMessage::set_allocated_ball_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.ball_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ball_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.BallMessage.ball_position)
}

// .protos.Vector2D ball_velocity = 2;
inline bool BallMessage::has_ball_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_velocity_ != nullptr);
  return value;
}
inline void BallMessage::clear_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ball_velocity_ != nullptr) _impl_.ball_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& BallMessage::_internal_ball_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.ball_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallMessage::ball_velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.BallMessage.ball_velocity)
  return _internal_ball_velocity();
}
inline void BallMessage::unsafe_arena_set_allocated_ball_velocity(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ball_velocity_);
  }
  _impl_.ball_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallMessage.ball_velocity)
}
inline ::protos::Vector2D* BallMessage::release_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* BallMessage::unsafe_arena_release_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.BallMessage.ball_velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallMessage::_internal_mutable_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ball_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.ball_velocity_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.ball_velocity_;
}
inline ::protos::Vector2D* BallMessage::mutable_ball_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_ball_velocity();
  // @@protoc_insertion_point(field_mutable:protos.BallMessage.ball_velocity)
  return _msg;
}
inline void BallMessage::set_allocated_ball_velocity(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.ball_velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.ball_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.BallMessage.ball_velocity)
}

// -------------------------------------------------------------------

// PassMessage

// int32 receiver_uniform_number = 1;
inline void PassMessage::clear_receiver_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.receiver_uniform_number_ = 0;
}
inline ::int32_t PassMessage::receiver_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.PassMessage.receiver_uniform_number)
  return _internal_receiver_uniform_number();
}
inline void PassMessage::set_receiver_uniform_number(::int32_t value) {
  _internal_set_receiver_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.PassMessage.receiver_uniform_number)
}
inline ::int32_t PassMessage::_internal_receiver_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.receiver_uniform_number_;
}
inline void PassMessage::_internal_set_receiver_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.receiver_uniform_number_ = value;
}

// .protos.Vector2D receiver_point = 2;
inline bool PassMessage::has_receiver_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.receiver_point_ != nullptr);
  return value;
}
inline void PassMessage::clear_receiver_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.receiver_point_ != nullptr) _impl_.receiver_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& PassMessage::_internal_receiver_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.receiver_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& PassMessage::receiver_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PassMessage.receiver_point)
  return _internal_receiver_point();
}
inline void PassMessage::unsafe_arena_set_allocated_receiver_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.receiver_point_);
  }
  _impl_.receiver_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PassMessage.receiver_point)
}
inline ::protos::Vector2D* PassMessage::release_receiver_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.receiver_point_;
  _impl_.receiver_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* PassMessage::unsafe_arena_release_receiver_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.PassMessage.receiver_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.receiver_point_;
  _impl_.receiver_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* PassMessage::_internal_mutable_receiver_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.receiver_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.receiver_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.receiver_point_;
}
inline ::protos::Vector2D* PassMessage::mutable_receiver_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_receiver_point();
  // @@protoc_insertion_point(field_mutable:protos.PassMessage.receiver_point)
  return _msg;
}
inline void PassMessage::set_allocated_receiver_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.receiver_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.receiver_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.PassMessage.receiver_point)
}

// .protos.Vector2D ball_position = 3;
inline bool PassMessage::has_ball_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_position_ != nullptr);
  return value;
}
inline void PassMessage::clear_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ball_position_ != nullptr) _impl_.ball_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& PassMessage::_internal_ball_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.ball_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& PassMessage::ball_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PassMessage.ball_position)
  return _internal_ball_position();
}
inline void PassMessage::unsafe_arena_set_allocated_ball_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ball_position_);
  }
  _impl_.ball_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PassMessage.ball_position)
}
inline ::protos::Vector2D* PassMessage::release_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* PassMessage::unsafe_arena_release_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.PassMessage.ball_position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* PassMessage::_internal_mutable_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ball_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.ball_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.ball_position_;
}
inline ::protos::Vector2D* PassMessage::mutable_ball_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_ball_position();
  // @@protoc_insertion_point(field_mutable:protos.PassMessage.ball_position)
  return _msg;
}
inline void PassMessage::set_allocated_ball_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.ball_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.ball_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.PassMessage.ball_position)
}

// .protos.Vector2D ball_velocity = 4;
inline bool PassMessage::has_ball_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_velocity_ != nullptr);
  return value;
}
inline void PassMessage::clear_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ball_velocity_ != nullptr) _impl_.ball_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& PassMessage::_internal_ball_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.ball_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& PassMessage::ball_velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PassMessage.ball_velocity)
  return _internal_ball_velocity();
}
inline void PassMessage::unsafe_arena_set_allocated_ball_velocity(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ball_velocity_);
  }
  _impl_.ball_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PassMessage.ball_velocity)
}
inline ::protos::Vector2D* PassMessage::release_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* released = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* PassMessage::unsafe_arena_release_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.PassMessage.ball_velocity)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* PassMessage::_internal_mutable_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ball_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.ball_velocity_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.ball_velocity_;
}
inline ::protos::Vector2D* PassMessage::mutable_ball_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_ball_velocity();
  // @@protoc_insertion_point(field_mutable:protos.PassMessage.ball_velocity)
  return _msg;
}
inline void PassMessage::set_allocated_ball_velocity(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.ball_velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.ball_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.PassMessage.ball_velocity)
}

// -------------------------------------------------------------------

// InterceptMessage

// bool our = 1;
inline void InterceptMessage::clear_our() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.our_ = false;
}
inline bool InterceptMessage::our() const {
  // @@protoc_insertion_point(field_get:protos.InterceptMessage.our)
  return _internal_our();
}
inline void InterceptMessage::set_our(bool value) {
  _internal_set_our(value);
  // @@protoc_insertion_point(field_set:protos.InterceptMessage.our)
}
inline bool InterceptMessage::_internal_our() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.our_;
}
inline void InterceptMessage::_internal_set_our(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.our_ = value;
}

// int32 uniform_number = 2;
inline void InterceptMessage::clear_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_ = 0;
}
inline ::int32_t InterceptMessage::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.InterceptMessage.uniform_number)
  return _internal_uniform_number();
}
inline void InterceptMessage::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.InterceptMessage.uniform_number)
}
inline ::int32_t InterceptMessage::_internal_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_;
}
inline void InterceptMessage::_internal_set_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_ = value;
}

// int32 cycle = 3;
inline void InterceptMessage::clear_cycle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cycle_ = 0;
}
inline ::int32_t InterceptMessage::cycle() const {
  // @@protoc_insertion_point(field_get:protos.InterceptMessage.cycle)
  return _internal_cycle();
}
inline void InterceptMessage::set_cycle(::int32_t value) {
  _internal_set_cycle(value);
  // @@protoc_insertion_point(field_set:protos.InterceptMessage.cycle)
}
inline ::int32_t InterceptMessage::_internal_cycle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cycle_;
}
inline void InterceptMessage::_internal_set_cycle(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cycle_ = value;
}

// -------------------------------------------------------------------

// GoalieMessage

// int32 goalie_uniform_number = 1;
inline void GoalieMessage::clear_goalie_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goalie_uniform_number_ = 0;
}
inline ::int32_t GoalieMessage::goalie_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.GoalieMessage.goalie_uniform_number)
  return _internal_goalie_uniform_number();
}
inline void GoalieMessage::set_goalie_uniform_number(::int32_t value) {
  _internal_set_goalie_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.GoalieMessage.goalie_uniform_number)
}
inline ::int32_t GoalieMessage::_internal_goalie_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goalie_uniform_number_;
}
inline void GoalieMessage::_internal_set_goalie_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.goalie_uniform_number_ = value;
}

// .protos.Vector2D goalie_position = 2;
inline bool GoalieMessage::has_goalie_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.goalie_position_ != nullptr);
  return value;
}
inline void GoalieMessage::clear_goalie_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.goalie_position_ != nullptr) _impl_.goalie_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& GoalieMessage::_internal_goalie_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.goalie_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& GoalieMessage::goalie_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.GoalieMessage.goalie_position)
  return _internal_goalie_position();
}
inline void GoalieMessage::unsafe_arena_set_allocated_goalie_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.goalie_position_);
  }
  _impl_.goalie_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.GoalieMessage.goalie_position)
}
inline ::protos::Vector2D* GoalieMessage::release_goalie_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.goalie_position_;
  _impl_.goalie_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* GoalieMessage::unsafe_arena_release_goalie_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.GoalieMessage.goalie_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.goalie_position_;
  _impl_.goalie_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* GoalieMessage::_internal_mutable_goalie_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.goalie_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.goalie_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.goalie_position_;
}
inline ::protos::Vector2D* GoalieMessage::mutable_goalie_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_goalie_position();
  // @@protoc_insertion_point(field_mutable:protos.GoalieMessage.goalie_position)
  return _msg;
}
inline void GoalieMessage::set_allocated_goalie_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.goalie_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.goalie_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.GoalieMessage.goalie_position)
}

// float goalie_body_direction = 3;
inline void GoalieMessage::clear_goalie_body_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goalie_body_direction_ = 0;
}
inline float GoalieMessage::goalie_body_direction() const {
  // @@protoc_insertion_point(field_get:protos.GoalieMessage.goalie_body_direction)
  return _internal_goalie_body_direction();
}
inline void GoalieMessage::set_goalie_body_direction(float value) {
  _internal_set_goalie_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.GoalieMessage.goalie_body_direction)
}
inline float GoalieMessage::_internal_goalie_body_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goalie_body_direction_;
}
inline void GoalieMessage::_internal_set_goalie_body_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.goalie_body_direction_ = value;
}

// -------------------------------------------------------------------

// GoalieAndPlayerMessage

// int32 goalie_uniform_number = 1;
inline void GoalieAndPlayerMessage::clear_goalie_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goalie_uniform_number_ = 0;
}
inline ::int32_t GoalieAndPlayerMessage::goalie_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.GoalieAndPlayerMessage.goalie_uniform_number)
  return _internal_goalie_uniform_number();
}
inline void GoalieAndPlayerMessage::set_goalie_uniform_number(::int32_t value) {
  _internal_set_goalie_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.GoalieAndPlayerMessage.goalie_uniform_number)
}
inline ::int32_t GoalieAndPlayerMessage::_internal_goalie_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goalie_uniform_number_;
}
inline void GoalieAndPlayerMessage::_internal_set_goalie_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.goalie_uniform_number_ = value;
}

// .protos.Vector2D goalie_position = 2;
inline bool GoalieAndPlayerMessage::has_goalie_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.goalie_position_ != nullptr);
  return value;
}
inline void GoalieAndPlayerMessage::clear_goalie_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.goalie_position_ != nullptr) _impl_.goalie_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& GoalieAndPlayerMessage::_internal_goalie_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.goalie_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& GoalieAndPlayerMessage::goalie_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.GoalieAndPlayerMessage.goalie_position)
  return _internal_goalie_position();
}
inline void GoalieAndPlayerMessage::unsafe_arena_set_allocated_goalie_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.goalie_position_);
  }
  _impl_.goalie_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.GoalieAndPlayerMessage.goalie_position)
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::release_goalie_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.goalie_position_;
  _impl_.goalie_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::unsafe_arena_release_goalie_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.GoalieAndPlayerMessage.goalie_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.goalie_position_;
  _impl_.goalie_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::_internal_mutable_goalie_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.goalie_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.goalie_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.goalie_position_;
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::mutable_goalie_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_goalie_position();
  // @@protoc_insertion_point(field_mutable:protos.GoalieAndPlayerMessage.goalie_position)
  return _msg;
}
inline void GoalieAndPlayerMessage::set_allocated_goalie_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.goalie_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.goalie_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.GoalieAndPlayerMessage.goalie_position)
}

// float goalie_body_direction = 3;
inline void GoalieAndPlayerMessage::clear_goalie_body_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goalie_body_direction_ = 0;
}
inline float GoalieAndPlayerMessage::goalie_body_direction() const {
  // @@protoc_insertion_point(field_get:protos.GoalieAndPlayerMessage.goalie_body_direction)
  return _internal_goalie_body_direction();
}
inline void GoalieAndPlayerMessage::set_goalie_body_direction(float value) {
  _internal_set_goalie_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.GoalieAndPlayerMessage.goalie_body_direction)
}
inline float GoalieAndPlayerMessage::_internal_goalie_body_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goalie_body_direction_;
}
inline void GoalieAndPlayerMessage::_internal_set_goalie_body_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.goalie_body_direction_ = value;
}

// int32 player_uniform_number = 4;
inline void GoalieAndPlayerMessage::clear_player_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_uniform_number_ = 0;
}
inline ::int32_t GoalieAndPlayerMessage::player_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.GoalieAndPlayerMessage.player_uniform_number)
  return _internal_player_uniform_number();
}
inline void GoalieAndPlayerMessage::set_player_uniform_number(::int32_t value) {
  _internal_set_player_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.GoalieAndPlayerMessage.player_uniform_number)
}
inline ::int32_t GoalieAndPlayerMessage::_internal_player_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_uniform_number_;
}
inline void GoalieAndPlayerMessage::_internal_set_player_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_uniform_number_ = value;
}

// .protos.Vector2D player_position = 5;
inline bool GoalieAndPlayerMessage::has_player_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_position_ != nullptr);
  return value;
}
inline void GoalieAndPlayerMessage::clear_player_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_position_ != nullptr) _impl_.player_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& GoalieAndPlayerMessage::_internal_player_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.player_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& GoalieAndPlayerMessage::player_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.GoalieAndPlayerMessage.player_position)
  return _internal_player_position();
}
inline void GoalieAndPlayerMessage::unsafe_arena_set_allocated_player_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_position_);
  }
  _impl_.player_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.GoalieAndPlayerMessage.player_position)
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::release_player_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.player_position_;
  _impl_.player_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::unsafe_arena_release_player_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.GoalieAndPlayerMessage.player_position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.player_position_;
  _impl_.player_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::_internal_mutable_player_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.player_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.player_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.player_position_;
}
inline ::protos::Vector2D* GoalieAndPlayerMessage::mutable_player_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_player_position();
  // @@protoc_insertion_point(field_mutable:protos.GoalieAndPlayerMessage.player_position)
  return _msg;
}
inline void GoalieAndPlayerMessage::set_allocated_player_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.player_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.player_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.GoalieAndPlayerMessage.player_position)
}

// -------------------------------------------------------------------

// OffsideLineMessage

// float offside_line_x = 1;
inline void OffsideLineMessage::clear_offside_line_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offside_line_x_ = 0;
}
inline float OffsideLineMessage::offside_line_x() const {
  // @@protoc_insertion_point(field_get:protos.OffsideLineMessage.offside_line_x)
  return _internal_offside_line_x();
}
inline void OffsideLineMessage::set_offside_line_x(float value) {
  _internal_set_offside_line_x(value);
  // @@protoc_insertion_point(field_set:protos.OffsideLineMessage.offside_line_x)
}
inline float OffsideLineMessage::_internal_offside_line_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offside_line_x_;
}
inline void OffsideLineMessage::_internal_set_offside_line_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.offside_line_x_ = value;
}

// -------------------------------------------------------------------

// DefenseLineMessage

// float defense_line_x = 1;
inline void DefenseLineMessage::clear_defense_line_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.defense_line_x_ = 0;
}
inline float DefenseLineMessage::defense_line_x() const {
  // @@protoc_insertion_point(field_get:protos.DefenseLineMessage.defense_line_x)
  return _internal_defense_line_x();
}
inline void DefenseLineMessage::set_defense_line_x(float value) {
  _internal_set_defense_line_x(value);
  // @@protoc_insertion_point(field_set:protos.DefenseLineMessage.defense_line_x)
}
inline float DefenseLineMessage::_internal_defense_line_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.defense_line_x_;
}
inline void DefenseLineMessage::_internal_set_defense_line_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.defense_line_x_ = value;
}

// -------------------------------------------------------------------

// WaitRequestMessage

// -------------------------------------------------------------------

// SetplayMessage

// int32 wait_step = 1;
inline void SetplayMessage::clear_wait_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wait_step_ = 0;
}
inline ::int32_t SetplayMessage::wait_step() const {
  // @@protoc_insertion_point(field_get:protos.SetplayMessage.wait_step)
  return _internal_wait_step();
}
inline void SetplayMessage::set_wait_step(::int32_t value) {
  _internal_set_wait_step(value);
  // @@protoc_insertion_point(field_set:protos.SetplayMessage.wait_step)
}
inline ::int32_t SetplayMessage::_internal_wait_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wait_step_;
}
inline void SetplayMessage::_internal_set_wait_step(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wait_step_ = value;
}

// -------------------------------------------------------------------

// PassRequestMessage

// .protos.Vector2D target_point = 1;
inline bool PassRequestMessage::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void PassRequestMessage::clear_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& PassRequestMessage::_internal_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& PassRequestMessage::target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PassRequestMessage.target_point)
  return _internal_target_point();
}
inline void PassRequestMessage::unsafe_arena_set_allocated_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PassRequestMessage.target_point)
}
inline ::protos::Vector2D* PassRequestMessage::release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* PassRequestMessage::unsafe_arena_release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.PassRequestMessage.target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* PassRequestMessage::_internal_mutable_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* PassRequestMessage::mutable_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.PassRequestMessage.target_point)
  return _msg;
}
inline void PassRequestMessage::set_allocated_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.PassRequestMessage.target_point)
}

// -------------------------------------------------------------------

// StaminaMessage

// float stamina = 1;
inline void StaminaMessage::clear_stamina() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stamina_ = 0;
}
inline float StaminaMessage::stamina() const {
  // @@protoc_insertion_point(field_get:protos.StaminaMessage.stamina)
  return _internal_stamina();
}
inline void StaminaMessage::set_stamina(float value) {
  _internal_set_stamina(value);
  // @@protoc_insertion_point(field_set:protos.StaminaMessage.stamina)
}
inline float StaminaMessage::_internal_stamina() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stamina_;
}
inline void StaminaMessage::_internal_set_stamina(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stamina_ = value;
}

// -------------------------------------------------------------------

// RecoveryMessage

// float recovery = 1;
inline void RecoveryMessage::clear_recovery() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recovery_ = 0;
}
inline float RecoveryMessage::recovery() const {
  // @@protoc_insertion_point(field_get:protos.RecoveryMessage.recovery)
  return _internal_recovery();
}
inline void RecoveryMessage::set_recovery(float value) {
  _internal_set_recovery(value);
  // @@protoc_insertion_point(field_set:protos.RecoveryMessage.recovery)
}
inline float RecoveryMessage::_internal_recovery() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recovery_;
}
inline void RecoveryMessage::_internal_set_recovery(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recovery_ = value;
}

// -------------------------------------------------------------------

// StaminaCapacityMessage

// float stamina_capacity = 1;
inline void StaminaCapacityMessage::clear_stamina_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stamina_capacity_ = 0;
}
inline float StaminaCapacityMessage::stamina_capacity() const {
  // @@protoc_insertion_point(field_get:protos.StaminaCapacityMessage.stamina_capacity)
  return _internal_stamina_capacity();
}
inline void StaminaCapacityMessage::set_stamina_capacity(float value) {
  _internal_set_stamina_capacity(value);
  // @@protoc_insertion_point(field_set:protos.StaminaCapacityMessage.stamina_capacity)
}
inline float StaminaCapacityMessage::_internal_stamina_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stamina_capacity_;
}
inline void StaminaCapacityMessage::_internal_set_stamina_capacity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stamina_capacity_ = value;
}

// -------------------------------------------------------------------

// DribbleMessage

// .protos.Vector2D target_point = 1;
inline bool DribbleMessage::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void DribbleMessage::clear_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& DribbleMessage::_internal_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& DribbleMessage::target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.DribbleMessage.target_point)
  return _internal_target_point();
}
inline void DribbleMessage::unsafe_arena_set_allocated_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.DribbleMessage.target_point)
}
inline ::protos::Vector2D* DribbleMessage::release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* DribbleMessage::unsafe_arena_release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.DribbleMessage.target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* DribbleMessage::_internal_mutable_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* DribbleMessage::mutable_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.DribbleMessage.target_point)
  return _msg;
}
inline void DribbleMessage::set_allocated_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.DribbleMessage.target_point)
}

// int32 queue_count = 2;
inline void DribbleMessage::clear_queue_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.queue_count_ = 0;
}
inline ::int32_t DribbleMessage::queue_count() const {
  // @@protoc_insertion_point(field_get:protos.DribbleMessage.queue_count)
  return _internal_queue_count();
}
inline void DribbleMessage::set_queue_count(::int32_t value) {
  _internal_set_queue_count(value);
  // @@protoc_insertion_point(field_set:protos.DribbleMessage.queue_count)
}
inline ::int32_t DribbleMessage::_internal_queue_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.queue_count_;
}
inline void DribbleMessage::_internal_set_queue_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.queue_count_ = value;
}

// -------------------------------------------------------------------

// BallGoalieMessage

// .protos.Vector2D ball_position = 1;
inline bool BallGoalieMessage::has_ball_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_position_ != nullptr);
  return value;
}
inline void BallGoalieMessage::clear_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ball_position_ != nullptr) _impl_.ball_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& BallGoalieMessage::_internal_ball_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.ball_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallGoalieMessage::ball_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.BallGoalieMessage.ball_position)
  return _internal_ball_position();
}
inline void BallGoalieMessage::unsafe_arena_set_allocated_ball_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ball_position_);
  }
  _impl_.ball_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallGoalieMessage.ball_position)
}
inline ::protos::Vector2D* BallGoalieMessage::release_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* BallGoalieMessage::unsafe_arena_release_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.BallGoalieMessage.ball_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallGoalieMessage::_internal_mutable_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ball_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.ball_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.ball_position_;
}
inline ::protos::Vector2D* BallGoalieMessage::mutable_ball_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_ball_position();
  // @@protoc_insertion_point(field_mutable:protos.BallGoalieMessage.ball_position)
  return _msg;
}
inline void BallGoalieMessage::set_allocated_ball_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.ball_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ball_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.BallGoalieMessage.ball_position)
}

// .protos.Vector2D ball_velocity = 2;
inline bool BallGoalieMessage::has_ball_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_velocity_ != nullptr);
  return value;
}
inline void BallGoalieMessage::clear_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ball_velocity_ != nullptr) _impl_.ball_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& BallGoalieMessage::_internal_ball_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.ball_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallGoalieMessage::ball_velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.BallGoalieMessage.ball_velocity)
  return _internal_ball_velocity();
}
inline void BallGoalieMessage::unsafe_arena_set_allocated_ball_velocity(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ball_velocity_);
  }
  _impl_.ball_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallGoalieMessage.ball_velocity)
}
inline ::protos::Vector2D* BallGoalieMessage::release_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* BallGoalieMessage::unsafe_arena_release_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.BallGoalieMessage.ball_velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallGoalieMessage::_internal_mutable_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ball_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.ball_velocity_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.ball_velocity_;
}
inline ::protos::Vector2D* BallGoalieMessage::mutable_ball_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_ball_velocity();
  // @@protoc_insertion_point(field_mutable:protos.BallGoalieMessage.ball_velocity)
  return _msg;
}
inline void BallGoalieMessage::set_allocated_ball_velocity(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.ball_velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.ball_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.BallGoalieMessage.ball_velocity)
}

// .protos.Vector2D goalie_position = 3;
inline bool BallGoalieMessage::has_goalie_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.goalie_position_ != nullptr);
  return value;
}
inline void BallGoalieMessage::clear_goalie_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.goalie_position_ != nullptr) _impl_.goalie_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& BallGoalieMessage::_internal_goalie_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.goalie_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallGoalieMessage::goalie_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.BallGoalieMessage.goalie_position)
  return _internal_goalie_position();
}
inline void BallGoalieMessage::unsafe_arena_set_allocated_goalie_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.goalie_position_);
  }
  _impl_.goalie_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallGoalieMessage.goalie_position)
}
inline ::protos::Vector2D* BallGoalieMessage::release_goalie_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* released = _impl_.goalie_position_;
  _impl_.goalie_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* BallGoalieMessage::unsafe_arena_release_goalie_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.BallGoalieMessage.goalie_position)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.goalie_position_;
  _impl_.goalie_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallGoalieMessage::_internal_mutable_goalie_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.goalie_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.goalie_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.goalie_position_;
}
inline ::protos::Vector2D* BallGoalieMessage::mutable_goalie_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_goalie_position();
  // @@protoc_insertion_point(field_mutable:protos.BallGoalieMessage.goalie_position)
  return _msg;
}
inline void BallGoalieMessage::set_allocated_goalie_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.goalie_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.goalie_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.BallGoalieMessage.goalie_position)
}

// float goalie_body_direction = 4;
inline void BallGoalieMessage::clear_goalie_body_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goalie_body_direction_ = 0;
}
inline float BallGoalieMessage::goalie_body_direction() const {
  // @@protoc_insertion_point(field_get:protos.BallGoalieMessage.goalie_body_direction)
  return _internal_goalie_body_direction();
}
inline void BallGoalieMessage::set_goalie_body_direction(float value) {
  _internal_set_goalie_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.BallGoalieMessage.goalie_body_direction)
}
inline float BallGoalieMessage::_internal_goalie_body_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goalie_body_direction_;
}
inline void BallGoalieMessage::_internal_set_goalie_body_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.goalie_body_direction_ = value;
}

// -------------------------------------------------------------------

// OnePlayerMessage

// int32 uniform_number = 1;
inline void OnePlayerMessage::clear_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_ = 0;
}
inline ::int32_t OnePlayerMessage::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.OnePlayerMessage.uniform_number)
  return _internal_uniform_number();
}
inline void OnePlayerMessage::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.OnePlayerMessage.uniform_number)
}
inline ::int32_t OnePlayerMessage::_internal_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_;
}
inline void OnePlayerMessage::_internal_set_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_ = value;
}

// .protos.Vector2D position = 2;
inline bool OnePlayerMessage::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void OnePlayerMessage::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& OnePlayerMessage::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& OnePlayerMessage::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.OnePlayerMessage.position)
  return _internal_position();
}
inline void OnePlayerMessage::unsafe_arena_set_allocated_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.OnePlayerMessage.position)
}
inline ::protos::Vector2D* OnePlayerMessage::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* OnePlayerMessage::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.OnePlayerMessage.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* OnePlayerMessage::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* OnePlayerMessage::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.OnePlayerMessage.position)
  return _msg;
}
inline void OnePlayerMessage::set_allocated_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.OnePlayerMessage.position)
}

// -------------------------------------------------------------------

// TwoPlayerMessage

// int32 first_uniform_number = 1;
inline void TwoPlayerMessage::clear_first_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.first_uniform_number_ = 0;
}
inline ::int32_t TwoPlayerMessage::first_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.TwoPlayerMessage.first_uniform_number)
  return _internal_first_uniform_number();
}
inline void TwoPlayerMessage::set_first_uniform_number(::int32_t value) {
  _internal_set_first_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.TwoPlayerMessage.first_uniform_number)
}
inline ::int32_t TwoPlayerMessage::_internal_first_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.first_uniform_number_;
}
inline void TwoPlayerMessage::_internal_set_first_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.first_uniform_number_ = value;
}

// .protos.Vector2D first_position = 2;
inline bool TwoPlayerMessage::has_first_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.first_position_ != nullptr);
  return value;
}
inline void TwoPlayerMessage::clear_first_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.first_position_ != nullptr) _impl_.first_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& TwoPlayerMessage::_internal_first_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.first_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& TwoPlayerMessage::first_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.TwoPlayerMessage.first_position)
  return _internal_first_position();
}
inline void TwoPlayerMessage::unsafe_arena_set_allocated_first_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.first_position_);
  }
  _impl_.first_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.TwoPlayerMessage.first_position)
}
inline ::protos::Vector2D* TwoPlayerMessage::release_first_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.first_position_;
  _impl_.first_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* TwoPlayerMessage::unsafe_arena_release_first_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.TwoPlayerMessage.first_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.first_position_;
  _impl_.first_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* TwoPlayerMessage::_internal_mutable_first_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.first_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.first_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.first_position_;
}
inline ::protos::Vector2D* TwoPlayerMessage::mutable_first_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_first_position();
  // @@protoc_insertion_point(field_mutable:protos.TwoPlayerMessage.first_position)
  return _msg;
}
inline void TwoPlayerMessage::set_allocated_first_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.first_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.first_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.TwoPlayerMessage.first_position)
}

// int32 second_uniform_number = 3;
inline void TwoPlayerMessage::clear_second_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.second_uniform_number_ = 0;
}
inline ::int32_t TwoPlayerMessage::second_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.TwoPlayerMessage.second_uniform_number)
  return _internal_second_uniform_number();
}
inline void TwoPlayerMessage::set_second_uniform_number(::int32_t value) {
  _internal_set_second_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.TwoPlayerMessage.second_uniform_number)
}
inline ::int32_t TwoPlayerMessage::_internal_second_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.second_uniform_number_;
}
inline void TwoPlayerMessage::_internal_set_second_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.second_uniform_number_ = value;
}

// .protos.Vector2D second_position = 4;
inline bool TwoPlayerMessage::has_second_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.second_position_ != nullptr);
  return value;
}
inline void TwoPlayerMessage::clear_second_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.second_position_ != nullptr) _impl_.second_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& TwoPlayerMessage::_internal_second_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.second_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& TwoPlayerMessage::second_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.TwoPlayerMessage.second_position)
  return _internal_second_position();
}
inline void TwoPlayerMessage::unsafe_arena_set_allocated_second_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.second_position_);
  }
  _impl_.second_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.TwoPlayerMessage.second_position)
}
inline ::protos::Vector2D* TwoPlayerMessage::release_second_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.second_position_;
  _impl_.second_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* TwoPlayerMessage::unsafe_arena_release_second_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.TwoPlayerMessage.second_position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.second_position_;
  _impl_.second_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* TwoPlayerMessage::_internal_mutable_second_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.second_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.second_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.second_position_;
}
inline ::protos::Vector2D* TwoPlayerMessage::mutable_second_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_second_position();
  // @@protoc_insertion_point(field_mutable:protos.TwoPlayerMessage.second_position)
  return _msg;
}
inline void TwoPlayerMessage::set_allocated_second_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.second_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.second_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.TwoPlayerMessage.second_position)
}

// -------------------------------------------------------------------

// ThreePlayerMessage

// int32 first_uniform_number = 1;
inline void ThreePlayerMessage::clear_first_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.first_uniform_number_ = 0;
}
inline ::int32_t ThreePlayerMessage::first_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.ThreePlayerMessage.first_uniform_number)
  return _internal_first_uniform_number();
}
inline void ThreePlayerMessage::set_first_uniform_number(::int32_t value) {
  _internal_set_first_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.ThreePlayerMessage.first_uniform_number)
}
inline ::int32_t ThreePlayerMessage::_internal_first_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.first_uniform_number_;
}
inline void ThreePlayerMessage::_internal_set_first_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.first_uniform_number_ = value;
}

// .protos.Vector2D first_position = 2;
inline bool ThreePlayerMessage::has_first_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.first_position_ != nullptr);
  return value;
}
inline void ThreePlayerMessage::clear_first_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.first_position_ != nullptr) _impl_.first_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& ThreePlayerMessage::_internal_first_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.first_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& ThreePlayerMessage::first_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ThreePlayerMessage.first_position)
  return _internal_first_position();
}
inline void ThreePlayerMessage::unsafe_arena_set_allocated_first_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.first_position_);
  }
  _impl_.first_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.ThreePlayerMessage.first_position)
}
inline ::protos::Vector2D* ThreePlayerMessage::release_first_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.first_position_;
  _impl_.first_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* ThreePlayerMessage::unsafe_arena_release_first_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ThreePlayerMessage.first_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.first_position_;
  _impl_.first_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* ThreePlayerMessage::_internal_mutable_first_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.first_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.first_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.first_position_;
}
inline ::protos::Vector2D* ThreePlayerMessage::mutable_first_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_first_position();
  // @@protoc_insertion_point(field_mutable:protos.ThreePlayerMessage.first_position)
  return _msg;
}
inline void ThreePlayerMessage::set_allocated_first_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.first_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.first_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.ThreePlayerMessage.first_position)
}

// int32 second_uniform_number = 3;
inline void ThreePlayerMessage::clear_second_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.second_uniform_number_ = 0;
}
inline ::int32_t ThreePlayerMessage::second_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.ThreePlayerMessage.second_uniform_number)
  return _internal_second_uniform_number();
}
inline void ThreePlayerMessage::set_second_uniform_number(::int32_t value) {
  _internal_set_second_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.ThreePlayerMessage.second_uniform_number)
}
inline ::int32_t ThreePlayerMessage::_internal_second_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.second_uniform_number_;
}
inline void ThreePlayerMessage::_internal_set_second_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.second_uniform_number_ = value;
}

// .protos.Vector2D second_position = 4;
inline bool ThreePlayerMessage::has_second_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.second_position_ != nullptr);
  return value;
}
inline void ThreePlayerMessage::clear_second_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.second_position_ != nullptr) _impl_.second_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& ThreePlayerMessage::_internal_second_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.second_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& ThreePlayerMessage::second_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ThreePlayerMessage.second_position)
  return _internal_second_position();
}
inline void ThreePlayerMessage::unsafe_arena_set_allocated_second_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.second_position_);
  }
  _impl_.second_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.ThreePlayerMessage.second_position)
}
inline ::protos::Vector2D* ThreePlayerMessage::release_second_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.second_position_;
  _impl_.second_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* ThreePlayerMessage::unsafe_arena_release_second_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ThreePlayerMessage.second_position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.second_position_;
  _impl_.second_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* ThreePlayerMessage::_internal_mutable_second_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.second_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.second_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.second_position_;
}
inline ::protos::Vector2D* ThreePlayerMessage::mutable_second_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_second_position();
  // @@protoc_insertion_point(field_mutable:protos.ThreePlayerMessage.second_position)
  return _msg;
}
inline void ThreePlayerMessage::set_allocated_second_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.second_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.second_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.ThreePlayerMessage.second_position)
}

// int32 third_uniform_number = 5;
inline void ThreePlayerMessage::clear_third_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.third_uniform_number_ = 0;
}
inline ::int32_t ThreePlayerMessage::third_uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.ThreePlayerMessage.third_uniform_number)
  return _internal_third_uniform_number();
}
inline void ThreePlayerMessage::set_third_uniform_number(::int32_t value) {
  _internal_set_third_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.ThreePlayerMessage.third_uniform_number)
}
inline ::int32_t ThreePlayerMessage::_internal_third_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.third_uniform_number_;
}
inline void ThreePlayerMessage::_internal_set_third_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.third_uniform_number_ = value;
}

// .protos.Vector2D third_position = 6;
inline bool ThreePlayerMessage::has_third_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.third_position_ != nullptr);
  return value;
}
inline void ThreePlayerMessage::clear_third_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.third_position_ != nullptr) _impl_.third_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& ThreePlayerMessage::_internal_third_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.third_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& ThreePlayerMessage::third_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ThreePlayerMessage.third_position)
  return _internal_third_position();
}
inline void ThreePlayerMessage::unsafe_arena_set_allocated_third_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.third_position_);
  }
  _impl_.third_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.ThreePlayerMessage.third_position)
}
inline ::protos::Vector2D* ThreePlayerMessage::release_third_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* released = _impl_.third_position_;
  _impl_.third_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* ThreePlayerMessage::unsafe_arena_release_third_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ThreePlayerMessage.third_position)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.third_position_;
  _impl_.third_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* ThreePlayerMessage::_internal_mutable_third_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.third_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.third_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.third_position_;
}
inline ::protos::Vector2D* ThreePlayerMessage::mutable_third_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_third_position();
  // @@protoc_insertion_point(field_mutable:protos.ThreePlayerMessage.third_position)
  return _msg;
}
inline void ThreePlayerMessage::set_allocated_third_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.third_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.third_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.ThreePlayerMessage.third_position)
}

// -------------------------------------------------------------------

// SelfMessage

// .protos.Vector2D self_position = 1;
inline bool SelfMessage::has_self_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.self_position_ != nullptr);
  return value;
}
inline void SelfMessage::clear_self_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.self_position_ != nullptr) _impl_.self_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& SelfMessage::_internal_self_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.self_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& SelfMessage::self_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.SelfMessage.self_position)
  return _internal_self_position();
}
inline void SelfMessage::unsafe_arena_set_allocated_self_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.self_position_);
  }
  _impl_.self_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.SelfMessage.self_position)
}
inline ::protos::Vector2D* SelfMessage::release_self_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.self_position_;
  _impl_.self_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* SelfMessage::unsafe_arena_release_self_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.SelfMessage.self_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.self_position_;
  _impl_.self_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* SelfMessage::_internal_mutable_self_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.self_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.self_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.self_position_;
}
inline ::protos::Vector2D* SelfMessage::mutable_self_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_self_position();
  // @@protoc_insertion_point(field_mutable:protos.SelfMessage.self_position)
  return _msg;
}
inline void SelfMessage::set_allocated_self_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.self_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.self_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.SelfMessage.self_position)
}

// float self_body_direction = 2;
inline void SelfMessage::clear_self_body_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.self_body_direction_ = 0;
}
inline float SelfMessage::self_body_direction() const {
  // @@protoc_insertion_point(field_get:protos.SelfMessage.self_body_direction)
  return _internal_self_body_direction();
}
inline void SelfMessage::set_self_body_direction(float value) {
  _internal_set_self_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.SelfMessage.self_body_direction)
}
inline float SelfMessage::_internal_self_body_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.self_body_direction_;
}
inline void SelfMessage::_internal_set_self_body_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.self_body_direction_ = value;
}

// float self_stamina = 3;
inline void SelfMessage::clear_self_stamina() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.self_stamina_ = 0;
}
inline float SelfMessage::self_stamina() const {
  // @@protoc_insertion_point(field_get:protos.SelfMessage.self_stamina)
  return _internal_self_stamina();
}
inline void SelfMessage::set_self_stamina(float value) {
  _internal_set_self_stamina(value);
  // @@protoc_insertion_point(field_set:protos.SelfMessage.self_stamina)
}
inline float SelfMessage::_internal_self_stamina() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.self_stamina_;
}
inline void SelfMessage::_internal_set_self_stamina(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.self_stamina_ = value;
}

// -------------------------------------------------------------------

// TeammateMessage

// int32 uniform_number = 1;
inline void TeammateMessage::clear_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_ = 0;
}
inline ::int32_t TeammateMessage::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.TeammateMessage.uniform_number)
  return _internal_uniform_number();
}
inline void TeammateMessage::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.TeammateMessage.uniform_number)
}
inline ::int32_t TeammateMessage::_internal_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_;
}
inline void TeammateMessage::_internal_set_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_ = value;
}

// .protos.Vector2D position = 2;
inline bool TeammateMessage::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void TeammateMessage::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& TeammateMessage::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& TeammateMessage::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.TeammateMessage.position)
  return _internal_position();
}
inline void TeammateMessage::unsafe_arena_set_allocated_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.TeammateMessage.position)
}
inline ::protos::Vector2D* TeammateMessage::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* TeammateMessage::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.TeammateMessage.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* TeammateMessage::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* TeammateMessage::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.TeammateMessage.position)
  return _msg;
}
inline void TeammateMessage::set_allocated_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.TeammateMessage.position)
}

// float body_direction = 3;
inline void TeammateMessage::clear_body_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_direction_ = 0;
}
inline float TeammateMessage::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.TeammateMessage.body_direction)
  return _internal_body_direction();
}
inline void TeammateMessage::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.TeammateMessage.body_direction)
}
inline float TeammateMessage::_internal_body_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_direction_;
}
inline void TeammateMessage::_internal_set_body_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.body_direction_ = value;
}

// -------------------------------------------------------------------

// OpponentMessage

// int32 uniform_number = 1;
inline void OpponentMessage::clear_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_ = 0;
}
inline ::int32_t OpponentMessage::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.OpponentMessage.uniform_number)
  return _internal_uniform_number();
}
inline void OpponentMessage::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.OpponentMessage.uniform_number)
}
inline ::int32_t OpponentMessage::_internal_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_;
}
inline void OpponentMessage::_internal_set_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_ = value;
}

// .protos.Vector2D position = 2;
inline bool OpponentMessage::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void OpponentMessage::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& OpponentMessage::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& OpponentMessage::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.OpponentMessage.position)
  return _internal_position();
}
inline void OpponentMessage::unsafe_arena_set_allocated_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.OpponentMessage.position)
}
inline ::protos::Vector2D* OpponentMessage::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* OpponentMessage::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.OpponentMessage.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* OpponentMessage::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* OpponentMessage::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.OpponentMessage.position)
  return _msg;
}
inline void OpponentMessage::set_allocated_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.OpponentMessage.position)
}

// float body_direction = 3;
inline void OpponentMessage::clear_body_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_direction_ = 0;
}
inline float OpponentMessage::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.OpponentMessage.body_direction)
  return _internal_body_direction();
}
inline void OpponentMessage::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.OpponentMessage.body_direction)
}
inline float OpponentMessage::_internal_body_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_direction_;
}
inline void OpponentMessage::_internal_set_body_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.body_direction_ = value;
}

// -------------------------------------------------------------------

// BallPlayerMessage

// .protos.Vector2D ball_position = 1;
inline bool BallPlayerMessage::has_ball_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_position_ != nullptr);
  return value;
}
inline void BallPlayerMessage::clear_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ball_position_ != nullptr) _impl_.ball_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& BallPlayerMessage::_internal_ball_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.ball_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallPlayerMessage::ball_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.BallPlayerMessage.ball_position)
  return _internal_ball_position();
}
inline void BallPlayerMessage::unsafe_arena_set_allocated_ball_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ball_position_);
  }
  _impl_.ball_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallPlayerMessage.ball_position)
}
inline ::protos::Vector2D* BallPlayerMessage::release_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* BallPlayerMessage::unsafe_arena_release_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.BallPlayerMessage.ball_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.ball_position_;
  _impl_.ball_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallPlayerMessage::_internal_mutable_ball_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ball_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.ball_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.ball_position_;
}
inline ::protos::Vector2D* BallPlayerMessage::mutable_ball_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_ball_position();
  // @@protoc_insertion_point(field_mutable:protos.BallPlayerMessage.ball_position)
  return _msg;
}
inline void BallPlayerMessage::set_allocated_ball_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.ball_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ball_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.BallPlayerMessage.ball_position)
}

// .protos.Vector2D ball_velocity = 2;
inline bool BallPlayerMessage::has_ball_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ball_velocity_ != nullptr);
  return value;
}
inline void BallPlayerMessage::clear_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ball_velocity_ != nullptr) _impl_.ball_velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& BallPlayerMessage::_internal_ball_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.ball_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallPlayerMessage::ball_velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.BallPlayerMessage.ball_velocity)
  return _internal_ball_velocity();
}
inline void BallPlayerMessage::unsafe_arena_set_allocated_ball_velocity(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ball_velocity_);
  }
  _impl_.ball_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallPlayerMessage.ball_velocity)
}
inline ::protos::Vector2D* BallPlayerMessage::release_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* BallPlayerMessage::unsafe_arena_release_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.BallPlayerMessage.ball_velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.ball_velocity_;
  _impl_.ball_velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallPlayerMessage::_internal_mutable_ball_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ball_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.ball_velocity_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.ball_velocity_;
}
inline ::protos::Vector2D* BallPlayerMessage::mutable_ball_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_ball_velocity();
  // @@protoc_insertion_point(field_mutable:protos.BallPlayerMessage.ball_velocity)
  return _msg;
}
inline void BallPlayerMessage::set_allocated_ball_velocity(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.ball_velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.ball_velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.BallPlayerMessage.ball_velocity)
}

// int32 uniform_number = 3;
inline void BallPlayerMessage::clear_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_ = 0;
}
inline ::int32_t BallPlayerMessage::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.BallPlayerMessage.uniform_number)
  return _internal_uniform_number();
}
inline void BallPlayerMessage::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.BallPlayerMessage.uniform_number)
}
inline ::int32_t BallPlayerMessage::_internal_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_;
}
inline void BallPlayerMessage::_internal_set_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_ = value;
}

// .protos.Vector2D player_position = 4;
inline bool BallPlayerMessage::has_player_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_position_ != nullptr);
  return value;
}
inline void BallPlayerMessage::clear_player_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_position_ != nullptr) _impl_.player_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& BallPlayerMessage::_internal_player_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.player_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& BallPlayerMessage::player_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.BallPlayerMessage.player_position)
  return _internal_player_position();
}
inline void BallPlayerMessage::unsafe_arena_set_allocated_player_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_position_);
  }
  _impl_.player_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.BallPlayerMessage.player_position)
}
inline ::protos::Vector2D* BallPlayerMessage::release_player_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* released = _impl_.player_position_;
  _impl_.player_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* BallPlayerMessage::unsafe_arena_release_player_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.BallPlayerMessage.player_position)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.player_position_;
  _impl_.player_position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* BallPlayerMessage::_internal_mutable_player_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.player_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.player_position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.player_position_;
}
inline ::protos::Vector2D* BallPlayerMessage::mutable_player_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_player_position();
  // @@protoc_insertion_point(field_mutable:protos.BallPlayerMessage.player_position)
  return _msg;
}
inline void BallPlayerMessage::set_allocated_player_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.player_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.player_position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.BallPlayerMessage.player_position)
}

// float body_direction = 5;
inline void BallPlayerMessage::clear_body_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_direction_ = 0;
}
inline float BallPlayerMessage::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.BallPlayerMessage.body_direction)
  return _internal_body_direction();
}
inline void BallPlayerMessage::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.BallPlayerMessage.body_direction)
}
inline float BallPlayerMessage::_internal_body_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_direction_;
}
inline void BallPlayerMessage::_internal_set_body_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.body_direction_ = value;
}

// -------------------------------------------------------------------

// Say

// .protos.BallMessage ball_message = 1;
inline bool Say::has_ball_message() const {
  return message_case() == kBallMessage;
}
inline bool Say::_internal_has_ball_message() const {
  return message_case() == kBallMessage;
}
inline void Say::set_has_ball_message() {
  _impl_._oneof_case_[0] = kBallMessage;
}
inline void Say::clear_ball_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kBallMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.ball_message_;
    }
    clear_has_message();
  }
}
inline ::protos::BallMessage* Say::release_ball_message() {
  // @@protoc_insertion_point(field_release:protos.Say.ball_message)
  if (message_case() == kBallMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.ball_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ball_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::BallMessage& Say::_internal_ball_message() const {
  return message_case() == kBallMessage ? *_impl_.message_.ball_message_ : reinterpret_cast<::protos::BallMessage&>(::protos::_BallMessage_default_instance_);
}
inline const ::protos::BallMessage& Say::ball_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.ball_message)
  return _internal_ball_message();
}
inline ::protos::BallMessage* Say::unsafe_arena_release_ball_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.ball_message)
  if (message_case() == kBallMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.ball_message_;
    _impl_.message_.ball_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_ball_message(::protos::BallMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_ball_message();
    _impl_.message_.ball_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.ball_message)
}
inline ::protos::BallMessage* Say::_internal_mutable_ball_message() {
  if (message_case() != kBallMessage) {
    clear_message();
    set_has_ball_message();
    _impl_.message_.ball_message_ = CreateMaybeMessage<::protos::BallMessage>(GetArena());
  }
  return _impl_.message_.ball_message_;
}
inline ::protos::BallMessage* Say::mutable_ball_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::BallMessage* _msg = _internal_mutable_ball_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.ball_message)
  return _msg;
}

// .protos.PassMessage pass_message = 2;
inline bool Say::has_pass_message() const {
  return message_case() == kPassMessage;
}
inline bool Say::_internal_has_pass_message() const {
  return message_case() == kPassMessage;
}
inline void Say::set_has_pass_message() {
  _impl_._oneof_case_[0] = kPassMessage;
}
inline void Say::clear_pass_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kPassMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.pass_message_;
    }
    clear_has_message();
  }
}
inline ::protos::PassMessage* Say::release_pass_message() {
  // @@protoc_insertion_point(field_release:protos.Say.pass_message)
  if (message_case() == kPassMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.pass_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.pass_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::PassMessage& Say::_internal_pass_message() const {
  return message_case() == kPassMessage ? *_impl_.message_.pass_message_ : reinterpret_cast<::protos::PassMessage&>(::protos::_PassMessage_default_instance_);
}
inline const ::protos::PassMessage& Say::pass_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.pass_message)
  return _internal_pass_message();
}
inline ::protos::PassMessage* Say::unsafe_arena_release_pass_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.pass_message)
  if (message_case() == kPassMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.pass_message_;
    _impl_.message_.pass_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_pass_message(::protos::PassMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_pass_message();
    _impl_.message_.pass_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.pass_message)
}
inline ::protos::PassMessage* Say::_internal_mutable_pass_message() {
  if (message_case() != kPassMessage) {
    clear_message();
    set_has_pass_message();
    _impl_.message_.pass_message_ = CreateMaybeMessage<::protos::PassMessage>(GetArena());
  }
  return _impl_.message_.pass_message_;
}
inline ::protos::PassMessage* Say::mutable_pass_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::PassMessage* _msg = _internal_mutable_pass_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.pass_message)
  return _msg;
}

// .protos.InterceptMessage intercept_message = 3;
inline bool Say::has_intercept_message() const {
  return message_case() == kInterceptMessage;
}
inline bool Say::_internal_has_intercept_message() const {
  return message_case() == kInterceptMessage;
}
inline void Say::set_has_intercept_message() {
  _impl_._oneof_case_[0] = kInterceptMessage;
}
inline void Say::clear_intercept_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kInterceptMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.intercept_message_;
    }
    clear_has_message();
  }
}
inline ::protos::InterceptMessage* Say::release_intercept_message() {
  // @@protoc_insertion_point(field_release:protos.Say.intercept_message)
  if (message_case() == kInterceptMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.intercept_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.intercept_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::InterceptMessage& Say::_internal_intercept_message() const {
  return message_case() == kInterceptMessage ? *_impl_.message_.intercept_message_ : reinterpret_cast<::protos::InterceptMessage&>(::protos::_InterceptMessage_default_instance_);
}
inline const ::protos::InterceptMessage& Say::intercept_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.intercept_message)
  return _internal_intercept_message();
}
inline ::protos::InterceptMessage* Say::unsafe_arena_release_intercept_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.intercept_message)
  if (message_case() == kInterceptMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.intercept_message_;
    _impl_.message_.intercept_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_intercept_message(::protos::InterceptMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_intercept_message();
    _impl_.message_.intercept_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.intercept_message)
}
inline ::protos::InterceptMessage* Say::_internal_mutable_intercept_message() {
  if (message_case() != kInterceptMessage) {
    clear_message();
    set_has_intercept_message();
    _impl_.message_.intercept_message_ = CreateMaybeMessage<::protos::InterceptMessage>(GetArena());
  }
  return _impl_.message_.intercept_message_;
}
inline ::protos::InterceptMessage* Say::mutable_intercept_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::InterceptMessage* _msg = _internal_mutable_intercept_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.intercept_message)
  return _msg;
}

// .protos.GoalieMessage goalie_message = 4;
inline bool Say::has_goalie_message() const {
  return message_case() == kGoalieMessage;
}
inline bool Say::_internal_has_goalie_message() const {
  return message_case() == kGoalieMessage;
}
inline void Say::set_has_goalie_message() {
  _impl_._oneof_case_[0] = kGoalieMessage;
}
inline void Say::clear_goalie_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kGoalieMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.goalie_message_;
    }
    clear_has_message();
  }
}
inline ::protos::GoalieMessage* Say::release_goalie_message() {
  // @@protoc_insertion_point(field_release:protos.Say.goalie_message)
  if (message_case() == kGoalieMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.goalie_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.goalie_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::GoalieMessage& Say::_internal_goalie_message() const {
  return message_case() == kGoalieMessage ? *_impl_.message_.goalie_message_ : reinterpret_cast<::protos::GoalieMessage&>(::protos::_GoalieMessage_default_instance_);
}
inline const ::protos::GoalieMessage& Say::goalie_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.goalie_message)
  return _internal_goalie_message();
}
inline ::protos::GoalieMessage* Say::unsafe_arena_release_goalie_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.goalie_message)
  if (message_case() == kGoalieMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.goalie_message_;
    _impl_.message_.goalie_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_goalie_message(::protos::GoalieMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_goalie_message();
    _impl_.message_.goalie_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.goalie_message)
}
inline ::protos::GoalieMessage* Say::_internal_mutable_goalie_message() {
  if (message_case() != kGoalieMessage) {
    clear_message();
    set_has_goalie_message();
    _impl_.message_.goalie_message_ = CreateMaybeMessage<::protos::GoalieMessage>(GetArena());
  }
  return _impl_.message_.goalie_message_;
}
inline ::protos::GoalieMessage* Say::mutable_goalie_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::GoalieMessage* _msg = _internal_mutable_goalie_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.goalie_message)
  return _msg;
}

// .protos.GoalieAndPlayerMessage goalie_and_player_message = 5;
inline bool Say::has_goalie_and_player_message() const {
  return message_case() == kGoalieAndPlayerMessage;
}
inline bool Say::_internal_has_goalie_and_player_message() const {
  return message_case() == kGoalieAndPlayerMessage;
}
inline void Say::set_has_goalie_and_player_message() {
  _impl_._oneof_case_[0] = kGoalieAndPlayerMessage;
}
inline void Say::clear_goalie_and_player_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kGoalieAndPlayerMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.goalie_and_player_message_;
    }
    clear_has_message();
  }
}
inline ::protos::GoalieAndPlayerMessage* Say::release_goalie_and_player_message() {
  // @@protoc_insertion_point(field_release:protos.Say.goalie_and_player_message)
  if (message_case() == kGoalieAndPlayerMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.goalie_and_player_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.goalie_and_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::GoalieAndPlayerMessage& Say::_internal_goalie_and_player_message() const {
  return message_case() == kGoalieAndPlayerMessage ? *_impl_.message_.goalie_and_player_message_ : reinterpret_cast<::protos::GoalieAndPlayerMessage&>(::protos::_GoalieAndPlayerMessage_default_instance_);
}
inline const ::protos::GoalieAndPlayerMessage& Say::goalie_and_player_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.goalie_and_player_message)
  return _internal_goalie_and_player_message();
}
inline ::protos::GoalieAndPlayerMessage* Say::unsafe_arena_release_goalie_and_player_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.goalie_and_player_message)
  if (message_case() == kGoalieAndPlayerMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.goalie_and_player_message_;
    _impl_.message_.goalie_and_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_goalie_and_player_message(::protos::GoalieAndPlayerMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_goalie_and_player_message();
    _impl_.message_.goalie_and_player_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.goalie_and_player_message)
}
inline ::protos::GoalieAndPlayerMessage* Say::_internal_mutable_goalie_and_player_message() {
  if (message_case() != kGoalieAndPlayerMessage) {
    clear_message();
    set_has_goalie_and_player_message();
    _impl_.message_.goalie_and_player_message_ = CreateMaybeMessage<::protos::GoalieAndPlayerMessage>(GetArena());
  }
  return _impl_.message_.goalie_and_player_message_;
}
inline ::protos::GoalieAndPlayerMessage* Say::mutable_goalie_and_player_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::GoalieAndPlayerMessage* _msg = _internal_mutable_goalie_and_player_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.goalie_and_player_message)
  return _msg;
}

// .protos.OffsideLineMessage offside_line_message = 6;
inline bool Say::has_offside_line_message() const {
  return message_case() == kOffsideLineMessage;
}
inline bool Say::_internal_has_offside_line_message() const {
  return message_case() == kOffsideLineMessage;
}
inline void Say::set_has_offside_line_message() {
  _impl_._oneof_case_[0] = kOffsideLineMessage;
}
inline void Say::clear_offside_line_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kOffsideLineMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.offside_line_message_;
    }
    clear_has_message();
  }
}
inline ::protos::OffsideLineMessage* Say::release_offside_line_message() {
  // @@protoc_insertion_point(field_release:protos.Say.offside_line_message)
  if (message_case() == kOffsideLineMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.offside_line_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.offside_line_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::OffsideLineMessage& Say::_internal_offside_line_message() const {
  return message_case() == kOffsideLineMessage ? *_impl_.message_.offside_line_message_ : reinterpret_cast<::protos::OffsideLineMessage&>(::protos::_OffsideLineMessage_default_instance_);
}
inline const ::protos::OffsideLineMessage& Say::offside_line_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.offside_line_message)
  return _internal_offside_line_message();
}
inline ::protos::OffsideLineMessage* Say::unsafe_arena_release_offside_line_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.offside_line_message)
  if (message_case() == kOffsideLineMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.offside_line_message_;
    _impl_.message_.offside_line_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_offside_line_message(::protos::OffsideLineMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_offside_line_message();
    _impl_.message_.offside_line_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.offside_line_message)
}
inline ::protos::OffsideLineMessage* Say::_internal_mutable_offside_line_message() {
  if (message_case() != kOffsideLineMessage) {
    clear_message();
    set_has_offside_line_message();
    _impl_.message_.offside_line_message_ = CreateMaybeMessage<::protos::OffsideLineMessage>(GetArena());
  }
  return _impl_.message_.offside_line_message_;
}
inline ::protos::OffsideLineMessage* Say::mutable_offside_line_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::OffsideLineMessage* _msg = _internal_mutable_offside_line_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.offside_line_message)
  return _msg;
}

// .protos.DefenseLineMessage defense_line_message = 7;
inline bool Say::has_defense_line_message() const {
  return message_case() == kDefenseLineMessage;
}
inline bool Say::_internal_has_defense_line_message() const {
  return message_case() == kDefenseLineMessage;
}
inline void Say::set_has_defense_line_message() {
  _impl_._oneof_case_[0] = kDefenseLineMessage;
}
inline void Say::clear_defense_line_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kDefenseLineMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.defense_line_message_;
    }
    clear_has_message();
  }
}
inline ::protos::DefenseLineMessage* Say::release_defense_line_message() {
  // @@protoc_insertion_point(field_release:protos.Say.defense_line_message)
  if (message_case() == kDefenseLineMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.defense_line_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.defense_line_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DefenseLineMessage& Say::_internal_defense_line_message() const {
  return message_case() == kDefenseLineMessage ? *_impl_.message_.defense_line_message_ : reinterpret_cast<::protos::DefenseLineMessage&>(::protos::_DefenseLineMessage_default_instance_);
}
inline const ::protos::DefenseLineMessage& Say::defense_line_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.defense_line_message)
  return _internal_defense_line_message();
}
inline ::protos::DefenseLineMessage* Say::unsafe_arena_release_defense_line_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.defense_line_message)
  if (message_case() == kDefenseLineMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.defense_line_message_;
    _impl_.message_.defense_line_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_defense_line_message(::protos::DefenseLineMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_defense_line_message();
    _impl_.message_.defense_line_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.defense_line_message)
}
inline ::protos::DefenseLineMessage* Say::_internal_mutable_defense_line_message() {
  if (message_case() != kDefenseLineMessage) {
    clear_message();
    set_has_defense_line_message();
    _impl_.message_.defense_line_message_ = CreateMaybeMessage<::protos::DefenseLineMessage>(GetArena());
  }
  return _impl_.message_.defense_line_message_;
}
inline ::protos::DefenseLineMessage* Say::mutable_defense_line_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::DefenseLineMessage* _msg = _internal_mutable_defense_line_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.defense_line_message)
  return _msg;
}

// .protos.WaitRequestMessage wait_request_message = 8;
inline bool Say::has_wait_request_message() const {
  return message_case() == kWaitRequestMessage;
}
inline bool Say::_internal_has_wait_request_message() const {
  return message_case() == kWaitRequestMessage;
}
inline void Say::set_has_wait_request_message() {
  _impl_._oneof_case_[0] = kWaitRequestMessage;
}
inline void Say::clear_wait_request_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kWaitRequestMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.wait_request_message_;
    }
    clear_has_message();
  }
}
inline ::protos::WaitRequestMessage* Say::release_wait_request_message() {
  // @@protoc_insertion_point(field_release:protos.Say.wait_request_message)
  if (message_case() == kWaitRequestMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.wait_request_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.wait_request_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::WaitRequestMessage& Say::_internal_wait_request_message() const {
  return message_case() == kWaitRequestMessage ? *_impl_.message_.wait_request_message_ : reinterpret_cast<::protos::WaitRequestMessage&>(::protos::_WaitRequestMessage_default_instance_);
}
inline const ::protos::WaitRequestMessage& Say::wait_request_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.wait_request_message)
  return _internal_wait_request_message();
}
inline ::protos::WaitRequestMessage* Say::unsafe_arena_release_wait_request_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.wait_request_message)
  if (message_case() == kWaitRequestMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.wait_request_message_;
    _impl_.message_.wait_request_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_wait_request_message(::protos::WaitRequestMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_wait_request_message();
    _impl_.message_.wait_request_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.wait_request_message)
}
inline ::protos::WaitRequestMessage* Say::_internal_mutable_wait_request_message() {
  if (message_case() != kWaitRequestMessage) {
    clear_message();
    set_has_wait_request_message();
    _impl_.message_.wait_request_message_ = CreateMaybeMessage<::protos::WaitRequestMessage>(GetArena());
  }
  return _impl_.message_.wait_request_message_;
}
inline ::protos::WaitRequestMessage* Say::mutable_wait_request_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::WaitRequestMessage* _msg = _internal_mutable_wait_request_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.wait_request_message)
  return _msg;
}

// .protos.SetplayMessage setplay_message = 9;
inline bool Say::has_setplay_message() const {
  return message_case() == kSetplayMessage;
}
inline bool Say::_internal_has_setplay_message() const {
  return message_case() == kSetplayMessage;
}
inline void Say::set_has_setplay_message() {
  _impl_._oneof_case_[0] = kSetplayMessage;
}
inline void Say::clear_setplay_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kSetplayMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.setplay_message_;
    }
    clear_has_message();
  }
}
inline ::protos::SetplayMessage* Say::release_setplay_message() {
  // @@protoc_insertion_point(field_release:protos.Say.setplay_message)
  if (message_case() == kSetplayMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.setplay_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.setplay_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::SetplayMessage& Say::_internal_setplay_message() const {
  return message_case() == kSetplayMessage ? *_impl_.message_.setplay_message_ : reinterpret_cast<::protos::SetplayMessage&>(::protos::_SetplayMessage_default_instance_);
}
inline const ::protos::SetplayMessage& Say::setplay_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.setplay_message)
  return _internal_setplay_message();
}
inline ::protos::SetplayMessage* Say::unsafe_arena_release_setplay_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.setplay_message)
  if (message_case() == kSetplayMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.setplay_message_;
    _impl_.message_.setplay_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_setplay_message(::protos::SetplayMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_setplay_message();
    _impl_.message_.setplay_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.setplay_message)
}
inline ::protos::SetplayMessage* Say::_internal_mutable_setplay_message() {
  if (message_case() != kSetplayMessage) {
    clear_message();
    set_has_setplay_message();
    _impl_.message_.setplay_message_ = CreateMaybeMessage<::protos::SetplayMessage>(GetArena());
  }
  return _impl_.message_.setplay_message_;
}
inline ::protos::SetplayMessage* Say::mutable_setplay_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::SetplayMessage* _msg = _internal_mutable_setplay_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.setplay_message)
  return _msg;
}

// .protos.PassRequestMessage pass_request_message = 10;
inline bool Say::has_pass_request_message() const {
  return message_case() == kPassRequestMessage;
}
inline bool Say::_internal_has_pass_request_message() const {
  return message_case() == kPassRequestMessage;
}
inline void Say::set_has_pass_request_message() {
  _impl_._oneof_case_[0] = kPassRequestMessage;
}
inline void Say::clear_pass_request_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kPassRequestMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.pass_request_message_;
    }
    clear_has_message();
  }
}
inline ::protos::PassRequestMessage* Say::release_pass_request_message() {
  // @@protoc_insertion_point(field_release:protos.Say.pass_request_message)
  if (message_case() == kPassRequestMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.pass_request_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.pass_request_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::PassRequestMessage& Say::_internal_pass_request_message() const {
  return message_case() == kPassRequestMessage ? *_impl_.message_.pass_request_message_ : reinterpret_cast<::protos::PassRequestMessage&>(::protos::_PassRequestMessage_default_instance_);
}
inline const ::protos::PassRequestMessage& Say::pass_request_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.pass_request_message)
  return _internal_pass_request_message();
}
inline ::protos::PassRequestMessage* Say::unsafe_arena_release_pass_request_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.pass_request_message)
  if (message_case() == kPassRequestMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.pass_request_message_;
    _impl_.message_.pass_request_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_pass_request_message(::protos::PassRequestMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_pass_request_message();
    _impl_.message_.pass_request_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.pass_request_message)
}
inline ::protos::PassRequestMessage* Say::_internal_mutable_pass_request_message() {
  if (message_case() != kPassRequestMessage) {
    clear_message();
    set_has_pass_request_message();
    _impl_.message_.pass_request_message_ = CreateMaybeMessage<::protos::PassRequestMessage>(GetArena());
  }
  return _impl_.message_.pass_request_message_;
}
inline ::protos::PassRequestMessage* Say::mutable_pass_request_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::PassRequestMessage* _msg = _internal_mutable_pass_request_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.pass_request_message)
  return _msg;
}

// .protos.StaminaMessage stamina_message = 11;
inline bool Say::has_stamina_message() const {
  return message_case() == kStaminaMessage;
}
inline bool Say::_internal_has_stamina_message() const {
  return message_case() == kStaminaMessage;
}
inline void Say::set_has_stamina_message() {
  _impl_._oneof_case_[0] = kStaminaMessage;
}
inline void Say::clear_stamina_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kStaminaMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.stamina_message_;
    }
    clear_has_message();
  }
}
inline ::protos::StaminaMessage* Say::release_stamina_message() {
  // @@protoc_insertion_point(field_release:protos.Say.stamina_message)
  if (message_case() == kStaminaMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.stamina_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.stamina_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::StaminaMessage& Say::_internal_stamina_message() const {
  return message_case() == kStaminaMessage ? *_impl_.message_.stamina_message_ : reinterpret_cast<::protos::StaminaMessage&>(::protos::_StaminaMessage_default_instance_);
}
inline const ::protos::StaminaMessage& Say::stamina_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.stamina_message)
  return _internal_stamina_message();
}
inline ::protos::StaminaMessage* Say::unsafe_arena_release_stamina_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.stamina_message)
  if (message_case() == kStaminaMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.stamina_message_;
    _impl_.message_.stamina_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_stamina_message(::protos::StaminaMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_stamina_message();
    _impl_.message_.stamina_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.stamina_message)
}
inline ::protos::StaminaMessage* Say::_internal_mutable_stamina_message() {
  if (message_case() != kStaminaMessage) {
    clear_message();
    set_has_stamina_message();
    _impl_.message_.stamina_message_ = CreateMaybeMessage<::protos::StaminaMessage>(GetArena());
  }
  return _impl_.message_.stamina_message_;
}
inline ::protos::StaminaMessage* Say::mutable_stamina_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::StaminaMessage* _msg = _internal_mutable_stamina_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.stamina_message)
  return _msg;
}

// .protos.RecoveryMessage recovery_message = 12;
inline bool Say::has_recovery_message() const {
  return message_case() == kRecoveryMessage;
}
inline bool Say::_internal_has_recovery_message() const {
  return message_case() == kRecoveryMessage;
}
inline void Say::set_has_recovery_message() {
  _impl_._oneof_case_[0] = kRecoveryMessage;
}
inline void Say::clear_recovery_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kRecoveryMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.recovery_message_;
    }
    clear_has_message();
  }
}
inline ::protos::RecoveryMessage* Say::release_recovery_message() {
  // @@protoc_insertion_point(field_release:protos.Say.recovery_message)
  if (message_case() == kRecoveryMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.recovery_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.recovery_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::RecoveryMessage& Say::_internal_recovery_message() const {
  return message_case() == kRecoveryMessage ? *_impl_.message_.recovery_message_ : reinterpret_cast<::protos::RecoveryMessage&>(::protos::_RecoveryMessage_default_instance_);
}
inline const ::protos::RecoveryMessage& Say::recovery_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.recovery_message)
  return _internal_recovery_message();
}
inline ::protos::RecoveryMessage* Say::unsafe_arena_release_recovery_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.recovery_message)
  if (message_case() == kRecoveryMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.recovery_message_;
    _impl_.message_.recovery_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_recovery_message(::protos::RecoveryMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_recovery_message();
    _impl_.message_.recovery_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.recovery_message)
}
inline ::protos::RecoveryMessage* Say::_internal_mutable_recovery_message() {
  if (message_case() != kRecoveryMessage) {
    clear_message();
    set_has_recovery_message();
    _impl_.message_.recovery_message_ = CreateMaybeMessage<::protos::RecoveryMessage>(GetArena());
  }
  return _impl_.message_.recovery_message_;
}
inline ::protos::RecoveryMessage* Say::mutable_recovery_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::RecoveryMessage* _msg = _internal_mutable_recovery_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.recovery_message)
  return _msg;
}

// .protos.StaminaCapacityMessage stamina_capacity_message = 13;
inline bool Say::has_stamina_capacity_message() const {
  return message_case() == kStaminaCapacityMessage;
}
inline bool Say::_internal_has_stamina_capacity_message() const {
  return message_case() == kStaminaCapacityMessage;
}
inline void Say::set_has_stamina_capacity_message() {
  _impl_._oneof_case_[0] = kStaminaCapacityMessage;
}
inline void Say::clear_stamina_capacity_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kStaminaCapacityMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.stamina_capacity_message_;
    }
    clear_has_message();
  }
}
inline ::protos::StaminaCapacityMessage* Say::release_stamina_capacity_message() {
  // @@protoc_insertion_point(field_release:protos.Say.stamina_capacity_message)
  if (message_case() == kStaminaCapacityMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.stamina_capacity_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.stamina_capacity_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::StaminaCapacityMessage& Say::_internal_stamina_capacity_message() const {
  return message_case() == kStaminaCapacityMessage ? *_impl_.message_.stamina_capacity_message_ : reinterpret_cast<::protos::StaminaCapacityMessage&>(::protos::_StaminaCapacityMessage_default_instance_);
}
inline const ::protos::StaminaCapacityMessage& Say::stamina_capacity_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.stamina_capacity_message)
  return _internal_stamina_capacity_message();
}
inline ::protos::StaminaCapacityMessage* Say::unsafe_arena_release_stamina_capacity_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.stamina_capacity_message)
  if (message_case() == kStaminaCapacityMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.stamina_capacity_message_;
    _impl_.message_.stamina_capacity_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_stamina_capacity_message(::protos::StaminaCapacityMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_stamina_capacity_message();
    _impl_.message_.stamina_capacity_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.stamina_capacity_message)
}
inline ::protos::StaminaCapacityMessage* Say::_internal_mutable_stamina_capacity_message() {
  if (message_case() != kStaminaCapacityMessage) {
    clear_message();
    set_has_stamina_capacity_message();
    _impl_.message_.stamina_capacity_message_ = CreateMaybeMessage<::protos::StaminaCapacityMessage>(GetArena());
  }
  return _impl_.message_.stamina_capacity_message_;
}
inline ::protos::StaminaCapacityMessage* Say::mutable_stamina_capacity_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::StaminaCapacityMessage* _msg = _internal_mutable_stamina_capacity_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.stamina_capacity_message)
  return _msg;
}

// .protos.DribbleMessage dribble_message = 14;
inline bool Say::has_dribble_message() const {
  return message_case() == kDribbleMessage;
}
inline bool Say::_internal_has_dribble_message() const {
  return message_case() == kDribbleMessage;
}
inline void Say::set_has_dribble_message() {
  _impl_._oneof_case_[0] = kDribbleMessage;
}
inline void Say::clear_dribble_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kDribbleMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.dribble_message_;
    }
    clear_has_message();
  }
}
inline ::protos::DribbleMessage* Say::release_dribble_message() {
  // @@protoc_insertion_point(field_release:protos.Say.dribble_message)
  if (message_case() == kDribbleMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.dribble_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.dribble_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DribbleMessage& Say::_internal_dribble_message() const {
  return message_case() == kDribbleMessage ? *_impl_.message_.dribble_message_ : reinterpret_cast<::protos::DribbleMessage&>(::protos::_DribbleMessage_default_instance_);
}
inline const ::protos::DribbleMessage& Say::dribble_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.dribble_message)
  return _internal_dribble_message();
}
inline ::protos::DribbleMessage* Say::unsafe_arena_release_dribble_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.dribble_message)
  if (message_case() == kDribbleMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.dribble_message_;
    _impl_.message_.dribble_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_dribble_message(::protos::DribbleMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_dribble_message();
    _impl_.message_.dribble_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.dribble_message)
}
inline ::protos::DribbleMessage* Say::_internal_mutable_dribble_message() {
  if (message_case() != kDribbleMessage) {
    clear_message();
    set_has_dribble_message();
    _impl_.message_.dribble_message_ = CreateMaybeMessage<::protos::DribbleMessage>(GetArena());
  }
  return _impl_.message_.dribble_message_;
}
inline ::protos::DribbleMessage* Say::mutable_dribble_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::DribbleMessage* _msg = _internal_mutable_dribble_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.dribble_message)
  return _msg;
}

// .protos.BallGoalieMessage ball_goalie_message = 15;
inline bool Say::has_ball_goalie_message() const {
  return message_case() == kBallGoalieMessage;
}
inline bool Say::_internal_has_ball_goalie_message() const {
  return message_case() == kBallGoalieMessage;
}
inline void Say::set_has_ball_goalie_message() {
  _impl_._oneof_case_[0] = kBallGoalieMessage;
}
inline void Say::clear_ball_goalie_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kBallGoalieMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.ball_goalie_message_;
    }
    clear_has_message();
  }
}
inline ::protos::BallGoalieMessage* Say::release_ball_goalie_message() {
  // @@protoc_insertion_point(field_release:protos.Say.ball_goalie_message)
  if (message_case() == kBallGoalieMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.ball_goalie_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ball_goalie_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::BallGoalieMessage& Say::_internal_ball_goalie_message() const {
  return message_case() == kBallGoalieMessage ? *_impl_.message_.ball_goalie_message_ : reinterpret_cast<::protos::BallGoalieMessage&>(::protos::_BallGoalieMessage_default_instance_);
}
inline const ::protos::BallGoalieMessage& Say::ball_goalie_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.ball_goalie_message)
  return _internal_ball_goalie_message();
}
inline ::protos::BallGoalieMessage* Say::unsafe_arena_release_ball_goalie_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.ball_goalie_message)
  if (message_case() == kBallGoalieMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.ball_goalie_message_;
    _impl_.message_.ball_goalie_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_ball_goalie_message(::protos::BallGoalieMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_ball_goalie_message();
    _impl_.message_.ball_goalie_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.ball_goalie_message)
}
inline ::protos::BallGoalieMessage* Say::_internal_mutable_ball_goalie_message() {
  if (message_case() != kBallGoalieMessage) {
    clear_message();
    set_has_ball_goalie_message();
    _impl_.message_.ball_goalie_message_ = CreateMaybeMessage<::protos::BallGoalieMessage>(GetArena());
  }
  return _impl_.message_.ball_goalie_message_;
}
inline ::protos::BallGoalieMessage* Say::mutable_ball_goalie_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::BallGoalieMessage* _msg = _internal_mutable_ball_goalie_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.ball_goalie_message)
  return _msg;
}

// .protos.OnePlayerMessage one_player_message = 16;
inline bool Say::has_one_player_message() const {
  return message_case() == kOnePlayerMessage;
}
inline bool Say::_internal_has_one_player_message() const {
  return message_case() == kOnePlayerMessage;
}
inline void Say::set_has_one_player_message() {
  _impl_._oneof_case_[0] = kOnePlayerMessage;
}
inline void Say::clear_one_player_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kOnePlayerMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.one_player_message_;
    }
    clear_has_message();
  }
}
inline ::protos::OnePlayerMessage* Say::release_one_player_message() {
  // @@protoc_insertion_point(field_release:protos.Say.one_player_message)
  if (message_case() == kOnePlayerMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.one_player_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.one_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::OnePlayerMessage& Say::_internal_one_player_message() const {
  return message_case() == kOnePlayerMessage ? *_impl_.message_.one_player_message_ : reinterpret_cast<::protos::OnePlayerMessage&>(::protos::_OnePlayerMessage_default_instance_);
}
inline const ::protos::OnePlayerMessage& Say::one_player_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.one_player_message)
  return _internal_one_player_message();
}
inline ::protos::OnePlayerMessage* Say::unsafe_arena_release_one_player_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.one_player_message)
  if (message_case() == kOnePlayerMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.one_player_message_;
    _impl_.message_.one_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_one_player_message(::protos::OnePlayerMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_one_player_message();
    _impl_.message_.one_player_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.one_player_message)
}
inline ::protos::OnePlayerMessage* Say::_internal_mutable_one_player_message() {
  if (message_case() != kOnePlayerMessage) {
    clear_message();
    set_has_one_player_message();
    _impl_.message_.one_player_message_ = CreateMaybeMessage<::protos::OnePlayerMessage>(GetArena());
  }
  return _impl_.message_.one_player_message_;
}
inline ::protos::OnePlayerMessage* Say::mutable_one_player_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::OnePlayerMessage* _msg = _internal_mutable_one_player_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.one_player_message)
  return _msg;
}

// .protos.TwoPlayerMessage two_player_message = 17;
inline bool Say::has_two_player_message() const {
  return message_case() == kTwoPlayerMessage;
}
inline bool Say::_internal_has_two_player_message() const {
  return message_case() == kTwoPlayerMessage;
}
inline void Say::set_has_two_player_message() {
  _impl_._oneof_case_[0] = kTwoPlayerMessage;
}
inline void Say::clear_two_player_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kTwoPlayerMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.two_player_message_;
    }
    clear_has_message();
  }
}
inline ::protos::TwoPlayerMessage* Say::release_two_player_message() {
  // @@protoc_insertion_point(field_release:protos.Say.two_player_message)
  if (message_case() == kTwoPlayerMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.two_player_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.two_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::TwoPlayerMessage& Say::_internal_two_player_message() const {
  return message_case() == kTwoPlayerMessage ? *_impl_.message_.two_player_message_ : reinterpret_cast<::protos::TwoPlayerMessage&>(::protos::_TwoPlayerMessage_default_instance_);
}
inline const ::protos::TwoPlayerMessage& Say::two_player_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.two_player_message)
  return _internal_two_player_message();
}
inline ::protos::TwoPlayerMessage* Say::unsafe_arena_release_two_player_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.two_player_message)
  if (message_case() == kTwoPlayerMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.two_player_message_;
    _impl_.message_.two_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_two_player_message(::protos::TwoPlayerMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_two_player_message();
    _impl_.message_.two_player_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.two_player_message)
}
inline ::protos::TwoPlayerMessage* Say::_internal_mutable_two_player_message() {
  if (message_case() != kTwoPlayerMessage) {
    clear_message();
    set_has_two_player_message();
    _impl_.message_.two_player_message_ = CreateMaybeMessage<::protos::TwoPlayerMessage>(GetArena());
  }
  return _impl_.message_.two_player_message_;
}
inline ::protos::TwoPlayerMessage* Say::mutable_two_player_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::TwoPlayerMessage* _msg = _internal_mutable_two_player_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.two_player_message)
  return _msg;
}

// .protos.ThreePlayerMessage three_player_message = 18;
inline bool Say::has_three_player_message() const {
  return message_case() == kThreePlayerMessage;
}
inline bool Say::_internal_has_three_player_message() const {
  return message_case() == kThreePlayerMessage;
}
inline void Say::set_has_three_player_message() {
  _impl_._oneof_case_[0] = kThreePlayerMessage;
}
inline void Say::clear_three_player_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kThreePlayerMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.three_player_message_;
    }
    clear_has_message();
  }
}
inline ::protos::ThreePlayerMessage* Say::release_three_player_message() {
  // @@protoc_insertion_point(field_release:protos.Say.three_player_message)
  if (message_case() == kThreePlayerMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.three_player_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.three_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::ThreePlayerMessage& Say::_internal_three_player_message() const {
  return message_case() == kThreePlayerMessage ? *_impl_.message_.three_player_message_ : reinterpret_cast<::protos::ThreePlayerMessage&>(::protos::_ThreePlayerMessage_default_instance_);
}
inline const ::protos::ThreePlayerMessage& Say::three_player_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.three_player_message)
  return _internal_three_player_message();
}
inline ::protos::ThreePlayerMessage* Say::unsafe_arena_release_three_player_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.three_player_message)
  if (message_case() == kThreePlayerMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.three_player_message_;
    _impl_.message_.three_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_three_player_message(::protos::ThreePlayerMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_three_player_message();
    _impl_.message_.three_player_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.three_player_message)
}
inline ::protos::ThreePlayerMessage* Say::_internal_mutable_three_player_message() {
  if (message_case() != kThreePlayerMessage) {
    clear_message();
    set_has_three_player_message();
    _impl_.message_.three_player_message_ = CreateMaybeMessage<::protos::ThreePlayerMessage>(GetArena());
  }
  return _impl_.message_.three_player_message_;
}
inline ::protos::ThreePlayerMessage* Say::mutable_three_player_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::ThreePlayerMessage* _msg = _internal_mutable_three_player_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.three_player_message)
  return _msg;
}

// .protos.SelfMessage self_message = 19;
inline bool Say::has_self_message() const {
  return message_case() == kSelfMessage;
}
inline bool Say::_internal_has_self_message() const {
  return message_case() == kSelfMessage;
}
inline void Say::set_has_self_message() {
  _impl_._oneof_case_[0] = kSelfMessage;
}
inline void Say::clear_self_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kSelfMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.self_message_;
    }
    clear_has_message();
  }
}
inline ::protos::SelfMessage* Say::release_self_message() {
  // @@protoc_insertion_point(field_release:protos.Say.self_message)
  if (message_case() == kSelfMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.self_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.self_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::SelfMessage& Say::_internal_self_message() const {
  return message_case() == kSelfMessage ? *_impl_.message_.self_message_ : reinterpret_cast<::protos::SelfMessage&>(::protos::_SelfMessage_default_instance_);
}
inline const ::protos::SelfMessage& Say::self_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.self_message)
  return _internal_self_message();
}
inline ::protos::SelfMessage* Say::unsafe_arena_release_self_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.self_message)
  if (message_case() == kSelfMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.self_message_;
    _impl_.message_.self_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_self_message(::protos::SelfMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_self_message();
    _impl_.message_.self_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.self_message)
}
inline ::protos::SelfMessage* Say::_internal_mutable_self_message() {
  if (message_case() != kSelfMessage) {
    clear_message();
    set_has_self_message();
    _impl_.message_.self_message_ = CreateMaybeMessage<::protos::SelfMessage>(GetArena());
  }
  return _impl_.message_.self_message_;
}
inline ::protos::SelfMessage* Say::mutable_self_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::SelfMessage* _msg = _internal_mutable_self_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.self_message)
  return _msg;
}

// .protos.TeammateMessage teammate_message = 20;
inline bool Say::has_teammate_message() const {
  return message_case() == kTeammateMessage;
}
inline bool Say::_internal_has_teammate_message() const {
  return message_case() == kTeammateMessage;
}
inline void Say::set_has_teammate_message() {
  _impl_._oneof_case_[0] = kTeammateMessage;
}
inline void Say::clear_teammate_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kTeammateMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.teammate_message_;
    }
    clear_has_message();
  }
}
inline ::protos::TeammateMessage* Say::release_teammate_message() {
  // @@protoc_insertion_point(field_release:protos.Say.teammate_message)
  if (message_case() == kTeammateMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.teammate_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.teammate_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::TeammateMessage& Say::_internal_teammate_message() const {
  return message_case() == kTeammateMessage ? *_impl_.message_.teammate_message_ : reinterpret_cast<::protos::TeammateMessage&>(::protos::_TeammateMessage_default_instance_);
}
inline const ::protos::TeammateMessage& Say::teammate_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.teammate_message)
  return _internal_teammate_message();
}
inline ::protos::TeammateMessage* Say::unsafe_arena_release_teammate_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.teammate_message)
  if (message_case() == kTeammateMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.teammate_message_;
    _impl_.message_.teammate_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_teammate_message(::protos::TeammateMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_teammate_message();
    _impl_.message_.teammate_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.teammate_message)
}
inline ::protos::TeammateMessage* Say::_internal_mutable_teammate_message() {
  if (message_case() != kTeammateMessage) {
    clear_message();
    set_has_teammate_message();
    _impl_.message_.teammate_message_ = CreateMaybeMessage<::protos::TeammateMessage>(GetArena());
  }
  return _impl_.message_.teammate_message_;
}
inline ::protos::TeammateMessage* Say::mutable_teammate_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::TeammateMessage* _msg = _internal_mutable_teammate_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.teammate_message)
  return _msg;
}

// .protos.OpponentMessage opponent_message = 21;
inline bool Say::has_opponent_message() const {
  return message_case() == kOpponentMessage;
}
inline bool Say::_internal_has_opponent_message() const {
  return message_case() == kOpponentMessage;
}
inline void Say::set_has_opponent_message() {
  _impl_._oneof_case_[0] = kOpponentMessage;
}
inline void Say::clear_opponent_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kOpponentMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.opponent_message_;
    }
    clear_has_message();
  }
}
inline ::protos::OpponentMessage* Say::release_opponent_message() {
  // @@protoc_insertion_point(field_release:protos.Say.opponent_message)
  if (message_case() == kOpponentMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.opponent_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.opponent_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::OpponentMessage& Say::_internal_opponent_message() const {
  return message_case() == kOpponentMessage ? *_impl_.message_.opponent_message_ : reinterpret_cast<::protos::OpponentMessage&>(::protos::_OpponentMessage_default_instance_);
}
inline const ::protos::OpponentMessage& Say::opponent_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.opponent_message)
  return _internal_opponent_message();
}
inline ::protos::OpponentMessage* Say::unsafe_arena_release_opponent_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.opponent_message)
  if (message_case() == kOpponentMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.opponent_message_;
    _impl_.message_.opponent_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_opponent_message(::protos::OpponentMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_opponent_message();
    _impl_.message_.opponent_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.opponent_message)
}
inline ::protos::OpponentMessage* Say::_internal_mutable_opponent_message() {
  if (message_case() != kOpponentMessage) {
    clear_message();
    set_has_opponent_message();
    _impl_.message_.opponent_message_ = CreateMaybeMessage<::protos::OpponentMessage>(GetArena());
  }
  return _impl_.message_.opponent_message_;
}
inline ::protos::OpponentMessage* Say::mutable_opponent_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::OpponentMessage* _msg = _internal_mutable_opponent_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.opponent_message)
  return _msg;
}

// .protos.BallPlayerMessage ball_player_message = 22;
inline bool Say::has_ball_player_message() const {
  return message_case() == kBallPlayerMessage;
}
inline bool Say::_internal_has_ball_player_message() const {
  return message_case() == kBallPlayerMessage;
}
inline void Say::set_has_ball_player_message() {
  _impl_._oneof_case_[0] = kBallPlayerMessage;
}
inline void Say::clear_ball_player_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kBallPlayerMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.ball_player_message_;
    }
    clear_has_message();
  }
}
inline ::protos::BallPlayerMessage* Say::release_ball_player_message() {
  // @@protoc_insertion_point(field_release:protos.Say.ball_player_message)
  if (message_case() == kBallPlayerMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.ball_player_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ball_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::BallPlayerMessage& Say::_internal_ball_player_message() const {
  return message_case() == kBallPlayerMessage ? *_impl_.message_.ball_player_message_ : reinterpret_cast<::protos::BallPlayerMessage&>(::protos::_BallPlayerMessage_default_instance_);
}
inline const ::protos::BallPlayerMessage& Say::ball_player_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Say.ball_player_message)
  return _internal_ball_player_message();
}
inline ::protos::BallPlayerMessage* Say::unsafe_arena_release_ball_player_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Say.ball_player_message)
  if (message_case() == kBallPlayerMessage) {
    clear_has_message();
    auto* temp = _impl_.message_.ball_player_message_;
    _impl_.message_.ball_player_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Say::unsafe_arena_set_allocated_ball_player_message(::protos::BallPlayerMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_ball_player_message();
    _impl_.message_.ball_player_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Say.ball_player_message)
}
inline ::protos::BallPlayerMessage* Say::_internal_mutable_ball_player_message() {
  if (message_case() != kBallPlayerMessage) {
    clear_message();
    set_has_ball_player_message();
    _impl_.message_.ball_player_message_ = CreateMaybeMessage<::protos::BallPlayerMessage>(GetArena());
  }
  return _impl_.message_.ball_player_message_;
}
inline ::protos::BallPlayerMessage* Say::mutable_ball_player_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::BallPlayerMessage* _msg = _internal_mutable_ball_player_message();
  // @@protoc_insertion_point(field_mutable:protos.Say.ball_player_message)
  return _msg;
}

inline bool Say::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void Say::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Say::MessageCase Say::message_case() const {
  return Say::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PointTo

// float x = 1;
inline void PointTo::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline float PointTo::x() const {
  // @@protoc_insertion_point(field_get:protos.PointTo.x)
  return _internal_x();
}
inline void PointTo::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:protos.PointTo.x)
}
inline float PointTo::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void PointTo::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void PointTo::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float PointTo::y() const {
  // @@protoc_insertion_point(field_get:protos.PointTo.y)
  return _internal_y();
}
inline void PointTo::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:protos.PointTo.y)
}
inline float PointTo::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void PointTo::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// PointToOf

// -------------------------------------------------------------------

// AttentionTo

// .protos.Side side = 1;
inline void AttentionTo::clear_side() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_ = 0;
}
inline ::protos::Side AttentionTo::side() const {
  // @@protoc_insertion_point(field_get:protos.AttentionTo.side)
  return _internal_side();
}
inline void AttentionTo::set_side(::protos::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.AttentionTo.side)
}
inline ::protos::Side AttentionTo::_internal_side() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void AttentionTo::_internal_set_side(::protos::Side value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.side_ = value;
}

// int32 unum = 2;
inline void AttentionTo::clear_unum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unum_ = 0;
}
inline ::int32_t AttentionTo::unum() const {
  // @@protoc_insertion_point(field_get:protos.AttentionTo.unum)
  return _internal_unum();
}
inline void AttentionTo::set_unum(::int32_t value) {
  _internal_set_unum(value);
  // @@protoc_insertion_point(field_set:protos.AttentionTo.unum)
}
inline ::int32_t AttentionTo::_internal_unum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unum_;
}
inline void AttentionTo::_internal_set_unum(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unum_ = value;
}

// -------------------------------------------------------------------

// AttentionToOf

// -------------------------------------------------------------------

// AddText

// .protos.LoggerLevel level = 1;
inline void AddText::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddText::level() const {
  // @@protoc_insertion_point(field_get:protos.AddText.level)
  return _internal_level();
}
inline void AddText::set_level(::protos::LoggerLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddText.level)
}
inline ::protos::LoggerLevel AddText::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddText::_internal_set_level(::protos::LoggerLevel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// string message = 2;
inline void AddText::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AddText::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddText.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddText::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.AddText.message)
}
inline std::string* AddText::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protos.AddText.message)
  return _s;
}
inline const std::string& AddText::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void AddText::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* AddText::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* AddText::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddText.message)
  return _impl_.message_.Release();
}
inline void AddText::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddText.message)
}

// -------------------------------------------------------------------

// AddPoint

// .protos.LoggerLevel level = 1;
inline void AddPoint::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddPoint::level() const {
  // @@protoc_insertion_point(field_get:protos.AddPoint.level)
  return _internal_level();
}
inline void AddPoint::set_level(::protos::LoggerLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddPoint.level)
}
inline ::protos::LoggerLevel AddPoint::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddPoint::_internal_set_level(::protos::LoggerLevel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D point = 2;
inline bool AddPoint::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline void AddPoint::clear_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddPoint::_internal_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddPoint::point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddPoint.point)
  return _internal_point();
}
inline void AddPoint::unsafe_arena_set_allocated_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddPoint.point)
}
inline ::protos::Vector2D* AddPoint::release_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* AddPoint::unsafe_arena_release_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddPoint.point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddPoint::_internal_mutable_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.point_;
}
inline ::protos::Vector2D* AddPoint::mutable_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:protos.AddPoint.point)
  return _msg;
}
inline void AddPoint::set_allocated_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.AddPoint.point)
}

// string color = 3;
inline void AddPoint::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddPoint::color() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddPoint.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddPoint::set_color(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.AddPoint.color)
}
inline std::string* AddPoint::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddPoint.color)
  return _s;
}
inline const std::string& AddPoint::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.color_.Get();
}
inline void AddPoint::_internal_set_color(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(value, GetArena());
}
inline std::string* AddPoint::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.color_.Mutable( GetArena());
}
inline std::string* AddPoint::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddPoint.color)
  return _impl_.color_.Release();
}
inline void AddPoint::set_allocated_color(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddPoint.color)
}

// -------------------------------------------------------------------

// AddLine

// .protos.LoggerLevel level = 1;
inline void AddLine::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddLine::level() const {
  // @@protoc_insertion_point(field_get:protos.AddLine.level)
  return _internal_level();
}
inline void AddLine::set_level(::protos::LoggerLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddLine.level)
}
inline ::protos::LoggerLevel AddLine::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddLine::_internal_set_level(::protos::LoggerLevel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D start = 2;
inline bool AddLine::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline void AddLine::clear_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddLine::_internal_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddLine::start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddLine.start)
  return _internal_start();
}
inline void AddLine::unsafe_arena_set_allocated_start(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddLine.start)
}
inline ::protos::Vector2D* AddLine::release_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* AddLine::unsafe_arena_release_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddLine.start)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddLine::_internal_mutable_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.start_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.start_;
}
inline ::protos::Vector2D* AddLine::mutable_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:protos.AddLine.start)
  return _msg;
}
inline void AddLine::set_allocated_start(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.start_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.start_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.AddLine.start)
}

// .protos.Vector2D end = 3;
inline bool AddLine::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline void AddLine::clear_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& AddLine::_internal_end() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddLine::end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddLine.end)
  return _internal_end();
}
inline void AddLine::unsafe_arena_set_allocated_end(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddLine.end)
}
inline ::protos::Vector2D* AddLine::release_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* AddLine::unsafe_arena_release_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddLine.end)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddLine::_internal_mutable_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.end_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.end_;
}
inline ::protos::Vector2D* AddLine::mutable_end() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:protos.AddLine.end)
  return _msg;
}
inline void AddLine::set_allocated_end(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.end_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.end_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.AddLine.end)
}

// string color = 4;
inline void AddLine::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddLine::color() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddLine.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddLine::set_color(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.AddLine.color)
}
inline std::string* AddLine::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddLine.color)
  return _s;
}
inline const std::string& AddLine::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.color_.Get();
}
inline void AddLine::_internal_set_color(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(value, GetArena());
}
inline std::string* AddLine::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.color_.Mutable( GetArena());
}
inline std::string* AddLine::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddLine.color)
  return _impl_.color_.Release();
}
inline void AddLine::set_allocated_color(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddLine.color)
}

// -------------------------------------------------------------------

// AddArc

// .protos.LoggerLevel level = 1;
inline void AddArc::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddArc::level() const {
  // @@protoc_insertion_point(field_get:protos.AddArc.level)
  return _internal_level();
}
inline void AddArc::set_level(::protos::LoggerLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddArc.level)
}
inline ::protos::LoggerLevel AddArc::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddArc::_internal_set_level(::protos::LoggerLevel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D center = 2;
inline bool AddArc::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void AddArc::clear_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddArc::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddArc::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddArc.center)
  return _internal_center();
}
inline void AddArc::unsafe_arena_set_allocated_center(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddArc.center)
}
inline ::protos::Vector2D* AddArc::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* AddArc::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddArc.center)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddArc::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.center_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.center_;
}
inline ::protos::Vector2D* AddArc::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:protos.AddArc.center)
  return _msg;
}
inline void AddArc::set_allocated_center(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.AddArc.center)
}

// float radius = 3;
inline void AddArc::clear_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.radius_ = 0;
}
inline float AddArc::radius() const {
  // @@protoc_insertion_point(field_get:protos.AddArc.radius)
  return _internal_radius();
}
inline void AddArc::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:protos.AddArc.radius)
}
inline float AddArc::_internal_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.radius_;
}
inline void AddArc::_internal_set_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.radius_ = value;
}

// float start_angle = 4;
inline void AddArc::clear_start_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_angle_ = 0;
}
inline float AddArc::start_angle() const {
  // @@protoc_insertion_point(field_get:protos.AddArc.start_angle)
  return _internal_start_angle();
}
inline void AddArc::set_start_angle(float value) {
  _internal_set_start_angle(value);
  // @@protoc_insertion_point(field_set:protos.AddArc.start_angle)
}
inline float AddArc::_internal_start_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_angle_;
}
inline void AddArc::_internal_set_start_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_angle_ = value;
}

// float span_angel = 5;
inline void AddArc::clear_span_angel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.span_angel_ = 0;
}
inline float AddArc::span_angel() const {
  // @@protoc_insertion_point(field_get:protos.AddArc.span_angel)
  return _internal_span_angel();
}
inline void AddArc::set_span_angel(float value) {
  _internal_set_span_angel(value);
  // @@protoc_insertion_point(field_set:protos.AddArc.span_angel)
}
inline float AddArc::_internal_span_angel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.span_angel_;
}
inline void AddArc::_internal_set_span_angel(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.span_angel_ = value;
}

// string color = 6;
inline void AddArc::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddArc::color() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddArc.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddArc::set_color(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.AddArc.color)
}
inline std::string* AddArc::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddArc.color)
  return _s;
}
inline const std::string& AddArc::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.color_.Get();
}
inline void AddArc::_internal_set_color(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(value, GetArena());
}
inline std::string* AddArc::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.color_.Mutable( GetArena());
}
inline std::string* AddArc::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddArc.color)
  return _impl_.color_.Release();
}
inline void AddArc::set_allocated_color(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddArc.color)
}

// -------------------------------------------------------------------

// AddCircle

// .protos.LoggerLevel level = 1;
inline void AddCircle::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddCircle::level() const {
  // @@protoc_insertion_point(field_get:protos.AddCircle.level)
  return _internal_level();
}
inline void AddCircle::set_level(::protos::LoggerLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddCircle.level)
}
inline ::protos::LoggerLevel AddCircle::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddCircle::_internal_set_level(::protos::LoggerLevel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D center = 2;
inline bool AddCircle::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void AddCircle::clear_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddCircle::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddCircle::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddCircle.center)
  return _internal_center();
}
inline void AddCircle::unsafe_arena_set_allocated_center(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddCircle.center)
}
inline ::protos::Vector2D* AddCircle::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* AddCircle::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddCircle.center)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddCircle::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.center_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.center_;
}
inline ::protos::Vector2D* AddCircle::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:protos.AddCircle.center)
  return _msg;
}
inline void AddCircle::set_allocated_center(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.AddCircle.center)
}

// float radius = 3;
inline void AddCircle::clear_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.radius_ = 0;
}
inline float AddCircle::radius() const {
  // @@protoc_insertion_point(field_get:protos.AddCircle.radius)
  return _internal_radius();
}
inline void AddCircle::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:protos.AddCircle.radius)
}
inline float AddCircle::_internal_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.radius_;
}
inline void AddCircle::_internal_set_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.radius_ = value;
}

// string color = 4;
inline void AddCircle::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddCircle::color() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddCircle.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddCircle::set_color(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.AddCircle.color)
}
inline std::string* AddCircle::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddCircle.color)
  return _s;
}
inline const std::string& AddCircle::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.color_.Get();
}
inline void AddCircle::_internal_set_color(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(value, GetArena());
}
inline std::string* AddCircle::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.color_.Mutable( GetArena());
}
inline std::string* AddCircle::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddCircle.color)
  return _impl_.color_.Release();
}
inline void AddCircle::set_allocated_color(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddCircle.color)
}

// bool fill = 5;
inline void AddCircle::clear_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fill_ = false;
}
inline bool AddCircle::fill() const {
  // @@protoc_insertion_point(field_get:protos.AddCircle.fill)
  return _internal_fill();
}
inline void AddCircle::set_fill(bool value) {
  _internal_set_fill(value);
  // @@protoc_insertion_point(field_set:protos.AddCircle.fill)
}
inline bool AddCircle::_internal_fill() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fill_;
}
inline void AddCircle::_internal_set_fill(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fill_ = value;
}

// -------------------------------------------------------------------

// AddTriangle

// .protos.LoggerLevel level = 1;
inline void AddTriangle::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddTriangle::level() const {
  // @@protoc_insertion_point(field_get:protos.AddTriangle.level)
  return _internal_level();
}
inline void AddTriangle::set_level(::protos::LoggerLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddTriangle.level)
}
inline ::protos::LoggerLevel AddTriangle::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddTriangle::_internal_set_level(::protos::LoggerLevel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D point1 = 2;
inline bool AddTriangle::has_point1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point1_ != nullptr);
  return value;
}
inline void AddTriangle::clear_point1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.point1_ != nullptr) _impl_.point1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddTriangle::_internal_point1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.point1_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddTriangle::point1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddTriangle.point1)
  return _internal_point1();
}
inline void AddTriangle::unsafe_arena_set_allocated_point1(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point1_);
  }
  _impl_.point1_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddTriangle.point1)
}
inline ::protos::Vector2D* AddTriangle::release_point1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.point1_;
  _impl_.point1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* AddTriangle::unsafe_arena_release_point1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddTriangle.point1)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point1_;
  _impl_.point1_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddTriangle::_internal_mutable_point1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point1_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.point1_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.point1_;
}
inline ::protos::Vector2D* AddTriangle::mutable_point1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_point1();
  // @@protoc_insertion_point(field_mutable:protos.AddTriangle.point1)
  return _msg;
}
inline void AddTriangle::set_allocated_point1(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.point1_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.point1_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.AddTriangle.point1)
}

// .protos.Vector2D point2 = 3;
inline bool AddTriangle::has_point2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point2_ != nullptr);
  return value;
}
inline void AddTriangle::clear_point2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.point2_ != nullptr) _impl_.point2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& AddTriangle::_internal_point2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.point2_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddTriangle::point2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddTriangle.point2)
  return _internal_point2();
}
inline void AddTriangle::unsafe_arena_set_allocated_point2(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point2_);
  }
  _impl_.point2_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddTriangle.point2)
}
inline ::protos::Vector2D* AddTriangle::release_point2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.point2_;
  _impl_.point2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* AddTriangle::unsafe_arena_release_point2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddTriangle.point2)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.point2_;
  _impl_.point2_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddTriangle::_internal_mutable_point2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.point2_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.point2_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.point2_;
}
inline ::protos::Vector2D* AddTriangle::mutable_point2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_point2();
  // @@protoc_insertion_point(field_mutable:protos.AddTriangle.point2)
  return _msg;
}
inline void AddTriangle::set_allocated_point2(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.point2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.point2_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.AddTriangle.point2)
}

// .protos.Vector2D point3 = 4;
inline bool AddTriangle::has_point3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point3_ != nullptr);
  return value;
}
inline void AddTriangle::clear_point3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.point3_ != nullptr) _impl_.point3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::protos::Vector2D& AddTriangle::_internal_point3() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.point3_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddTriangle::point3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddTriangle.point3)
  return _internal_point3();
}
inline void AddTriangle::unsafe_arena_set_allocated_point3(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point3_);
  }
  _impl_.point3_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddTriangle.point3)
}
inline ::protos::Vector2D* AddTriangle::release_point3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* released = _impl_.point3_;
  _impl_.point3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* AddTriangle::unsafe_arena_release_point3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddTriangle.point3)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::protos::Vector2D* temp = _impl_.point3_;
  _impl_.point3_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddTriangle::_internal_mutable_point3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.point3_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.point3_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.point3_;
}
inline ::protos::Vector2D* AddTriangle::mutable_point3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_point3();
  // @@protoc_insertion_point(field_mutable:protos.AddTriangle.point3)
  return _msg;
}
inline void AddTriangle::set_allocated_point3(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.point3_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.point3_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.AddTriangle.point3)
}

// string color = 5;
inline void AddTriangle::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddTriangle::color() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddTriangle.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddTriangle::set_color(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.AddTriangle.color)
}
inline std::string* AddTriangle::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddTriangle.color)
  return _s;
}
inline const std::string& AddTriangle::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.color_.Get();
}
inline void AddTriangle::_internal_set_color(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(value, GetArena());
}
inline std::string* AddTriangle::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.color_.Mutable( GetArena());
}
inline std::string* AddTriangle::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddTriangle.color)
  return _impl_.color_.Release();
}
inline void AddTriangle::set_allocated_color(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddTriangle.color)
}

// bool fill = 6;
inline void AddTriangle::clear_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fill_ = false;
}
inline bool AddTriangle::fill() const {
  // @@protoc_insertion_point(field_get:protos.AddTriangle.fill)
  return _internal_fill();
}
inline void AddTriangle::set_fill(bool value) {
  _internal_set_fill(value);
  // @@protoc_insertion_point(field_set:protos.AddTriangle.fill)
}
inline bool AddTriangle::_internal_fill() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fill_;
}
inline void AddTriangle::_internal_set_fill(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fill_ = value;
}

// -------------------------------------------------------------------

// AddRectangle

// .protos.LoggerLevel level = 1;
inline void AddRectangle::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddRectangle::level() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.level)
  return _internal_level();
}
inline void AddRectangle::set_level(::protos::LoggerLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddRectangle.level)
}
inline ::protos::LoggerLevel AddRectangle::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddRectangle::_internal_set_level(::protos::LoggerLevel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// float left = 2;
inline void AddRectangle::clear_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.left_ = 0;
}
inline float AddRectangle::left() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.left)
  return _internal_left();
}
inline void AddRectangle::set_left(float value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:protos.AddRectangle.left)
}
inline float AddRectangle::_internal_left() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.left_;
}
inline void AddRectangle::_internal_set_left(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.left_ = value;
}

// float top = 3;
inline void AddRectangle::clear_top() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_ = 0;
}
inline float AddRectangle::top() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.top)
  return _internal_top();
}
inline void AddRectangle::set_top(float value) {
  _internal_set_top(value);
  // @@protoc_insertion_point(field_set:protos.AddRectangle.top)
}
inline float AddRectangle::_internal_top() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_;
}
inline void AddRectangle::_internal_set_top(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.top_ = value;
}

// float length = 4;
inline void AddRectangle::clear_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.length_ = 0;
}
inline float AddRectangle::length() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.length)
  return _internal_length();
}
inline void AddRectangle::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:protos.AddRectangle.length)
}
inline float AddRectangle::_internal_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.length_;
}
inline void AddRectangle::_internal_set_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.length_ = value;
}

// float width = 5;
inline void AddRectangle::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline float AddRectangle::width() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.width)
  return _internal_width();
}
inline void AddRectangle::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:protos.AddRectangle.width)
}
inline float AddRectangle::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void AddRectangle::_internal_set_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.width_ = value;
}

// string color = 6;
inline void AddRectangle::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddRectangle::color() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddRectangle::set_color(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.AddRectangle.color)
}
inline std::string* AddRectangle::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddRectangle.color)
  return _s;
}
inline const std::string& AddRectangle::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.color_.Get();
}
inline void AddRectangle::_internal_set_color(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(value, GetArena());
}
inline std::string* AddRectangle::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.color_.Mutable( GetArena());
}
inline std::string* AddRectangle::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddRectangle.color)
  return _impl_.color_.Release();
}
inline void AddRectangle::set_allocated_color(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddRectangle.color)
}

// bool fill = 7;
inline void AddRectangle::clear_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fill_ = false;
}
inline bool AddRectangle::fill() const {
  // @@protoc_insertion_point(field_get:protos.AddRectangle.fill)
  return _internal_fill();
}
inline void AddRectangle::set_fill(bool value) {
  _internal_set_fill(value);
  // @@protoc_insertion_point(field_set:protos.AddRectangle.fill)
}
inline bool AddRectangle::_internal_fill() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fill_;
}
inline void AddRectangle::_internal_set_fill(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fill_ = value;
}

// -------------------------------------------------------------------

// AddSector

// .protos.LoggerLevel level = 1;
inline void AddSector::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddSector::level() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.level)
  return _internal_level();
}
inline void AddSector::set_level(::protos::LoggerLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddSector.level)
}
inline ::protos::LoggerLevel AddSector::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddSector::_internal_set_level(::protos::LoggerLevel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D center = 2;
inline bool AddSector::has_center() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_ != nullptr);
  return value;
}
inline void AddSector::clear_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_ != nullptr) _impl_.center_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddSector::_internal_center() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.center_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddSector::center() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddSector.center)
  return _internal_center();
}
inline void AddSector::unsafe_arena_set_allocated_center(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_);
  }
  _impl_.center_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddSector.center)
}
inline ::protos::Vector2D* AddSector::release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.center_;
  _impl_.center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* AddSector::unsafe_arena_release_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddSector.center)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.center_;
  _impl_.center_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddSector::_internal_mutable_center() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.center_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.center_;
}
inline ::protos::Vector2D* AddSector::mutable_center() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:protos.AddSector.center)
  return _msg;
}
inline void AddSector::set_allocated_center(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.center_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.AddSector.center)
}

// float min_radius = 3;
inline void AddSector::clear_min_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_radius_ = 0;
}
inline float AddSector::min_radius() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.min_radius)
  return _internal_min_radius();
}
inline void AddSector::set_min_radius(float value) {
  _internal_set_min_radius(value);
  // @@protoc_insertion_point(field_set:protos.AddSector.min_radius)
}
inline float AddSector::_internal_min_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_radius_;
}
inline void AddSector::_internal_set_min_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_radius_ = value;
}

// float max_radius = 4;
inline void AddSector::clear_max_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_radius_ = 0;
}
inline float AddSector::max_radius() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.max_radius)
  return _internal_max_radius();
}
inline void AddSector::set_max_radius(float value) {
  _internal_set_max_radius(value);
  // @@protoc_insertion_point(field_set:protos.AddSector.max_radius)
}
inline float AddSector::_internal_max_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_radius_;
}
inline void AddSector::_internal_set_max_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_radius_ = value;
}

// float start_angle = 5;
inline void AddSector::clear_start_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_angle_ = 0;
}
inline float AddSector::start_angle() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.start_angle)
  return _internal_start_angle();
}
inline void AddSector::set_start_angle(float value) {
  _internal_set_start_angle(value);
  // @@protoc_insertion_point(field_set:protos.AddSector.start_angle)
}
inline float AddSector::_internal_start_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_angle_;
}
inline void AddSector::_internal_set_start_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_angle_ = value;
}

// float span_angel = 6;
inline void AddSector::clear_span_angel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.span_angel_ = 0;
}
inline float AddSector::span_angel() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.span_angel)
  return _internal_span_angel();
}
inline void AddSector::set_span_angel(float value) {
  _internal_set_span_angel(value);
  // @@protoc_insertion_point(field_set:protos.AddSector.span_angel)
}
inline float AddSector::_internal_span_angel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.span_angel_;
}
inline void AddSector::_internal_set_span_angel(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.span_angel_ = value;
}

// string color = 7;
inline void AddSector::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddSector::color() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddSector.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddSector::set_color(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.AddSector.color)
}
inline std::string* AddSector::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddSector.color)
  return _s;
}
inline const std::string& AddSector::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.color_.Get();
}
inline void AddSector::_internal_set_color(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(value, GetArena());
}
inline std::string* AddSector::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.color_.Mutable( GetArena());
}
inline std::string* AddSector::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddSector.color)
  return _impl_.color_.Release();
}
inline void AddSector::set_allocated_color(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddSector.color)
}

// bool fill = 8;
inline void AddSector::clear_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fill_ = false;
}
inline bool AddSector::fill() const {
  // @@protoc_insertion_point(field_get:protos.AddSector.fill)
  return _internal_fill();
}
inline void AddSector::set_fill(bool value) {
  _internal_set_fill(value);
  // @@protoc_insertion_point(field_set:protos.AddSector.fill)
}
inline bool AddSector::_internal_fill() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fill_;
}
inline void AddSector::_internal_set_fill(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fill_ = value;
}

// -------------------------------------------------------------------

// AddMessage

// .protos.LoggerLevel level = 1;
inline void AddMessage::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::protos::LoggerLevel AddMessage::level() const {
  // @@protoc_insertion_point(field_get:protos.AddMessage.level)
  return _internal_level();
}
inline void AddMessage::set_level(::protos::LoggerLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:protos.AddMessage.level)
}
inline ::protos::LoggerLevel AddMessage::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::LoggerLevel>(_impl_.level_);
}
inline void AddMessage::_internal_set_level(::protos::LoggerLevel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// .protos.Vector2D position = 2;
inline bool AddMessage::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void AddMessage::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& AddMessage::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& AddMessage::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddMessage.position)
  return _internal_position();
}
inline void AddMessage::unsafe_arena_set_allocated_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.AddMessage.position)
}
inline ::protos::Vector2D* AddMessage::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* AddMessage::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddMessage.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* AddMessage::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* AddMessage::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.AddMessage.position)
  return _msg;
}
inline void AddMessage::set_allocated_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.AddMessage.position)
}

// string message = 3;
inline void AddMessage::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AddMessage::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddMessage.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddMessage::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.AddMessage.message)
}
inline std::string* AddMessage::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protos.AddMessage.message)
  return _s;
}
inline const std::string& AddMessage::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void AddMessage::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* AddMessage::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* AddMessage::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddMessage.message)
  return _impl_.message_.Release();
}
inline void AddMessage::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddMessage.message)
}

// string color = 4;
inline void AddMessage::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AddMessage::color() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.AddMessage.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddMessage::set_color(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.AddMessage.color)
}
inline std::string* AddMessage::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:protos.AddMessage.color)
  return _s;
}
inline const std::string& AddMessage::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.color_.Get();
}
inline void AddMessage::_internal_set_color(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_.Set(value, GetArena());
}
inline std::string* AddMessage::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.color_.Mutable( GetArena());
}
inline std::string* AddMessage::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.AddMessage.color)
  return _impl_.color_.Release();
}
inline void AddMessage::set_allocated_color(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.color_.IsDefault()) {
          _impl_.color_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.AddMessage.color)
}

// -------------------------------------------------------------------

// Log

// .protos.AddText add_text = 1;
inline bool Log::has_add_text() const {
  return log_case() == kAddText;
}
inline bool Log::_internal_has_add_text() const {
  return log_case() == kAddText;
}
inline void Log::set_has_add_text() {
  _impl_._oneof_case_[0] = kAddText;
}
inline void Log::clear_add_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (log_case() == kAddText) {
    if (GetArena() == nullptr) {
      delete _impl_.log_.add_text_;
    }
    clear_has_log();
  }
}
inline ::protos::AddText* Log::release_add_text() {
  // @@protoc_insertion_point(field_release:protos.Log.add_text)
  if (log_case() == kAddText) {
    clear_has_log();
    auto* temp = _impl_.log_.add_text_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddText& Log::_internal_add_text() const {
  return log_case() == kAddText ? *_impl_.log_.add_text_ : reinterpret_cast<::protos::AddText&>(::protos::_AddText_default_instance_);
}
inline const ::protos::AddText& Log::add_text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Log.add_text)
  return _internal_add_text();
}
inline ::protos::AddText* Log::unsafe_arena_release_add_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_text)
  if (log_case() == kAddText) {
    clear_has_log();
    auto* temp = _impl_.log_.add_text_;
    _impl_.log_.add_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_text(::protos::AddText* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_log();
  if (value) {
    set_has_add_text();
    _impl_.log_.add_text_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_text)
}
inline ::protos::AddText* Log::_internal_mutable_add_text() {
  if (log_case() != kAddText) {
    clear_log();
    set_has_add_text();
    _impl_.log_.add_text_ = CreateMaybeMessage<::protos::AddText>(GetArena());
  }
  return _impl_.log_.add_text_;
}
inline ::protos::AddText* Log::mutable_add_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::AddText* _msg = _internal_mutable_add_text();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_text)
  return _msg;
}

// .protos.AddPoint add_point = 2;
inline bool Log::has_add_point() const {
  return log_case() == kAddPoint;
}
inline bool Log::_internal_has_add_point() const {
  return log_case() == kAddPoint;
}
inline void Log::set_has_add_point() {
  _impl_._oneof_case_[0] = kAddPoint;
}
inline void Log::clear_add_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (log_case() == kAddPoint) {
    if (GetArena() == nullptr) {
      delete _impl_.log_.add_point_;
    }
    clear_has_log();
  }
}
inline ::protos::AddPoint* Log::release_add_point() {
  // @@protoc_insertion_point(field_release:protos.Log.add_point)
  if (log_case() == kAddPoint) {
    clear_has_log();
    auto* temp = _impl_.log_.add_point_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddPoint& Log::_internal_add_point() const {
  return log_case() == kAddPoint ? *_impl_.log_.add_point_ : reinterpret_cast<::protos::AddPoint&>(::protos::_AddPoint_default_instance_);
}
inline const ::protos::AddPoint& Log::add_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Log.add_point)
  return _internal_add_point();
}
inline ::protos::AddPoint* Log::unsafe_arena_release_add_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_point)
  if (log_case() == kAddPoint) {
    clear_has_log();
    auto* temp = _impl_.log_.add_point_;
    _impl_.log_.add_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_point(::protos::AddPoint* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_log();
  if (value) {
    set_has_add_point();
    _impl_.log_.add_point_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_point)
}
inline ::protos::AddPoint* Log::_internal_mutable_add_point() {
  if (log_case() != kAddPoint) {
    clear_log();
    set_has_add_point();
    _impl_.log_.add_point_ = CreateMaybeMessage<::protos::AddPoint>(GetArena());
  }
  return _impl_.log_.add_point_;
}
inline ::protos::AddPoint* Log::mutable_add_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::AddPoint* _msg = _internal_mutable_add_point();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_point)
  return _msg;
}

// .protos.AddLine add_line = 3;
inline bool Log::has_add_line() const {
  return log_case() == kAddLine;
}
inline bool Log::_internal_has_add_line() const {
  return log_case() == kAddLine;
}
inline void Log::set_has_add_line() {
  _impl_._oneof_case_[0] = kAddLine;
}
inline void Log::clear_add_line() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (log_case() == kAddLine) {
    if (GetArena() == nullptr) {
      delete _impl_.log_.add_line_;
    }
    clear_has_log();
  }
}
inline ::protos::AddLine* Log::release_add_line() {
  // @@protoc_insertion_point(field_release:protos.Log.add_line)
  if (log_case() == kAddLine) {
    clear_has_log();
    auto* temp = _impl_.log_.add_line_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddLine& Log::_internal_add_line() const {
  return log_case() == kAddLine ? *_impl_.log_.add_line_ : reinterpret_cast<::protos::AddLine&>(::protos::_AddLine_default_instance_);
}
inline const ::protos::AddLine& Log::add_line() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Log.add_line)
  return _internal_add_line();
}
inline ::protos::AddLine* Log::unsafe_arena_release_add_line() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_line)
  if (log_case() == kAddLine) {
    clear_has_log();
    auto* temp = _impl_.log_.add_line_;
    _impl_.log_.add_line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_line(::protos::AddLine* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_log();
  if (value) {
    set_has_add_line();
    _impl_.log_.add_line_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_line)
}
inline ::protos::AddLine* Log::_internal_mutable_add_line() {
  if (log_case() != kAddLine) {
    clear_log();
    set_has_add_line();
    _impl_.log_.add_line_ = CreateMaybeMessage<::protos::AddLine>(GetArena());
  }
  return _impl_.log_.add_line_;
}
inline ::protos::AddLine* Log::mutable_add_line() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::AddLine* _msg = _internal_mutable_add_line();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_line)
  return _msg;
}

// .protos.AddArc add_arc = 4;
inline bool Log::has_add_arc() const {
  return log_case() == kAddArc;
}
inline bool Log::_internal_has_add_arc() const {
  return log_case() == kAddArc;
}
inline void Log::set_has_add_arc() {
  _impl_._oneof_case_[0] = kAddArc;
}
inline void Log::clear_add_arc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (log_case() == kAddArc) {
    if (GetArena() == nullptr) {
      delete _impl_.log_.add_arc_;
    }
    clear_has_log();
  }
}
inline ::protos::AddArc* Log::release_add_arc() {
  // @@protoc_insertion_point(field_release:protos.Log.add_arc)
  if (log_case() == kAddArc) {
    clear_has_log();
    auto* temp = _impl_.log_.add_arc_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_arc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddArc& Log::_internal_add_arc() const {
  return log_case() == kAddArc ? *_impl_.log_.add_arc_ : reinterpret_cast<::protos::AddArc&>(::protos::_AddArc_default_instance_);
}
inline const ::protos::AddArc& Log::add_arc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Log.add_arc)
  return _internal_add_arc();
}
inline ::protos::AddArc* Log::unsafe_arena_release_add_arc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_arc)
  if (log_case() == kAddArc) {
    clear_has_log();
    auto* temp = _impl_.log_.add_arc_;
    _impl_.log_.add_arc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_arc(::protos::AddArc* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_log();
  if (value) {
    set_has_add_arc();
    _impl_.log_.add_arc_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_arc)
}
inline ::protos::AddArc* Log::_internal_mutable_add_arc() {
  if (log_case() != kAddArc) {
    clear_log();
    set_has_add_arc();
    _impl_.log_.add_arc_ = CreateMaybeMessage<::protos::AddArc>(GetArena());
  }
  return _impl_.log_.add_arc_;
}
inline ::protos::AddArc* Log::mutable_add_arc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::AddArc* _msg = _internal_mutable_add_arc();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_arc)
  return _msg;
}

// .protos.AddCircle add_circle = 5;
inline bool Log::has_add_circle() const {
  return log_case() == kAddCircle;
}
inline bool Log::_internal_has_add_circle() const {
  return log_case() == kAddCircle;
}
inline void Log::set_has_add_circle() {
  _impl_._oneof_case_[0] = kAddCircle;
}
inline void Log::clear_add_circle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (log_case() == kAddCircle) {
    if (GetArena() == nullptr) {
      delete _impl_.log_.add_circle_;
    }
    clear_has_log();
  }
}
inline ::protos::AddCircle* Log::release_add_circle() {
  // @@protoc_insertion_point(field_release:protos.Log.add_circle)
  if (log_case() == kAddCircle) {
    clear_has_log();
    auto* temp = _impl_.log_.add_circle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddCircle& Log::_internal_add_circle() const {
  return log_case() == kAddCircle ? *_impl_.log_.add_circle_ : reinterpret_cast<::protos::AddCircle&>(::protos::_AddCircle_default_instance_);
}
inline const ::protos::AddCircle& Log::add_circle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Log.add_circle)
  return _internal_add_circle();
}
inline ::protos::AddCircle* Log::unsafe_arena_release_add_circle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_circle)
  if (log_case() == kAddCircle) {
    clear_has_log();
    auto* temp = _impl_.log_.add_circle_;
    _impl_.log_.add_circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_circle(::protos::AddCircle* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_log();
  if (value) {
    set_has_add_circle();
    _impl_.log_.add_circle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_circle)
}
inline ::protos::AddCircle* Log::_internal_mutable_add_circle() {
  if (log_case() != kAddCircle) {
    clear_log();
    set_has_add_circle();
    _impl_.log_.add_circle_ = CreateMaybeMessage<::protos::AddCircle>(GetArena());
  }
  return _impl_.log_.add_circle_;
}
inline ::protos::AddCircle* Log::mutable_add_circle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::AddCircle* _msg = _internal_mutable_add_circle();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_circle)
  return _msg;
}

// .protos.AddTriangle add_triangle = 6;
inline bool Log::has_add_triangle() const {
  return log_case() == kAddTriangle;
}
inline bool Log::_internal_has_add_triangle() const {
  return log_case() == kAddTriangle;
}
inline void Log::set_has_add_triangle() {
  _impl_._oneof_case_[0] = kAddTriangle;
}
inline void Log::clear_add_triangle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (log_case() == kAddTriangle) {
    if (GetArena() == nullptr) {
      delete _impl_.log_.add_triangle_;
    }
    clear_has_log();
  }
}
inline ::protos::AddTriangle* Log::release_add_triangle() {
  // @@protoc_insertion_point(field_release:protos.Log.add_triangle)
  if (log_case() == kAddTriangle) {
    clear_has_log();
    auto* temp = _impl_.log_.add_triangle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_triangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddTriangle& Log::_internal_add_triangle() const {
  return log_case() == kAddTriangle ? *_impl_.log_.add_triangle_ : reinterpret_cast<::protos::AddTriangle&>(::protos::_AddTriangle_default_instance_);
}
inline const ::protos::AddTriangle& Log::add_triangle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Log.add_triangle)
  return _internal_add_triangle();
}
inline ::protos::AddTriangle* Log::unsafe_arena_release_add_triangle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_triangle)
  if (log_case() == kAddTriangle) {
    clear_has_log();
    auto* temp = _impl_.log_.add_triangle_;
    _impl_.log_.add_triangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_triangle(::protos::AddTriangle* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_log();
  if (value) {
    set_has_add_triangle();
    _impl_.log_.add_triangle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_triangle)
}
inline ::protos::AddTriangle* Log::_internal_mutable_add_triangle() {
  if (log_case() != kAddTriangle) {
    clear_log();
    set_has_add_triangle();
    _impl_.log_.add_triangle_ = CreateMaybeMessage<::protos::AddTriangle>(GetArena());
  }
  return _impl_.log_.add_triangle_;
}
inline ::protos::AddTriangle* Log::mutable_add_triangle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::AddTriangle* _msg = _internal_mutable_add_triangle();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_triangle)
  return _msg;
}

// .protos.AddRectangle add_rectangle = 7;
inline bool Log::has_add_rectangle() const {
  return log_case() == kAddRectangle;
}
inline bool Log::_internal_has_add_rectangle() const {
  return log_case() == kAddRectangle;
}
inline void Log::set_has_add_rectangle() {
  _impl_._oneof_case_[0] = kAddRectangle;
}
inline void Log::clear_add_rectangle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (log_case() == kAddRectangle) {
    if (GetArena() == nullptr) {
      delete _impl_.log_.add_rectangle_;
    }
    clear_has_log();
  }
}
inline ::protos::AddRectangle* Log::release_add_rectangle() {
  // @@protoc_insertion_point(field_release:protos.Log.add_rectangle)
  if (log_case() == kAddRectangle) {
    clear_has_log();
    auto* temp = _impl_.log_.add_rectangle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddRectangle& Log::_internal_add_rectangle() const {
  return log_case() == kAddRectangle ? *_impl_.log_.add_rectangle_ : reinterpret_cast<::protos::AddRectangle&>(::protos::_AddRectangle_default_instance_);
}
inline const ::protos::AddRectangle& Log::add_rectangle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Log.add_rectangle)
  return _internal_add_rectangle();
}
inline ::protos::AddRectangle* Log::unsafe_arena_release_add_rectangle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_rectangle)
  if (log_case() == kAddRectangle) {
    clear_has_log();
    auto* temp = _impl_.log_.add_rectangle_;
    _impl_.log_.add_rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_rectangle(::protos::AddRectangle* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_log();
  if (value) {
    set_has_add_rectangle();
    _impl_.log_.add_rectangle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_rectangle)
}
inline ::protos::AddRectangle* Log::_internal_mutable_add_rectangle() {
  if (log_case() != kAddRectangle) {
    clear_log();
    set_has_add_rectangle();
    _impl_.log_.add_rectangle_ = CreateMaybeMessage<::protos::AddRectangle>(GetArena());
  }
  return _impl_.log_.add_rectangle_;
}
inline ::protos::AddRectangle* Log::mutable_add_rectangle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::AddRectangle* _msg = _internal_mutable_add_rectangle();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_rectangle)
  return _msg;
}

// .protos.AddSector add_sector = 8;
inline bool Log::has_add_sector() const {
  return log_case() == kAddSector;
}
inline bool Log::_internal_has_add_sector() const {
  return log_case() == kAddSector;
}
inline void Log::set_has_add_sector() {
  _impl_._oneof_case_[0] = kAddSector;
}
inline void Log::clear_add_sector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (log_case() == kAddSector) {
    if (GetArena() == nullptr) {
      delete _impl_.log_.add_sector_;
    }
    clear_has_log();
  }
}
inline ::protos::AddSector* Log::release_add_sector() {
  // @@protoc_insertion_point(field_release:protos.Log.add_sector)
  if (log_case() == kAddSector) {
    clear_has_log();
    auto* temp = _impl_.log_.add_sector_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_sector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddSector& Log::_internal_add_sector() const {
  return log_case() == kAddSector ? *_impl_.log_.add_sector_ : reinterpret_cast<::protos::AddSector&>(::protos::_AddSector_default_instance_);
}
inline const ::protos::AddSector& Log::add_sector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Log.add_sector)
  return _internal_add_sector();
}
inline ::protos::AddSector* Log::unsafe_arena_release_add_sector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_sector)
  if (log_case() == kAddSector) {
    clear_has_log();
    auto* temp = _impl_.log_.add_sector_;
    _impl_.log_.add_sector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_sector(::protos::AddSector* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_log();
  if (value) {
    set_has_add_sector();
    _impl_.log_.add_sector_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_sector)
}
inline ::protos::AddSector* Log::_internal_mutable_add_sector() {
  if (log_case() != kAddSector) {
    clear_log();
    set_has_add_sector();
    _impl_.log_.add_sector_ = CreateMaybeMessage<::protos::AddSector>(GetArena());
  }
  return _impl_.log_.add_sector_;
}
inline ::protos::AddSector* Log::mutable_add_sector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::AddSector* _msg = _internal_mutable_add_sector();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_sector)
  return _msg;
}

// .protos.AddMessage add_message = 9;
inline bool Log::has_add_message() const {
  return log_case() == kAddMessage;
}
inline bool Log::_internal_has_add_message() const {
  return log_case() == kAddMessage;
}
inline void Log::set_has_add_message() {
  _impl_._oneof_case_[0] = kAddMessage;
}
inline void Log::clear_add_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (log_case() == kAddMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.log_.add_message_;
    }
    clear_has_log();
  }
}
inline ::protos::AddMessage* Log::release_add_message() {
  // @@protoc_insertion_point(field_release:protos.Log.add_message)
  if (log_case() == kAddMessage) {
    clear_has_log();
    auto* temp = _impl_.log_.add_message_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.log_.add_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AddMessage& Log::_internal_add_message() const {
  return log_case() == kAddMessage ? *_impl_.log_.add_message_ : reinterpret_cast<::protos::AddMessage&>(::protos::_AddMessage_default_instance_);
}
inline const ::protos::AddMessage& Log::add_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Log.add_message)
  return _internal_add_message();
}
inline ::protos::AddMessage* Log::unsafe_arena_release_add_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.Log.add_message)
  if (log_case() == kAddMessage) {
    clear_has_log();
    auto* temp = _impl_.log_.add_message_;
    _impl_.log_.add_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Log::unsafe_arena_set_allocated_add_message(::protos::AddMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_log();
  if (value) {
    set_has_add_message();
    _impl_.log_.add_message_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Log.add_message)
}
inline ::protos::AddMessage* Log::_internal_mutable_add_message() {
  if (log_case() != kAddMessage) {
    clear_log();
    set_has_add_message();
    _impl_.log_.add_message_ = CreateMaybeMessage<::protos::AddMessage>(GetArena());
  }
  return _impl_.log_.add_message_;
}
inline ::protos::AddMessage* Log::mutable_add_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::AddMessage* _msg = _internal_mutable_add_message();
  // @@protoc_insertion_point(field_mutable:protos.Log.add_message)
  return _msg;
}

inline bool Log::has_log() const {
  return log_case() != LOG_NOT_SET;
}
inline void Log::clear_has_log() {
  _impl_._oneof_case_[0] = LOG_NOT_SET;
}
inline Log::LogCase Log::log_case() const {
  return Log::LogCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DebugClient

// string message = 1;
inline void DebugClient::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& DebugClient::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.DebugClient.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebugClient::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.DebugClient.message)
}
inline std::string* DebugClient::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protos.DebugClient.message)
  return _s;
}
inline const std::string& DebugClient::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void DebugClient::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* DebugClient::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* DebugClient::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.DebugClient.message)
  return _impl_.message_.Release();
}
inline void DebugClient::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.DebugClient.message)
}

// -------------------------------------------------------------------

// Body_GoToPoint

// .protos.Vector2D target_point = 1;
inline bool Body_GoToPoint::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_GoToPoint::clear_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_GoToPoint::_internal_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_GoToPoint::target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Body_GoToPoint.target_point)
  return _internal_target_point();
}
inline void Body_GoToPoint::unsafe_arena_set_allocated_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_GoToPoint.target_point)
}
inline ::protos::Vector2D* Body_GoToPoint::release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Body_GoToPoint::unsafe_arena_release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Body_GoToPoint.target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_GoToPoint::_internal_mutable_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_GoToPoint::mutable_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_GoToPoint.target_point)
  return _msg;
}
inline void Body_GoToPoint::set_allocated_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Body_GoToPoint.target_point)
}

// float distance_threshold = 2;
inline void Body_GoToPoint::clear_distance_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distance_threshold_ = 0;
}
inline float Body_GoToPoint::distance_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Body_GoToPoint.distance_threshold)
  return _internal_distance_threshold();
}
inline void Body_GoToPoint::set_distance_threshold(float value) {
  _internal_set_distance_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Body_GoToPoint.distance_threshold)
}
inline float Body_GoToPoint::_internal_distance_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_threshold_;
}
inline void Body_GoToPoint::_internal_set_distance_threshold(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.distance_threshold_ = value;
}

// float max_dash_power = 3;
inline void Body_GoToPoint::clear_max_dash_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_dash_power_ = 0;
}
inline float Body_GoToPoint::max_dash_power() const {
  // @@protoc_insertion_point(field_get:protos.Body_GoToPoint.max_dash_power)
  return _internal_max_dash_power();
}
inline void Body_GoToPoint::set_max_dash_power(float value) {
  _internal_set_max_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.Body_GoToPoint.max_dash_power)
}
inline float Body_GoToPoint::_internal_max_dash_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_dash_power_;
}
inline void Body_GoToPoint::_internal_set_max_dash_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_dash_power_ = value;
}

// -------------------------------------------------------------------

// Body_SmartKick

// .protos.Vector2D target_point = 1;
inline bool Body_SmartKick::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_SmartKick::clear_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_SmartKick::_internal_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_SmartKick::target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Body_SmartKick.target_point)
  return _internal_target_point();
}
inline void Body_SmartKick::unsafe_arena_set_allocated_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_SmartKick.target_point)
}
inline ::protos::Vector2D* Body_SmartKick::release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Body_SmartKick::unsafe_arena_release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Body_SmartKick.target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_SmartKick::_internal_mutable_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_SmartKick::mutable_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_SmartKick.target_point)
  return _msg;
}
inline void Body_SmartKick::set_allocated_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Body_SmartKick.target_point)
}

// float first_speed = 2;
inline void Body_SmartKick::clear_first_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.first_speed_ = 0;
}
inline float Body_SmartKick::first_speed() const {
  // @@protoc_insertion_point(field_get:protos.Body_SmartKick.first_speed)
  return _internal_first_speed();
}
inline void Body_SmartKick::set_first_speed(float value) {
  _internal_set_first_speed(value);
  // @@protoc_insertion_point(field_set:protos.Body_SmartKick.first_speed)
}
inline float Body_SmartKick::_internal_first_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.first_speed_;
}
inline void Body_SmartKick::_internal_set_first_speed(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.first_speed_ = value;
}

// float first_speed_threshold = 3;
inline void Body_SmartKick::clear_first_speed_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.first_speed_threshold_ = 0;
}
inline float Body_SmartKick::first_speed_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Body_SmartKick.first_speed_threshold)
  return _internal_first_speed_threshold();
}
inline void Body_SmartKick::set_first_speed_threshold(float value) {
  _internal_set_first_speed_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Body_SmartKick.first_speed_threshold)
}
inline float Body_SmartKick::_internal_first_speed_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.first_speed_threshold_;
}
inline void Body_SmartKick::_internal_set_first_speed_threshold(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.first_speed_threshold_ = value;
}

// int32 max_steps = 4;
inline void Body_SmartKick::clear_max_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_steps_ = 0;
}
inline ::int32_t Body_SmartKick::max_steps() const {
  // @@protoc_insertion_point(field_get:protos.Body_SmartKick.max_steps)
  return _internal_max_steps();
}
inline void Body_SmartKick::set_max_steps(::int32_t value) {
  _internal_set_max_steps(value);
  // @@protoc_insertion_point(field_set:protos.Body_SmartKick.max_steps)
}
inline ::int32_t Body_SmartKick::_internal_max_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_steps_;
}
inline void Body_SmartKick::_internal_set_max_steps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_steps_ = value;
}

// -------------------------------------------------------------------

// Bhv_BeforeKickOff

// .protos.Vector2D point = 1;
inline bool Bhv_BeforeKickOff::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline void Bhv_BeforeKickOff::clear_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Bhv_BeforeKickOff::_internal_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Bhv_BeforeKickOff::point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Bhv_BeforeKickOff.point)
  return _internal_point();
}
inline void Bhv_BeforeKickOff::unsafe_arena_set_allocated_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Bhv_BeforeKickOff.point)
}
inline ::protos::Vector2D* Bhv_BeforeKickOff::release_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Bhv_BeforeKickOff::unsafe_arena_release_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Bhv_BeforeKickOff.point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Bhv_BeforeKickOff::_internal_mutable_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.point_;
}
inline ::protos::Vector2D* Bhv_BeforeKickOff::mutable_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:protos.Bhv_BeforeKickOff.point)
  return _msg;
}
inline void Bhv_BeforeKickOff::set_allocated_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Bhv_BeforeKickOff.point)
}

// -------------------------------------------------------------------

// Bhv_BodyNeckToBall

// -------------------------------------------------------------------

// Bhv_BodyNeckToPoint

// .protos.Vector2D point = 1;
inline bool Bhv_BodyNeckToPoint::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline void Bhv_BodyNeckToPoint::clear_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Bhv_BodyNeckToPoint::_internal_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Bhv_BodyNeckToPoint::point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Bhv_BodyNeckToPoint.point)
  return _internal_point();
}
inline void Bhv_BodyNeckToPoint::unsafe_arena_set_allocated_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Bhv_BodyNeckToPoint.point)
}
inline ::protos::Vector2D* Bhv_BodyNeckToPoint::release_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Bhv_BodyNeckToPoint::unsafe_arena_release_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Bhv_BodyNeckToPoint.point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Bhv_BodyNeckToPoint::_internal_mutable_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.point_;
}
inline ::protos::Vector2D* Bhv_BodyNeckToPoint::mutable_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:protos.Bhv_BodyNeckToPoint.point)
  return _msg;
}
inline void Bhv_BodyNeckToPoint::set_allocated_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Bhv_BodyNeckToPoint.point)
}

// -------------------------------------------------------------------

// Bhv_Emergency

// -------------------------------------------------------------------

// Bhv_GoToPointLookBall

// .protos.Vector2D target_point = 1;
inline bool Bhv_GoToPointLookBall::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Bhv_GoToPointLookBall::clear_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Bhv_GoToPointLookBall::_internal_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Bhv_GoToPointLookBall::target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Bhv_GoToPointLookBall.target_point)
  return _internal_target_point();
}
inline void Bhv_GoToPointLookBall::unsafe_arena_set_allocated_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Bhv_GoToPointLookBall.target_point)
}
inline ::protos::Vector2D* Bhv_GoToPointLookBall::release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Bhv_GoToPointLookBall::unsafe_arena_release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Bhv_GoToPointLookBall.target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Bhv_GoToPointLookBall::_internal_mutable_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Bhv_GoToPointLookBall::mutable_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Bhv_GoToPointLookBall.target_point)
  return _msg;
}
inline void Bhv_GoToPointLookBall::set_allocated_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Bhv_GoToPointLookBall.target_point)
}

// float distance_threshold = 2;
inline void Bhv_GoToPointLookBall::clear_distance_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distance_threshold_ = 0;
}
inline float Bhv_GoToPointLookBall::distance_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Bhv_GoToPointLookBall.distance_threshold)
  return _internal_distance_threshold();
}
inline void Bhv_GoToPointLookBall::set_distance_threshold(float value) {
  _internal_set_distance_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Bhv_GoToPointLookBall.distance_threshold)
}
inline float Bhv_GoToPointLookBall::_internal_distance_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_threshold_;
}
inline void Bhv_GoToPointLookBall::_internal_set_distance_threshold(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.distance_threshold_ = value;
}

// float max_dash_power = 3;
inline void Bhv_GoToPointLookBall::clear_max_dash_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_dash_power_ = 0;
}
inline float Bhv_GoToPointLookBall::max_dash_power() const {
  // @@protoc_insertion_point(field_get:protos.Bhv_GoToPointLookBall.max_dash_power)
  return _internal_max_dash_power();
}
inline void Bhv_GoToPointLookBall::set_max_dash_power(float value) {
  _internal_set_max_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.Bhv_GoToPointLookBall.max_dash_power)
}
inline float Bhv_GoToPointLookBall::_internal_max_dash_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_dash_power_;
}
inline void Bhv_GoToPointLookBall::_internal_set_max_dash_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_dash_power_ = value;
}

// -------------------------------------------------------------------

// Bhv_NeckBodyToBall

// float angle_buf = 1;
inline void Bhv_NeckBodyToBall::clear_angle_buf() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_buf_ = 0;
}
inline float Bhv_NeckBodyToBall::angle_buf() const {
  // @@protoc_insertion_point(field_get:protos.Bhv_NeckBodyToBall.angle_buf)
  return _internal_angle_buf();
}
inline void Bhv_NeckBodyToBall::set_angle_buf(float value) {
  _internal_set_angle_buf(value);
  // @@protoc_insertion_point(field_set:protos.Bhv_NeckBodyToBall.angle_buf)
}
inline float Bhv_NeckBodyToBall::_internal_angle_buf() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angle_buf_;
}
inline void Bhv_NeckBodyToBall::_internal_set_angle_buf(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.angle_buf_ = value;
}

// -------------------------------------------------------------------

// Bhv_NeckBodyToPoint

// .protos.Vector2D point = 1;
inline bool Bhv_NeckBodyToPoint::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline void Bhv_NeckBodyToPoint::clear_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Bhv_NeckBodyToPoint::_internal_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Bhv_NeckBodyToPoint::point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Bhv_NeckBodyToPoint.point)
  return _internal_point();
}
inline void Bhv_NeckBodyToPoint::unsafe_arena_set_allocated_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Bhv_NeckBodyToPoint.point)
}
inline ::protos::Vector2D* Bhv_NeckBodyToPoint::release_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Bhv_NeckBodyToPoint::unsafe_arena_release_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Bhv_NeckBodyToPoint.point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Bhv_NeckBodyToPoint::_internal_mutable_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.point_;
}
inline ::protos::Vector2D* Bhv_NeckBodyToPoint::mutable_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:protos.Bhv_NeckBodyToPoint.point)
  return _msg;
}
inline void Bhv_NeckBodyToPoint::set_allocated_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Bhv_NeckBodyToPoint.point)
}

// float angle_buf = 2;
inline void Bhv_NeckBodyToPoint::clear_angle_buf() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_buf_ = 0;
}
inline float Bhv_NeckBodyToPoint::angle_buf() const {
  // @@protoc_insertion_point(field_get:protos.Bhv_NeckBodyToPoint.angle_buf)
  return _internal_angle_buf();
}
inline void Bhv_NeckBodyToPoint::set_angle_buf(float value) {
  _internal_set_angle_buf(value);
  // @@protoc_insertion_point(field_set:protos.Bhv_NeckBodyToPoint.angle_buf)
}
inline float Bhv_NeckBodyToPoint::_internal_angle_buf() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angle_buf_;
}
inline void Bhv_NeckBodyToPoint::_internal_set_angle_buf(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.angle_buf_ = value;
}

// -------------------------------------------------------------------

// Bhv_ScanField

// -------------------------------------------------------------------

// Body_AdvanceBall

// -------------------------------------------------------------------

// Body_ClearBall

// -------------------------------------------------------------------

// Body_Dribble

// .protos.Vector2D target_point = 1;
inline bool Body_Dribble::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_Dribble::clear_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_Dribble::_internal_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_Dribble::target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Body_Dribble.target_point)
  return _internal_target_point();
}
inline void Body_Dribble::unsafe_arena_set_allocated_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_Dribble.target_point)
}
inline ::protos::Vector2D* Body_Dribble::release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Body_Dribble::unsafe_arena_release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Body_Dribble.target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_Dribble::_internal_mutable_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_Dribble::mutable_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_Dribble.target_point)
  return _msg;
}
inline void Body_Dribble::set_allocated_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Body_Dribble.target_point)
}

// float distance_threshold = 2;
inline void Body_Dribble::clear_distance_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distance_threshold_ = 0;
}
inline float Body_Dribble::distance_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Body_Dribble.distance_threshold)
  return _internal_distance_threshold();
}
inline void Body_Dribble::set_distance_threshold(float value) {
  _internal_set_distance_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Body_Dribble.distance_threshold)
}
inline float Body_Dribble::_internal_distance_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_threshold_;
}
inline void Body_Dribble::_internal_set_distance_threshold(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.distance_threshold_ = value;
}

// float dash_power = 3;
inline void Body_Dribble::clear_dash_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_power_ = 0;
}
inline float Body_Dribble::dash_power() const {
  // @@protoc_insertion_point(field_get:protos.Body_Dribble.dash_power)
  return _internal_dash_power();
}
inline void Body_Dribble::set_dash_power(float value) {
  _internal_set_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.Body_Dribble.dash_power)
}
inline float Body_Dribble::_internal_dash_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_power_;
}
inline void Body_Dribble::_internal_set_dash_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dash_power_ = value;
}

// int32 dash_count = 4;
inline void Body_Dribble::clear_dash_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_count_ = 0;
}
inline ::int32_t Body_Dribble::dash_count() const {
  // @@protoc_insertion_point(field_get:protos.Body_Dribble.dash_count)
  return _internal_dash_count();
}
inline void Body_Dribble::set_dash_count(::int32_t value) {
  _internal_set_dash_count(value);
  // @@protoc_insertion_point(field_set:protos.Body_Dribble.dash_count)
}
inline ::int32_t Body_Dribble::_internal_dash_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_count_;
}
inline void Body_Dribble::_internal_set_dash_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dash_count_ = value;
}

// bool dodge = 5;
inline void Body_Dribble::clear_dodge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dodge_ = false;
}
inline bool Body_Dribble::dodge() const {
  // @@protoc_insertion_point(field_get:protos.Body_Dribble.dodge)
  return _internal_dodge();
}
inline void Body_Dribble::set_dodge(bool value) {
  _internal_set_dodge(value);
  // @@protoc_insertion_point(field_set:protos.Body_Dribble.dodge)
}
inline bool Body_Dribble::_internal_dodge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dodge_;
}
inline void Body_Dribble::_internal_set_dodge(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dodge_ = value;
}

// -------------------------------------------------------------------

// Body_GoToPointDodge

// .protos.Vector2D target_point = 1;
inline bool Body_GoToPointDodge::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_GoToPointDodge::clear_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_GoToPointDodge::_internal_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_GoToPointDodge::target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Body_GoToPointDodge.target_point)
  return _internal_target_point();
}
inline void Body_GoToPointDodge::unsafe_arena_set_allocated_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_GoToPointDodge.target_point)
}
inline ::protos::Vector2D* Body_GoToPointDodge::release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Body_GoToPointDodge::unsafe_arena_release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Body_GoToPointDodge.target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_GoToPointDodge::_internal_mutable_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_GoToPointDodge::mutable_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_GoToPointDodge.target_point)
  return _msg;
}
inline void Body_GoToPointDodge::set_allocated_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Body_GoToPointDodge.target_point)
}

// float dash_power = 2;
inline void Body_GoToPointDodge::clear_dash_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_power_ = 0;
}
inline float Body_GoToPointDodge::dash_power() const {
  // @@protoc_insertion_point(field_get:protos.Body_GoToPointDodge.dash_power)
  return _internal_dash_power();
}
inline void Body_GoToPointDodge::set_dash_power(float value) {
  _internal_set_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.Body_GoToPointDodge.dash_power)
}
inline float Body_GoToPointDodge::_internal_dash_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_power_;
}
inline void Body_GoToPointDodge::_internal_set_dash_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dash_power_ = value;
}

// -------------------------------------------------------------------

// Body_HoldBall

// bool do_turn = 1;
inline void Body_HoldBall::clear_do_turn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.do_turn_ = false;
}
inline bool Body_HoldBall::do_turn() const {
  // @@protoc_insertion_point(field_get:protos.Body_HoldBall.do_turn)
  return _internal_do_turn();
}
inline void Body_HoldBall::set_do_turn(bool value) {
  _internal_set_do_turn(value);
  // @@protoc_insertion_point(field_set:protos.Body_HoldBall.do_turn)
}
inline bool Body_HoldBall::_internal_do_turn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.do_turn_;
}
inline void Body_HoldBall::_internal_set_do_turn(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.do_turn_ = value;
}

// .protos.Vector2D turn_target_point = 2;
inline bool Body_HoldBall::has_turn_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.turn_target_point_ != nullptr);
  return value;
}
inline void Body_HoldBall::clear_turn_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.turn_target_point_ != nullptr) _impl_.turn_target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_HoldBall::_internal_turn_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.turn_target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_HoldBall::turn_target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Body_HoldBall.turn_target_point)
  return _internal_turn_target_point();
}
inline void Body_HoldBall::unsafe_arena_set_allocated_turn_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.turn_target_point_);
  }
  _impl_.turn_target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_HoldBall.turn_target_point)
}
inline ::protos::Vector2D* Body_HoldBall::release_turn_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.turn_target_point_;
  _impl_.turn_target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Body_HoldBall::unsafe_arena_release_turn_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Body_HoldBall.turn_target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.turn_target_point_;
  _impl_.turn_target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_HoldBall::_internal_mutable_turn_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.turn_target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.turn_target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.turn_target_point_;
}
inline ::protos::Vector2D* Body_HoldBall::mutable_turn_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_turn_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_HoldBall.turn_target_point)
  return _msg;
}
inline void Body_HoldBall::set_allocated_turn_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.turn_target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.turn_target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Body_HoldBall.turn_target_point)
}

// .protos.Vector2D kick_target_point = 3;
inline bool Body_HoldBall::has_kick_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kick_target_point_ != nullptr);
  return value;
}
inline void Body_HoldBall::clear_kick_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.kick_target_point_ != nullptr) _impl_.kick_target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& Body_HoldBall::_internal_kick_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.kick_target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_HoldBall::kick_target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Body_HoldBall.kick_target_point)
  return _internal_kick_target_point();
}
inline void Body_HoldBall::unsafe_arena_set_allocated_kick_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kick_target_point_);
  }
  _impl_.kick_target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_HoldBall.kick_target_point)
}
inline ::protos::Vector2D* Body_HoldBall::release_kick_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.kick_target_point_;
  _impl_.kick_target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Body_HoldBall::unsafe_arena_release_kick_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Body_HoldBall.kick_target_point)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.kick_target_point_;
  _impl_.kick_target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_HoldBall::_internal_mutable_kick_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.kick_target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.kick_target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.kick_target_point_;
}
inline ::protos::Vector2D* Body_HoldBall::mutable_kick_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_kick_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_HoldBall.kick_target_point)
  return _msg;
}
inline void Body_HoldBall::set_allocated_kick_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.kick_target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.kick_target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Body_HoldBall.kick_target_point)
}

// -------------------------------------------------------------------

// Body_Intercept

// bool save_recovery = 1;
inline void Body_Intercept::clear_save_recovery() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.save_recovery_ = false;
}
inline bool Body_Intercept::save_recovery() const {
  // @@protoc_insertion_point(field_get:protos.Body_Intercept.save_recovery)
  return _internal_save_recovery();
}
inline void Body_Intercept::set_save_recovery(bool value) {
  _internal_set_save_recovery(value);
  // @@protoc_insertion_point(field_set:protos.Body_Intercept.save_recovery)
}
inline bool Body_Intercept::_internal_save_recovery() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.save_recovery_;
}
inline void Body_Intercept::_internal_set_save_recovery(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.save_recovery_ = value;
}

// .protos.Vector2D face_point = 2;
inline bool Body_Intercept::has_face_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.face_point_ != nullptr);
  return value;
}
inline void Body_Intercept::clear_face_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.face_point_ != nullptr) _impl_.face_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_Intercept::_internal_face_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.face_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_Intercept::face_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Body_Intercept.face_point)
  return _internal_face_point();
}
inline void Body_Intercept::unsafe_arena_set_allocated_face_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.face_point_);
  }
  _impl_.face_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_Intercept.face_point)
}
inline ::protos::Vector2D* Body_Intercept::release_face_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.face_point_;
  _impl_.face_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Body_Intercept::unsafe_arena_release_face_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Body_Intercept.face_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.face_point_;
  _impl_.face_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_Intercept::_internal_mutable_face_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.face_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.face_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.face_point_;
}
inline ::protos::Vector2D* Body_Intercept::mutable_face_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_face_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_Intercept.face_point)
  return _msg;
}
inline void Body_Intercept::set_allocated_face_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.face_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.face_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Body_Intercept.face_point)
}

// -------------------------------------------------------------------

// Body_KickOneStep

// .protos.Vector2D target_point = 1;
inline bool Body_KickOneStep::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_KickOneStep::clear_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_KickOneStep::_internal_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_KickOneStep::target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Body_KickOneStep.target_point)
  return _internal_target_point();
}
inline void Body_KickOneStep::unsafe_arena_set_allocated_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_KickOneStep.target_point)
}
inline ::protos::Vector2D* Body_KickOneStep::release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Body_KickOneStep::unsafe_arena_release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Body_KickOneStep.target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_KickOneStep::_internal_mutable_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_KickOneStep::mutable_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_KickOneStep.target_point)
  return _msg;
}
inline void Body_KickOneStep::set_allocated_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Body_KickOneStep.target_point)
}

// float first_speed = 2;
inline void Body_KickOneStep::clear_first_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.first_speed_ = 0;
}
inline float Body_KickOneStep::first_speed() const {
  // @@protoc_insertion_point(field_get:protos.Body_KickOneStep.first_speed)
  return _internal_first_speed();
}
inline void Body_KickOneStep::set_first_speed(float value) {
  _internal_set_first_speed(value);
  // @@protoc_insertion_point(field_set:protos.Body_KickOneStep.first_speed)
}
inline float Body_KickOneStep::_internal_first_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.first_speed_;
}
inline void Body_KickOneStep::_internal_set_first_speed(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.first_speed_ = value;
}

// bool force_mode = 3;
inline void Body_KickOneStep::clear_force_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.force_mode_ = false;
}
inline bool Body_KickOneStep::force_mode() const {
  // @@protoc_insertion_point(field_get:protos.Body_KickOneStep.force_mode)
  return _internal_force_mode();
}
inline void Body_KickOneStep::set_force_mode(bool value) {
  _internal_set_force_mode(value);
  // @@protoc_insertion_point(field_set:protos.Body_KickOneStep.force_mode)
}
inline bool Body_KickOneStep::_internal_force_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.force_mode_;
}
inline void Body_KickOneStep::_internal_set_force_mode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.force_mode_ = value;
}

// -------------------------------------------------------------------

// Body_StopBall

// -------------------------------------------------------------------

// Body_StopDash

// bool save_recovery = 1;
inline void Body_StopDash::clear_save_recovery() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.save_recovery_ = false;
}
inline bool Body_StopDash::save_recovery() const {
  // @@protoc_insertion_point(field_get:protos.Body_StopDash.save_recovery)
  return _internal_save_recovery();
}
inline void Body_StopDash::set_save_recovery(bool value) {
  _internal_set_save_recovery(value);
  // @@protoc_insertion_point(field_set:protos.Body_StopDash.save_recovery)
}
inline bool Body_StopDash::_internal_save_recovery() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.save_recovery_;
}
inline void Body_StopDash::_internal_set_save_recovery(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.save_recovery_ = value;
}

// -------------------------------------------------------------------

// Body_TackleToPoint

// .protos.Vector2D target_point = 1;
inline bool Body_TackleToPoint::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_TackleToPoint::clear_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_TackleToPoint::_internal_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_TackleToPoint::target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Body_TackleToPoint.target_point)
  return _internal_target_point();
}
inline void Body_TackleToPoint::unsafe_arena_set_allocated_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_TackleToPoint.target_point)
}
inline ::protos::Vector2D* Body_TackleToPoint::release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Body_TackleToPoint::unsafe_arena_release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Body_TackleToPoint.target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_TackleToPoint::_internal_mutable_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_TackleToPoint::mutable_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_TackleToPoint.target_point)
  return _msg;
}
inline void Body_TackleToPoint::set_allocated_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Body_TackleToPoint.target_point)
}

// float min_probability = 2;
inline void Body_TackleToPoint::clear_min_probability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_probability_ = 0;
}
inline float Body_TackleToPoint::min_probability() const {
  // @@protoc_insertion_point(field_get:protos.Body_TackleToPoint.min_probability)
  return _internal_min_probability();
}
inline void Body_TackleToPoint::set_min_probability(float value) {
  _internal_set_min_probability(value);
  // @@protoc_insertion_point(field_set:protos.Body_TackleToPoint.min_probability)
}
inline float Body_TackleToPoint::_internal_min_probability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_probability_;
}
inline void Body_TackleToPoint::_internal_set_min_probability(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_probability_ = value;
}

// float min_speed = 3;
inline void Body_TackleToPoint::clear_min_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_speed_ = 0;
}
inline float Body_TackleToPoint::min_speed() const {
  // @@protoc_insertion_point(field_get:protos.Body_TackleToPoint.min_speed)
  return _internal_min_speed();
}
inline void Body_TackleToPoint::set_min_speed(float value) {
  _internal_set_min_speed(value);
  // @@protoc_insertion_point(field_set:protos.Body_TackleToPoint.min_speed)
}
inline float Body_TackleToPoint::_internal_min_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_speed_;
}
inline void Body_TackleToPoint::_internal_set_min_speed(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_speed_ = value;
}

// -------------------------------------------------------------------

// Body_TurnToAngle

// float angle = 1;
inline void Body_TurnToAngle::clear_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_ = 0;
}
inline float Body_TurnToAngle::angle() const {
  // @@protoc_insertion_point(field_get:protos.Body_TurnToAngle.angle)
  return _internal_angle();
}
inline void Body_TurnToAngle::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:protos.Body_TurnToAngle.angle)
}
inline float Body_TurnToAngle::_internal_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angle_;
}
inline void Body_TurnToAngle::_internal_set_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// Body_TurnToBall

// int32 cycle = 1;
inline void Body_TurnToBall::clear_cycle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cycle_ = 0;
}
inline ::int32_t Body_TurnToBall::cycle() const {
  // @@protoc_insertion_point(field_get:protos.Body_TurnToBall.cycle)
  return _internal_cycle();
}
inline void Body_TurnToBall::set_cycle(::int32_t value) {
  _internal_set_cycle(value);
  // @@protoc_insertion_point(field_set:protos.Body_TurnToBall.cycle)
}
inline ::int32_t Body_TurnToBall::_internal_cycle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cycle_;
}
inline void Body_TurnToBall::_internal_set_cycle(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cycle_ = value;
}

// -------------------------------------------------------------------

// Body_TurnToPoint

// .protos.Vector2D target_point = 1;
inline bool Body_TurnToPoint::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Body_TurnToPoint::clear_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Body_TurnToPoint::_internal_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Body_TurnToPoint::target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Body_TurnToPoint.target_point)
  return _internal_target_point();
}
inline void Body_TurnToPoint::unsafe_arena_set_allocated_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Body_TurnToPoint.target_point)
}
inline ::protos::Vector2D* Body_TurnToPoint::release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Body_TurnToPoint::unsafe_arena_release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Body_TurnToPoint.target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Body_TurnToPoint::_internal_mutable_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Body_TurnToPoint::mutable_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Body_TurnToPoint.target_point)
  return _msg;
}
inline void Body_TurnToPoint::set_allocated_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Body_TurnToPoint.target_point)
}

// int32 cycle = 2;
inline void Body_TurnToPoint::clear_cycle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cycle_ = 0;
}
inline ::int32_t Body_TurnToPoint::cycle() const {
  // @@protoc_insertion_point(field_get:protos.Body_TurnToPoint.cycle)
  return _internal_cycle();
}
inline void Body_TurnToPoint::set_cycle(::int32_t value) {
  _internal_set_cycle(value);
  // @@protoc_insertion_point(field_set:protos.Body_TurnToPoint.cycle)
}
inline ::int32_t Body_TurnToPoint::_internal_cycle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cycle_;
}
inline void Body_TurnToPoint::_internal_set_cycle(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cycle_ = value;
}

// -------------------------------------------------------------------

// Focus_MoveToPoint

// .protos.Vector2D target_point = 1;
inline bool Focus_MoveToPoint::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Focus_MoveToPoint::clear_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Focus_MoveToPoint::_internal_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Focus_MoveToPoint::target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Focus_MoveToPoint.target_point)
  return _internal_target_point();
}
inline void Focus_MoveToPoint::unsafe_arena_set_allocated_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Focus_MoveToPoint.target_point)
}
inline ::protos::Vector2D* Focus_MoveToPoint::release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Focus_MoveToPoint::unsafe_arena_release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Focus_MoveToPoint.target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Focus_MoveToPoint::_internal_mutable_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Focus_MoveToPoint::mutable_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Focus_MoveToPoint.target_point)
  return _msg;
}
inline void Focus_MoveToPoint::set_allocated_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Focus_MoveToPoint.target_point)
}

// -------------------------------------------------------------------

// Focus_Reset

// -------------------------------------------------------------------

// Neck_ScanField

// -------------------------------------------------------------------

// Neck_ScanPlayers

// -------------------------------------------------------------------

// Neck_TurnToBallAndPlayer

// .protos.Side side = 1;
inline void Neck_TurnToBallAndPlayer::clear_side() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_ = 0;
}
inline ::protos::Side Neck_TurnToBallAndPlayer::side() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToBallAndPlayer.side)
  return _internal_side();
}
inline void Neck_TurnToBallAndPlayer::set_side(::protos::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToBallAndPlayer.side)
}
inline ::protos::Side Neck_TurnToBallAndPlayer::_internal_side() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void Neck_TurnToBallAndPlayer::_internal_set_side(::protos::Side value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.side_ = value;
}

// int32 uniform_number = 2;
inline void Neck_TurnToBallAndPlayer::clear_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_ = 0;
}
inline ::int32_t Neck_TurnToBallAndPlayer::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToBallAndPlayer.uniform_number)
  return _internal_uniform_number();
}
inline void Neck_TurnToBallAndPlayer::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToBallAndPlayer.uniform_number)
}
inline ::int32_t Neck_TurnToBallAndPlayer::_internal_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_;
}
inline void Neck_TurnToBallAndPlayer::_internal_set_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_ = value;
}

// int32 count_threshold = 3;
inline void Neck_TurnToBallAndPlayer::clear_count_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_threshold_ = 0;
}
inline ::int32_t Neck_TurnToBallAndPlayer::count_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToBallAndPlayer.count_threshold)
  return _internal_count_threshold();
}
inline void Neck_TurnToBallAndPlayer::set_count_threshold(::int32_t value) {
  _internal_set_count_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToBallAndPlayer.count_threshold)
}
inline ::int32_t Neck_TurnToBallAndPlayer::_internal_count_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_threshold_;
}
inline void Neck_TurnToBallAndPlayer::_internal_set_count_threshold(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.count_threshold_ = value;
}

// -------------------------------------------------------------------

// Neck_TurnToBallOrScan

// int32 count_threshold = 1;
inline void Neck_TurnToBallOrScan::clear_count_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_threshold_ = 0;
}
inline ::int32_t Neck_TurnToBallOrScan::count_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToBallOrScan.count_threshold)
  return _internal_count_threshold();
}
inline void Neck_TurnToBallOrScan::set_count_threshold(::int32_t value) {
  _internal_set_count_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToBallOrScan.count_threshold)
}
inline ::int32_t Neck_TurnToBallOrScan::_internal_count_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_threshold_;
}
inline void Neck_TurnToBallOrScan::_internal_set_count_threshold(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.count_threshold_ = value;
}

// -------------------------------------------------------------------

// Neck_TurnToBall

// -------------------------------------------------------------------

// Neck_TurnToGoalieOrScan

// int32 count_threshold = 1;
inline void Neck_TurnToGoalieOrScan::clear_count_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_threshold_ = 0;
}
inline ::int32_t Neck_TurnToGoalieOrScan::count_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToGoalieOrScan.count_threshold)
  return _internal_count_threshold();
}
inline void Neck_TurnToGoalieOrScan::set_count_threshold(::int32_t value) {
  _internal_set_count_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToGoalieOrScan.count_threshold)
}
inline ::int32_t Neck_TurnToGoalieOrScan::_internal_count_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_threshold_;
}
inline void Neck_TurnToGoalieOrScan::_internal_set_count_threshold(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.count_threshold_ = value;
}

// -------------------------------------------------------------------

// Neck_TurnToLowConfTeammate

// -------------------------------------------------------------------

// Neck_TurnToPlayerOrScan

// .protos.Side side = 1;
inline void Neck_TurnToPlayerOrScan::clear_side() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_ = 0;
}
inline ::protos::Side Neck_TurnToPlayerOrScan::side() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToPlayerOrScan.side)
  return _internal_side();
}
inline void Neck_TurnToPlayerOrScan::set_side(::protos::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToPlayerOrScan.side)
}
inline ::protos::Side Neck_TurnToPlayerOrScan::_internal_side() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void Neck_TurnToPlayerOrScan::_internal_set_side(::protos::Side value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.side_ = value;
}

// int32 uniform_number = 2;
inline void Neck_TurnToPlayerOrScan::clear_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_ = 0;
}
inline ::int32_t Neck_TurnToPlayerOrScan::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToPlayerOrScan.uniform_number)
  return _internal_uniform_number();
}
inline void Neck_TurnToPlayerOrScan::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToPlayerOrScan.uniform_number)
}
inline ::int32_t Neck_TurnToPlayerOrScan::_internal_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_;
}
inline void Neck_TurnToPlayerOrScan::_internal_set_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_ = value;
}

// int32 count_threshold = 3;
inline void Neck_TurnToPlayerOrScan::clear_count_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_threshold_ = 0;
}
inline ::int32_t Neck_TurnToPlayerOrScan::count_threshold() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToPlayerOrScan.count_threshold)
  return _internal_count_threshold();
}
inline void Neck_TurnToPlayerOrScan::set_count_threshold(::int32_t value) {
  _internal_set_count_threshold(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToPlayerOrScan.count_threshold)
}
inline ::int32_t Neck_TurnToPlayerOrScan::_internal_count_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_threshold_;
}
inline void Neck_TurnToPlayerOrScan::_internal_set_count_threshold(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.count_threshold_ = value;
}

// -------------------------------------------------------------------

// Neck_TurnToPoint

// .protos.Vector2D target_point = 1;
inline bool Neck_TurnToPoint::has_target_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_point_ != nullptr);
  return value;
}
inline void Neck_TurnToPoint::clear_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_point_ != nullptr) _impl_.target_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& Neck_TurnToPoint::_internal_target_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.target_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& Neck_TurnToPoint::target_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToPoint.target_point)
  return _internal_target_point();
}
inline void Neck_TurnToPoint::unsafe_arena_set_allocated_target_point(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_point_);
  }
  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.Neck_TurnToPoint.target_point)
}
inline ::protos::Vector2D* Neck_TurnToPoint::release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* Neck_TurnToPoint::unsafe_arena_release_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.Neck_TurnToPoint.target_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.target_point_;
  _impl_.target_point_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* Neck_TurnToPoint::_internal_mutable_target_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.target_point_;
}
inline ::protos::Vector2D* Neck_TurnToPoint::mutable_target_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_target_point();
  // @@protoc_insertion_point(field_mutable:protos.Neck_TurnToPoint.target_point)
  return _msg;
}
inline void Neck_TurnToPoint::set_allocated_target_point(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.target_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_point_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.Neck_TurnToPoint.target_point)
}

// -------------------------------------------------------------------

// Neck_TurnToRelative

// float angle = 1;
inline void Neck_TurnToRelative::clear_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_ = 0;
}
inline float Neck_TurnToRelative::angle() const {
  // @@protoc_insertion_point(field_get:protos.Neck_TurnToRelative.angle)
  return _internal_angle();
}
inline void Neck_TurnToRelative::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:protos.Neck_TurnToRelative.angle)
}
inline float Neck_TurnToRelative::_internal_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angle_;
}
inline void Neck_TurnToRelative::_internal_set_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// View_ChangeWidth

// .protos.ViewWidth view_width = 1;
inline void View_ChangeWidth::clear_view_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.view_width_ = 0;
}
inline ::protos::ViewWidth View_ChangeWidth::view_width() const {
  // @@protoc_insertion_point(field_get:protos.View_ChangeWidth.view_width)
  return _internal_view_width();
}
inline void View_ChangeWidth::set_view_width(::protos::ViewWidth value) {
  _internal_set_view_width(value);
  // @@protoc_insertion_point(field_set:protos.View_ChangeWidth.view_width)
}
inline ::protos::ViewWidth View_ChangeWidth::_internal_view_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::ViewWidth>(_impl_.view_width_);
}
inline void View_ChangeWidth::_internal_set_view_width(::protos::ViewWidth value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.view_width_ = value;
}

// -------------------------------------------------------------------

// View_Normal

// -------------------------------------------------------------------

// View_Synch

// -------------------------------------------------------------------

// View_Wide

// -------------------------------------------------------------------

// HeliosGoalie

// -------------------------------------------------------------------

// HeliosGoalieMove

// -------------------------------------------------------------------

// HeliosGoalieKick

// -------------------------------------------------------------------

// HeliosShoot

// -------------------------------------------------------------------

// HeliosChainAction

// bool direct_pass = 1;
inline void HeliosChainAction::clear_direct_pass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.direct_pass_ = false;
}
inline bool HeliosChainAction::direct_pass() const {
  // @@protoc_insertion_point(field_get:protos.HeliosChainAction.direct_pass)
  return _internal_direct_pass();
}
inline void HeliosChainAction::set_direct_pass(bool value) {
  _internal_set_direct_pass(value);
  // @@protoc_insertion_point(field_set:protos.HeliosChainAction.direct_pass)
}
inline bool HeliosChainAction::_internal_direct_pass() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.direct_pass_;
}
inline void HeliosChainAction::_internal_set_direct_pass(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.direct_pass_ = value;
}

// bool lead_pass = 2;
inline void HeliosChainAction::clear_lead_pass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lead_pass_ = false;
}
inline bool HeliosChainAction::lead_pass() const {
  // @@protoc_insertion_point(field_get:protos.HeliosChainAction.lead_pass)
  return _internal_lead_pass();
}
inline void HeliosChainAction::set_lead_pass(bool value) {
  _internal_set_lead_pass(value);
  // @@protoc_insertion_point(field_set:protos.HeliosChainAction.lead_pass)
}
inline bool HeliosChainAction::_internal_lead_pass() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lead_pass_;
}
inline void HeliosChainAction::_internal_set_lead_pass(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lead_pass_ = value;
}

// bool through_pass = 3;
inline void HeliosChainAction::clear_through_pass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.through_pass_ = false;
}
inline bool HeliosChainAction::through_pass() const {
  // @@protoc_insertion_point(field_get:protos.HeliosChainAction.through_pass)
  return _internal_through_pass();
}
inline void HeliosChainAction::set_through_pass(bool value) {
  _internal_set_through_pass(value);
  // @@protoc_insertion_point(field_set:protos.HeliosChainAction.through_pass)
}
inline bool HeliosChainAction::_internal_through_pass() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.through_pass_;
}
inline void HeliosChainAction::_internal_set_through_pass(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.through_pass_ = value;
}

// bool short_dribble = 4;
inline void HeliosChainAction::clear_short_dribble() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.short_dribble_ = false;
}
inline bool HeliosChainAction::short_dribble() const {
  // @@protoc_insertion_point(field_get:protos.HeliosChainAction.short_dribble)
  return _internal_short_dribble();
}
inline void HeliosChainAction::set_short_dribble(bool value) {
  _internal_set_short_dribble(value);
  // @@protoc_insertion_point(field_set:protos.HeliosChainAction.short_dribble)
}
inline bool HeliosChainAction::_internal_short_dribble() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.short_dribble_;
}
inline void HeliosChainAction::_internal_set_short_dribble(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.short_dribble_ = value;
}

// bool long_dribble = 5;
inline void HeliosChainAction::clear_long_dribble() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.long_dribble_ = false;
}
inline bool HeliosChainAction::long_dribble() const {
  // @@protoc_insertion_point(field_get:protos.HeliosChainAction.long_dribble)
  return _internal_long_dribble();
}
inline void HeliosChainAction::set_long_dribble(bool value) {
  _internal_set_long_dribble(value);
  // @@protoc_insertion_point(field_set:protos.HeliosChainAction.long_dribble)
}
inline bool HeliosChainAction::_internal_long_dribble() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.long_dribble_;
}
inline void HeliosChainAction::_internal_set_long_dribble(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.long_dribble_ = value;
}

// bool cross = 6;
inline void HeliosChainAction::clear_cross() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cross_ = false;
}
inline bool HeliosChainAction::cross() const {
  // @@protoc_insertion_point(field_get:protos.HeliosChainAction.cross)
  return _internal_cross();
}
inline void HeliosChainAction::set_cross(bool value) {
  _internal_set_cross(value);
  // @@protoc_insertion_point(field_set:protos.HeliosChainAction.cross)
}
inline bool HeliosChainAction::_internal_cross() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cross_;
}
inline void HeliosChainAction::_internal_set_cross(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cross_ = value;
}

// bool simple_pass = 7;
inline void HeliosChainAction::clear_simple_pass() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.simple_pass_ = false;
}
inline bool HeliosChainAction::simple_pass() const {
  // @@protoc_insertion_point(field_get:protos.HeliosChainAction.simple_pass)
  return _internal_simple_pass();
}
inline void HeliosChainAction::set_simple_pass(bool value) {
  _internal_set_simple_pass(value);
  // @@protoc_insertion_point(field_set:protos.HeliosChainAction.simple_pass)
}
inline bool HeliosChainAction::_internal_simple_pass() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.simple_pass_;
}
inline void HeliosChainAction::_internal_set_simple_pass(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.simple_pass_ = value;
}

// bool simple_dribble = 8;
inline void HeliosChainAction::clear_simple_dribble() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.simple_dribble_ = false;
}
inline bool HeliosChainAction::simple_dribble() const {
  // @@protoc_insertion_point(field_get:protos.HeliosChainAction.simple_dribble)
  return _internal_simple_dribble();
}
inline void HeliosChainAction::set_simple_dribble(bool value) {
  _internal_set_simple_dribble(value);
  // @@protoc_insertion_point(field_set:protos.HeliosChainAction.simple_dribble)
}
inline bool HeliosChainAction::_internal_simple_dribble() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.simple_dribble_;
}
inline void HeliosChainAction::_internal_set_simple_dribble(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.simple_dribble_ = value;
}

// bool simple_shoot = 9;
inline void HeliosChainAction::clear_simple_shoot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.simple_shoot_ = false;
}
inline bool HeliosChainAction::simple_shoot() const {
  // @@protoc_insertion_point(field_get:protos.HeliosChainAction.simple_shoot)
  return _internal_simple_shoot();
}
inline void HeliosChainAction::set_simple_shoot(bool value) {
  _internal_set_simple_shoot(value);
  // @@protoc_insertion_point(field_set:protos.HeliosChainAction.simple_shoot)
}
inline bool HeliosChainAction::_internal_simple_shoot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.simple_shoot_;
}
inline void HeliosChainAction::_internal_set_simple_shoot(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.simple_shoot_ = value;
}

// -------------------------------------------------------------------

// HeliosBasicOffensive

// -------------------------------------------------------------------

// HeliosBasicMove

// -------------------------------------------------------------------

// HeliosSetPlay

// -------------------------------------------------------------------

// HeliosPenalty

// -------------------------------------------------------------------

// HeliosCommunicaion

// -------------------------------------------------------------------

// PlayerAction

// .protos.Dash dash = 1;
inline bool PlayerAction::has_dash() const {
  return action_case() == kDash;
}
inline bool PlayerAction::_internal_has_dash() const {
  return action_case() == kDash;
}
inline void PlayerAction::set_has_dash() {
  _impl_._oneof_case_[0] = kDash;
}
inline void PlayerAction::clear_dash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kDash) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.dash_;
    }
    clear_has_action();
  }
}
inline ::protos::Dash* PlayerAction::release_dash() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.dash)
  if (action_case() == kDash) {
    clear_has_action();
    auto* temp = _impl_.action_.dash_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.dash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Dash& PlayerAction::_internal_dash() const {
  return action_case() == kDash ? *_impl_.action_.dash_ : reinterpret_cast<::protos::Dash&>(::protos::_Dash_default_instance_);
}
inline const ::protos::Dash& PlayerAction::dash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.dash)
  return _internal_dash();
}
inline ::protos::Dash* PlayerAction::unsafe_arena_release_dash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.dash)
  if (action_case() == kDash) {
    clear_has_action();
    auto* temp = _impl_.action_.dash_;
    _impl_.action_.dash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_dash(::protos::Dash* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_dash();
    _impl_.action_.dash_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.dash)
}
inline ::protos::Dash* PlayerAction::_internal_mutable_dash() {
  if (action_case() != kDash) {
    clear_action();
    set_has_dash();
    _impl_.action_.dash_ = CreateMaybeMessage<::protos::Dash>(GetArena());
  }
  return _impl_.action_.dash_;
}
inline ::protos::Dash* PlayerAction::mutable_dash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Dash* _msg = _internal_mutable_dash();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.dash)
  return _msg;
}

// .protos.Turn turn = 2;
inline bool PlayerAction::has_turn() const {
  return action_case() == kTurn;
}
inline bool PlayerAction::_internal_has_turn() const {
  return action_case() == kTurn;
}
inline void PlayerAction::set_has_turn() {
  _impl_._oneof_case_[0] = kTurn;
}
inline void PlayerAction::clear_turn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kTurn) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.turn_;
    }
    clear_has_action();
  }
}
inline ::protos::Turn* PlayerAction::release_turn() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.turn)
  if (action_case() == kTurn) {
    clear_has_action();
    auto* temp = _impl_.action_.turn_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.turn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Turn& PlayerAction::_internal_turn() const {
  return action_case() == kTurn ? *_impl_.action_.turn_ : reinterpret_cast<::protos::Turn&>(::protos::_Turn_default_instance_);
}
inline const ::protos::Turn& PlayerAction::turn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.turn)
  return _internal_turn();
}
inline ::protos::Turn* PlayerAction::unsafe_arena_release_turn() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.turn)
  if (action_case() == kTurn) {
    clear_has_action();
    auto* temp = _impl_.action_.turn_;
    _impl_.action_.turn_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_turn(::protos::Turn* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_turn();
    _impl_.action_.turn_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.turn)
}
inline ::protos::Turn* PlayerAction::_internal_mutable_turn() {
  if (action_case() != kTurn) {
    clear_action();
    set_has_turn();
    _impl_.action_.turn_ = CreateMaybeMessage<::protos::Turn>(GetArena());
  }
  return _impl_.action_.turn_;
}
inline ::protos::Turn* PlayerAction::mutable_turn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Turn* _msg = _internal_mutable_turn();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.turn)
  return _msg;
}

// .protos.Kick kick = 3;
inline bool PlayerAction::has_kick() const {
  return action_case() == kKick;
}
inline bool PlayerAction::_internal_has_kick() const {
  return action_case() == kKick;
}
inline void PlayerAction::set_has_kick() {
  _impl_._oneof_case_[0] = kKick;
}
inline void PlayerAction::clear_kick() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kKick) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.kick_;
    }
    clear_has_action();
  }
}
inline ::protos::Kick* PlayerAction::release_kick() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.kick)
  if (action_case() == kKick) {
    clear_has_action();
    auto* temp = _impl_.action_.kick_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.kick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Kick& PlayerAction::_internal_kick() const {
  return action_case() == kKick ? *_impl_.action_.kick_ : reinterpret_cast<::protos::Kick&>(::protos::_Kick_default_instance_);
}
inline const ::protos::Kick& PlayerAction::kick() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.kick)
  return _internal_kick();
}
inline ::protos::Kick* PlayerAction::unsafe_arena_release_kick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.kick)
  if (action_case() == kKick) {
    clear_has_action();
    auto* temp = _impl_.action_.kick_;
    _impl_.action_.kick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_kick(::protos::Kick* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_kick();
    _impl_.action_.kick_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.kick)
}
inline ::protos::Kick* PlayerAction::_internal_mutable_kick() {
  if (action_case() != kKick) {
    clear_action();
    set_has_kick();
    _impl_.action_.kick_ = CreateMaybeMessage<::protos::Kick>(GetArena());
  }
  return _impl_.action_.kick_;
}
inline ::protos::Kick* PlayerAction::mutable_kick() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Kick* _msg = _internal_mutable_kick();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.kick)
  return _msg;
}

// .protos.Tackle tackle = 4;
inline bool PlayerAction::has_tackle() const {
  return action_case() == kTackle;
}
inline bool PlayerAction::_internal_has_tackle() const {
  return action_case() == kTackle;
}
inline void PlayerAction::set_has_tackle() {
  _impl_._oneof_case_[0] = kTackle;
}
inline void PlayerAction::clear_tackle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kTackle) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.tackle_;
    }
    clear_has_action();
  }
}
inline ::protos::Tackle* PlayerAction::release_tackle() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.tackle)
  if (action_case() == kTackle) {
    clear_has_action();
    auto* temp = _impl_.action_.tackle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.tackle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Tackle& PlayerAction::_internal_tackle() const {
  return action_case() == kTackle ? *_impl_.action_.tackle_ : reinterpret_cast<::protos::Tackle&>(::protos::_Tackle_default_instance_);
}
inline const ::protos::Tackle& PlayerAction::tackle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.tackle)
  return _internal_tackle();
}
inline ::protos::Tackle* PlayerAction::unsafe_arena_release_tackle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.tackle)
  if (action_case() == kTackle) {
    clear_has_action();
    auto* temp = _impl_.action_.tackle_;
    _impl_.action_.tackle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_tackle(::protos::Tackle* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_tackle();
    _impl_.action_.tackle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.tackle)
}
inline ::protos::Tackle* PlayerAction::_internal_mutable_tackle() {
  if (action_case() != kTackle) {
    clear_action();
    set_has_tackle();
    _impl_.action_.tackle_ = CreateMaybeMessage<::protos::Tackle>(GetArena());
  }
  return _impl_.action_.tackle_;
}
inline ::protos::Tackle* PlayerAction::mutable_tackle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Tackle* _msg = _internal_mutable_tackle();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.tackle)
  return _msg;
}

// .protos.Catch catch = 5;
inline bool PlayerAction::has_catch_() const {
  return action_case() == kCatch;
}
inline bool PlayerAction::_internal_has_catch_() const {
  return action_case() == kCatch;
}
inline void PlayerAction::set_has_catch_() {
  _impl_._oneof_case_[0] = kCatch;
}
inline void PlayerAction::clear_catch_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kCatch) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.catch__;
    }
    clear_has_action();
  }
}
inline ::protos::Catch* PlayerAction::release_catch_() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.catch)
  if (action_case() == kCatch) {
    clear_has_action();
    auto* temp = _impl_.action_.catch__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.catch__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Catch& PlayerAction::_internal_catch_() const {
  return action_case() == kCatch ? *_impl_.action_.catch__ : reinterpret_cast<::protos::Catch&>(::protos::_Catch_default_instance_);
}
inline const ::protos::Catch& PlayerAction::catch_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.catch)
  return _internal_catch_();
}
inline ::protos::Catch* PlayerAction::unsafe_arena_release_catch_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.catch)
  if (action_case() == kCatch) {
    clear_has_action();
    auto* temp = _impl_.action_.catch__;
    _impl_.action_.catch__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_catch_(::protos::Catch* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_catch_();
    _impl_.action_.catch__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.catch)
}
inline ::protos::Catch* PlayerAction::_internal_mutable_catch_() {
  if (action_case() != kCatch) {
    clear_action();
    set_has_catch_();
    _impl_.action_.catch__ = CreateMaybeMessage<::protos::Catch>(GetArena());
  }
  return _impl_.action_.catch__;
}
inline ::protos::Catch* PlayerAction::mutable_catch_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Catch* _msg = _internal_mutable_catch_();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.catch)
  return _msg;
}

// .protos.Move move = 6;
inline bool PlayerAction::has_move() const {
  return action_case() == kMove;
}
inline bool PlayerAction::_internal_has_move() const {
  return action_case() == kMove;
}
inline void PlayerAction::set_has_move() {
  _impl_._oneof_case_[0] = kMove;
}
inline void PlayerAction::clear_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kMove) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.move_;
    }
    clear_has_action();
  }
}
inline ::protos::Move* PlayerAction::release_move() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.move)
  if (action_case() == kMove) {
    clear_has_action();
    auto* temp = _impl_.action_.move_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Move& PlayerAction::_internal_move() const {
  return action_case() == kMove ? *_impl_.action_.move_ : reinterpret_cast<::protos::Move&>(::protos::_Move_default_instance_);
}
inline const ::protos::Move& PlayerAction::move() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.move)
  return _internal_move();
}
inline ::protos::Move* PlayerAction::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.move)
  if (action_case() == kMove) {
    clear_has_action();
    auto* temp = _impl_.action_.move_;
    _impl_.action_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_move(::protos::Move* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_move();
    _impl_.action_.move_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.move)
}
inline ::protos::Move* PlayerAction::_internal_mutable_move() {
  if (action_case() != kMove) {
    clear_action();
    set_has_move();
    _impl_.action_.move_ = CreateMaybeMessage<::protos::Move>(GetArena());
  }
  return _impl_.action_.move_;
}
inline ::protos::Move* PlayerAction::mutable_move() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Move* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.move)
  return _msg;
}

// .protos.TurnNeck turn_neck = 7;
inline bool PlayerAction::has_turn_neck() const {
  return action_case() == kTurnNeck;
}
inline bool PlayerAction::_internal_has_turn_neck() const {
  return action_case() == kTurnNeck;
}
inline void PlayerAction::set_has_turn_neck() {
  _impl_._oneof_case_[0] = kTurnNeck;
}
inline void PlayerAction::clear_turn_neck() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kTurnNeck) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.turn_neck_;
    }
    clear_has_action();
  }
}
inline ::protos::TurnNeck* PlayerAction::release_turn_neck() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.turn_neck)
  if (action_case() == kTurnNeck) {
    clear_has_action();
    auto* temp = _impl_.action_.turn_neck_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.turn_neck_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::TurnNeck& PlayerAction::_internal_turn_neck() const {
  return action_case() == kTurnNeck ? *_impl_.action_.turn_neck_ : reinterpret_cast<::protos::TurnNeck&>(::protos::_TurnNeck_default_instance_);
}
inline const ::protos::TurnNeck& PlayerAction::turn_neck() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.turn_neck)
  return _internal_turn_neck();
}
inline ::protos::TurnNeck* PlayerAction::unsafe_arena_release_turn_neck() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.turn_neck)
  if (action_case() == kTurnNeck) {
    clear_has_action();
    auto* temp = _impl_.action_.turn_neck_;
    _impl_.action_.turn_neck_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_turn_neck(::protos::TurnNeck* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_turn_neck();
    _impl_.action_.turn_neck_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.turn_neck)
}
inline ::protos::TurnNeck* PlayerAction::_internal_mutable_turn_neck() {
  if (action_case() != kTurnNeck) {
    clear_action();
    set_has_turn_neck();
    _impl_.action_.turn_neck_ = CreateMaybeMessage<::protos::TurnNeck>(GetArena());
  }
  return _impl_.action_.turn_neck_;
}
inline ::protos::TurnNeck* PlayerAction::mutable_turn_neck() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::TurnNeck* _msg = _internal_mutable_turn_neck();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.turn_neck)
  return _msg;
}

// .protos.ChangeView change_view = 8;
inline bool PlayerAction::has_change_view() const {
  return action_case() == kChangeView;
}
inline bool PlayerAction::_internal_has_change_view() const {
  return action_case() == kChangeView;
}
inline void PlayerAction::set_has_change_view() {
  _impl_._oneof_case_[0] = kChangeView;
}
inline void PlayerAction::clear_change_view() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kChangeView) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.change_view_;
    }
    clear_has_action();
  }
}
inline ::protos::ChangeView* PlayerAction::release_change_view() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.change_view)
  if (action_case() == kChangeView) {
    clear_has_action();
    auto* temp = _impl_.action_.change_view_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.change_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::ChangeView& PlayerAction::_internal_change_view() const {
  return action_case() == kChangeView ? *_impl_.action_.change_view_ : reinterpret_cast<::protos::ChangeView&>(::protos::_ChangeView_default_instance_);
}
inline const ::protos::ChangeView& PlayerAction::change_view() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.change_view)
  return _internal_change_view();
}
inline ::protos::ChangeView* PlayerAction::unsafe_arena_release_change_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.change_view)
  if (action_case() == kChangeView) {
    clear_has_action();
    auto* temp = _impl_.action_.change_view_;
    _impl_.action_.change_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_change_view(::protos::ChangeView* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_change_view();
    _impl_.action_.change_view_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.change_view)
}
inline ::protos::ChangeView* PlayerAction::_internal_mutable_change_view() {
  if (action_case() != kChangeView) {
    clear_action();
    set_has_change_view();
    _impl_.action_.change_view_ = CreateMaybeMessage<::protos::ChangeView>(GetArena());
  }
  return _impl_.action_.change_view_;
}
inline ::protos::ChangeView* PlayerAction::mutable_change_view() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::ChangeView* _msg = _internal_mutable_change_view();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.change_view)
  return _msg;
}

// .protos.Say say = 9;
inline bool PlayerAction::has_say() const {
  return action_case() == kSay;
}
inline bool PlayerAction::_internal_has_say() const {
  return action_case() == kSay;
}
inline void PlayerAction::set_has_say() {
  _impl_._oneof_case_[0] = kSay;
}
inline void PlayerAction::clear_say() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kSay) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.say_;
    }
    clear_has_action();
  }
}
inline ::protos::Say* PlayerAction::release_say() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.say)
  if (action_case() == kSay) {
    clear_has_action();
    auto* temp = _impl_.action_.say_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.say_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Say& PlayerAction::_internal_say() const {
  return action_case() == kSay ? *_impl_.action_.say_ : reinterpret_cast<::protos::Say&>(::protos::_Say_default_instance_);
}
inline const ::protos::Say& PlayerAction::say() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.say)
  return _internal_say();
}
inline ::protos::Say* PlayerAction::unsafe_arena_release_say() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.say)
  if (action_case() == kSay) {
    clear_has_action();
    auto* temp = _impl_.action_.say_;
    _impl_.action_.say_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_say(::protos::Say* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_say();
    _impl_.action_.say_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.say)
}
inline ::protos::Say* PlayerAction::_internal_mutable_say() {
  if (action_case() != kSay) {
    clear_action();
    set_has_say();
    _impl_.action_.say_ = CreateMaybeMessage<::protos::Say>(GetArena());
  }
  return _impl_.action_.say_;
}
inline ::protos::Say* PlayerAction::mutable_say() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Say* _msg = _internal_mutable_say();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.say)
  return _msg;
}

// .protos.PointTo point_to = 10;
inline bool PlayerAction::has_point_to() const {
  return action_case() == kPointTo;
}
inline bool PlayerAction::_internal_has_point_to() const {
  return action_case() == kPointTo;
}
inline void PlayerAction::set_has_point_to() {
  _impl_._oneof_case_[0] = kPointTo;
}
inline void PlayerAction::clear_point_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kPointTo) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.point_to_;
    }
    clear_has_action();
  }
}
inline ::protos::PointTo* PlayerAction::release_point_to() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.point_to)
  if (action_case() == kPointTo) {
    clear_has_action();
    auto* temp = _impl_.action_.point_to_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.point_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::PointTo& PlayerAction::_internal_point_to() const {
  return action_case() == kPointTo ? *_impl_.action_.point_to_ : reinterpret_cast<::protos::PointTo&>(::protos::_PointTo_default_instance_);
}
inline const ::protos::PointTo& PlayerAction::point_to() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.point_to)
  return _internal_point_to();
}
inline ::protos::PointTo* PlayerAction::unsafe_arena_release_point_to() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.point_to)
  if (action_case() == kPointTo) {
    clear_has_action();
    auto* temp = _impl_.action_.point_to_;
    _impl_.action_.point_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_point_to(::protos::PointTo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_point_to();
    _impl_.action_.point_to_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.point_to)
}
inline ::protos::PointTo* PlayerAction::_internal_mutable_point_to() {
  if (action_case() != kPointTo) {
    clear_action();
    set_has_point_to();
    _impl_.action_.point_to_ = CreateMaybeMessage<::protos::PointTo>(GetArena());
  }
  return _impl_.action_.point_to_;
}
inline ::protos::PointTo* PlayerAction::mutable_point_to() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::PointTo* _msg = _internal_mutable_point_to();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.point_to)
  return _msg;
}

// .protos.PointToOf point_to_of = 11;
inline bool PlayerAction::has_point_to_of() const {
  return action_case() == kPointToOf;
}
inline bool PlayerAction::_internal_has_point_to_of() const {
  return action_case() == kPointToOf;
}
inline void PlayerAction::set_has_point_to_of() {
  _impl_._oneof_case_[0] = kPointToOf;
}
inline void PlayerAction::clear_point_to_of() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kPointToOf) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.point_to_of_;
    }
    clear_has_action();
  }
}
inline ::protos::PointToOf* PlayerAction::release_point_to_of() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.point_to_of)
  if (action_case() == kPointToOf) {
    clear_has_action();
    auto* temp = _impl_.action_.point_to_of_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.point_to_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::PointToOf& PlayerAction::_internal_point_to_of() const {
  return action_case() == kPointToOf ? *_impl_.action_.point_to_of_ : reinterpret_cast<::protos::PointToOf&>(::protos::_PointToOf_default_instance_);
}
inline const ::protos::PointToOf& PlayerAction::point_to_of() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.point_to_of)
  return _internal_point_to_of();
}
inline ::protos::PointToOf* PlayerAction::unsafe_arena_release_point_to_of() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.point_to_of)
  if (action_case() == kPointToOf) {
    clear_has_action();
    auto* temp = _impl_.action_.point_to_of_;
    _impl_.action_.point_to_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_point_to_of(::protos::PointToOf* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_point_to_of();
    _impl_.action_.point_to_of_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.point_to_of)
}
inline ::protos::PointToOf* PlayerAction::_internal_mutable_point_to_of() {
  if (action_case() != kPointToOf) {
    clear_action();
    set_has_point_to_of();
    _impl_.action_.point_to_of_ = CreateMaybeMessage<::protos::PointToOf>(GetArena());
  }
  return _impl_.action_.point_to_of_;
}
inline ::protos::PointToOf* PlayerAction::mutable_point_to_of() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::PointToOf* _msg = _internal_mutable_point_to_of();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.point_to_of)
  return _msg;
}

// .protos.AttentionTo attention_to = 12;
inline bool PlayerAction::has_attention_to() const {
  return action_case() == kAttentionTo;
}
inline bool PlayerAction::_internal_has_attention_to() const {
  return action_case() == kAttentionTo;
}
inline void PlayerAction::set_has_attention_to() {
  _impl_._oneof_case_[0] = kAttentionTo;
}
inline void PlayerAction::clear_attention_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kAttentionTo) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.attention_to_;
    }
    clear_has_action();
  }
}
inline ::protos::AttentionTo* PlayerAction::release_attention_to() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.attention_to)
  if (action_case() == kAttentionTo) {
    clear_has_action();
    auto* temp = _impl_.action_.attention_to_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.attention_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AttentionTo& PlayerAction::_internal_attention_to() const {
  return action_case() == kAttentionTo ? *_impl_.action_.attention_to_ : reinterpret_cast<::protos::AttentionTo&>(::protos::_AttentionTo_default_instance_);
}
inline const ::protos::AttentionTo& PlayerAction::attention_to() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.attention_to)
  return _internal_attention_to();
}
inline ::protos::AttentionTo* PlayerAction::unsafe_arena_release_attention_to() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.attention_to)
  if (action_case() == kAttentionTo) {
    clear_has_action();
    auto* temp = _impl_.action_.attention_to_;
    _impl_.action_.attention_to_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_attention_to(::protos::AttentionTo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_attention_to();
    _impl_.action_.attention_to_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.attention_to)
}
inline ::protos::AttentionTo* PlayerAction::_internal_mutable_attention_to() {
  if (action_case() != kAttentionTo) {
    clear_action();
    set_has_attention_to();
    _impl_.action_.attention_to_ = CreateMaybeMessage<::protos::AttentionTo>(GetArena());
  }
  return _impl_.action_.attention_to_;
}
inline ::protos::AttentionTo* PlayerAction::mutable_attention_to() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::AttentionTo* _msg = _internal_mutable_attention_to();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.attention_to)
  return _msg;
}

// .protos.AttentionToOf attention_to_of = 13;
inline bool PlayerAction::has_attention_to_of() const {
  return action_case() == kAttentionToOf;
}
inline bool PlayerAction::_internal_has_attention_to_of() const {
  return action_case() == kAttentionToOf;
}
inline void PlayerAction::set_has_attention_to_of() {
  _impl_._oneof_case_[0] = kAttentionToOf;
}
inline void PlayerAction::clear_attention_to_of() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kAttentionToOf) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.attention_to_of_;
    }
    clear_has_action();
  }
}
inline ::protos::AttentionToOf* PlayerAction::release_attention_to_of() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.attention_to_of)
  if (action_case() == kAttentionToOf) {
    clear_has_action();
    auto* temp = _impl_.action_.attention_to_of_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.attention_to_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::AttentionToOf& PlayerAction::_internal_attention_to_of() const {
  return action_case() == kAttentionToOf ? *_impl_.action_.attention_to_of_ : reinterpret_cast<::protos::AttentionToOf&>(::protos::_AttentionToOf_default_instance_);
}
inline const ::protos::AttentionToOf& PlayerAction::attention_to_of() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.attention_to_of)
  return _internal_attention_to_of();
}
inline ::protos::AttentionToOf* PlayerAction::unsafe_arena_release_attention_to_of() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.attention_to_of)
  if (action_case() == kAttentionToOf) {
    clear_has_action();
    auto* temp = _impl_.action_.attention_to_of_;
    _impl_.action_.attention_to_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_attention_to_of(::protos::AttentionToOf* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_attention_to_of();
    _impl_.action_.attention_to_of_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.attention_to_of)
}
inline ::protos::AttentionToOf* PlayerAction::_internal_mutable_attention_to_of() {
  if (action_case() != kAttentionToOf) {
    clear_action();
    set_has_attention_to_of();
    _impl_.action_.attention_to_of_ = CreateMaybeMessage<::protos::AttentionToOf>(GetArena());
  }
  return _impl_.action_.attention_to_of_;
}
inline ::protos::AttentionToOf* PlayerAction::mutable_attention_to_of() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::AttentionToOf* _msg = _internal_mutable_attention_to_of();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.attention_to_of)
  return _msg;
}

// .protos.Log log = 14;
inline bool PlayerAction::has_log() const {
  return action_case() == kLog;
}
inline bool PlayerAction::_internal_has_log() const {
  return action_case() == kLog;
}
inline void PlayerAction::set_has_log() {
  _impl_._oneof_case_[0] = kLog;
}
inline void PlayerAction::clear_log() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kLog) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.log_;
    }
    clear_has_action();
  }
}
inline ::protos::Log* PlayerAction::release_log() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.log)
  if (action_case() == kLog) {
    clear_has_action();
    auto* temp = _impl_.action_.log_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Log& PlayerAction::_internal_log() const {
  return action_case() == kLog ? *_impl_.action_.log_ : reinterpret_cast<::protos::Log&>(::protos::_Log_default_instance_);
}
inline const ::protos::Log& PlayerAction::log() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.log)
  return _internal_log();
}
inline ::protos::Log* PlayerAction::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.log)
  if (action_case() == kLog) {
    clear_has_action();
    auto* temp = _impl_.action_.log_;
    _impl_.action_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_log(::protos::Log* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_log();
    _impl_.action_.log_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.log)
}
inline ::protos::Log* PlayerAction::_internal_mutable_log() {
  if (action_case() != kLog) {
    clear_action();
    set_has_log();
    _impl_.action_.log_ = CreateMaybeMessage<::protos::Log>(GetArena());
  }
  return _impl_.action_.log_;
}
inline ::protos::Log* PlayerAction::mutable_log() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Log* _msg = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.log)
  return _msg;
}

// .protos.DebugClient debug_client = 15;
inline bool PlayerAction::has_debug_client() const {
  return action_case() == kDebugClient;
}
inline bool PlayerAction::_internal_has_debug_client() const {
  return action_case() == kDebugClient;
}
inline void PlayerAction::set_has_debug_client() {
  _impl_._oneof_case_[0] = kDebugClient;
}
inline void PlayerAction::clear_debug_client() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kDebugClient) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.debug_client_;
    }
    clear_has_action();
  }
}
inline ::protos::DebugClient* PlayerAction::release_debug_client() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.debug_client)
  if (action_case() == kDebugClient) {
    clear_has_action();
    auto* temp = _impl_.action_.debug_client_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.debug_client_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DebugClient& PlayerAction::_internal_debug_client() const {
  return action_case() == kDebugClient ? *_impl_.action_.debug_client_ : reinterpret_cast<::protos::DebugClient&>(::protos::_DebugClient_default_instance_);
}
inline const ::protos::DebugClient& PlayerAction::debug_client() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.debug_client)
  return _internal_debug_client();
}
inline ::protos::DebugClient* PlayerAction::unsafe_arena_release_debug_client() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.debug_client)
  if (action_case() == kDebugClient) {
    clear_has_action();
    auto* temp = _impl_.action_.debug_client_;
    _impl_.action_.debug_client_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_debug_client(::protos::DebugClient* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_debug_client();
    _impl_.action_.debug_client_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.debug_client)
}
inline ::protos::DebugClient* PlayerAction::_internal_mutable_debug_client() {
  if (action_case() != kDebugClient) {
    clear_action();
    set_has_debug_client();
    _impl_.action_.debug_client_ = CreateMaybeMessage<::protos::DebugClient>(GetArena());
  }
  return _impl_.action_.debug_client_;
}
inline ::protos::DebugClient* PlayerAction::mutable_debug_client() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::DebugClient* _msg = _internal_mutable_debug_client();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.debug_client)
  return _msg;
}

// .protos.Body_GoToPoint body_go_to_point = 16;
inline bool PlayerAction::has_body_go_to_point() const {
  return action_case() == kBodyGoToPoint;
}
inline bool PlayerAction::_internal_has_body_go_to_point() const {
  return action_case() == kBodyGoToPoint;
}
inline void PlayerAction::set_has_body_go_to_point() {
  _impl_._oneof_case_[0] = kBodyGoToPoint;
}
inline void PlayerAction::clear_body_go_to_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyGoToPoint) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_go_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_GoToPoint* PlayerAction::release_body_go_to_point() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_go_to_point)
  if (action_case() == kBodyGoToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.body_go_to_point_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_go_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_GoToPoint& PlayerAction::_internal_body_go_to_point() const {
  return action_case() == kBodyGoToPoint ? *_impl_.action_.body_go_to_point_ : reinterpret_cast<::protos::Body_GoToPoint&>(::protos::_Body_GoToPoint_default_instance_);
}
inline const ::protos::Body_GoToPoint& PlayerAction::body_go_to_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_go_to_point)
  return _internal_body_go_to_point();
}
inline ::protos::Body_GoToPoint* PlayerAction::unsafe_arena_release_body_go_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_go_to_point)
  if (action_case() == kBodyGoToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.body_go_to_point_;
    _impl_.action_.body_go_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_go_to_point(::protos::Body_GoToPoint* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_go_to_point();
    _impl_.action_.body_go_to_point_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_go_to_point)
}
inline ::protos::Body_GoToPoint* PlayerAction::_internal_mutable_body_go_to_point() {
  if (action_case() != kBodyGoToPoint) {
    clear_action();
    set_has_body_go_to_point();
    _impl_.action_.body_go_to_point_ = CreateMaybeMessage<::protos::Body_GoToPoint>(GetArena());
  }
  return _impl_.action_.body_go_to_point_;
}
inline ::protos::Body_GoToPoint* PlayerAction::mutable_body_go_to_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_GoToPoint* _msg = _internal_mutable_body_go_to_point();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_go_to_point)
  return _msg;
}

// .protos.Body_SmartKick body_smart_kick = 17;
inline bool PlayerAction::has_body_smart_kick() const {
  return action_case() == kBodySmartKick;
}
inline bool PlayerAction::_internal_has_body_smart_kick() const {
  return action_case() == kBodySmartKick;
}
inline void PlayerAction::set_has_body_smart_kick() {
  _impl_._oneof_case_[0] = kBodySmartKick;
}
inline void PlayerAction::clear_body_smart_kick() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodySmartKick) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_smart_kick_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_SmartKick* PlayerAction::release_body_smart_kick() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_smart_kick)
  if (action_case() == kBodySmartKick) {
    clear_has_action();
    auto* temp = _impl_.action_.body_smart_kick_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_smart_kick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_SmartKick& PlayerAction::_internal_body_smart_kick() const {
  return action_case() == kBodySmartKick ? *_impl_.action_.body_smart_kick_ : reinterpret_cast<::protos::Body_SmartKick&>(::protos::_Body_SmartKick_default_instance_);
}
inline const ::protos::Body_SmartKick& PlayerAction::body_smart_kick() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_smart_kick)
  return _internal_body_smart_kick();
}
inline ::protos::Body_SmartKick* PlayerAction::unsafe_arena_release_body_smart_kick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_smart_kick)
  if (action_case() == kBodySmartKick) {
    clear_has_action();
    auto* temp = _impl_.action_.body_smart_kick_;
    _impl_.action_.body_smart_kick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_smart_kick(::protos::Body_SmartKick* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_smart_kick();
    _impl_.action_.body_smart_kick_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_smart_kick)
}
inline ::protos::Body_SmartKick* PlayerAction::_internal_mutable_body_smart_kick() {
  if (action_case() != kBodySmartKick) {
    clear_action();
    set_has_body_smart_kick();
    _impl_.action_.body_smart_kick_ = CreateMaybeMessage<::protos::Body_SmartKick>(GetArena());
  }
  return _impl_.action_.body_smart_kick_;
}
inline ::protos::Body_SmartKick* PlayerAction::mutable_body_smart_kick() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_SmartKick* _msg = _internal_mutable_body_smart_kick();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_smart_kick)
  return _msg;
}

// .protos.Bhv_BeforeKickOff bhv_before_kick_off = 18;
inline bool PlayerAction::has_bhv_before_kick_off() const {
  return action_case() == kBhvBeforeKickOff;
}
inline bool PlayerAction::_internal_has_bhv_before_kick_off() const {
  return action_case() == kBhvBeforeKickOff;
}
inline void PlayerAction::set_has_bhv_before_kick_off() {
  _impl_._oneof_case_[0] = kBhvBeforeKickOff;
}
inline void PlayerAction::clear_bhv_before_kick_off() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBhvBeforeKickOff) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.bhv_before_kick_off_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_BeforeKickOff* PlayerAction::release_bhv_before_kick_off() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.bhv_before_kick_off)
  if (action_case() == kBhvBeforeKickOff) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_before_kick_off_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_before_kick_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_BeforeKickOff& PlayerAction::_internal_bhv_before_kick_off() const {
  return action_case() == kBhvBeforeKickOff ? *_impl_.action_.bhv_before_kick_off_ : reinterpret_cast<::protos::Bhv_BeforeKickOff&>(::protos::_Bhv_BeforeKickOff_default_instance_);
}
inline const ::protos::Bhv_BeforeKickOff& PlayerAction::bhv_before_kick_off() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.bhv_before_kick_off)
  return _internal_bhv_before_kick_off();
}
inline ::protos::Bhv_BeforeKickOff* PlayerAction::unsafe_arena_release_bhv_before_kick_off() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.bhv_before_kick_off)
  if (action_case() == kBhvBeforeKickOff) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_before_kick_off_;
    _impl_.action_.bhv_before_kick_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_bhv_before_kick_off(::protos::Bhv_BeforeKickOff* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_bhv_before_kick_off();
    _impl_.action_.bhv_before_kick_off_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.bhv_before_kick_off)
}
inline ::protos::Bhv_BeforeKickOff* PlayerAction::_internal_mutable_bhv_before_kick_off() {
  if (action_case() != kBhvBeforeKickOff) {
    clear_action();
    set_has_bhv_before_kick_off();
    _impl_.action_.bhv_before_kick_off_ = CreateMaybeMessage<::protos::Bhv_BeforeKickOff>(GetArena());
  }
  return _impl_.action_.bhv_before_kick_off_;
}
inline ::protos::Bhv_BeforeKickOff* PlayerAction::mutable_bhv_before_kick_off() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Bhv_BeforeKickOff* _msg = _internal_mutable_bhv_before_kick_off();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.bhv_before_kick_off)
  return _msg;
}

// .protos.Bhv_BodyNeckToBall bhv_body_neck_to_ball = 19;
inline bool PlayerAction::has_bhv_body_neck_to_ball() const {
  return action_case() == kBhvBodyNeckToBall;
}
inline bool PlayerAction::_internal_has_bhv_body_neck_to_ball() const {
  return action_case() == kBhvBodyNeckToBall;
}
inline void PlayerAction::set_has_bhv_body_neck_to_ball() {
  _impl_._oneof_case_[0] = kBhvBodyNeckToBall;
}
inline void PlayerAction::clear_bhv_body_neck_to_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBhvBodyNeckToBall) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.bhv_body_neck_to_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_BodyNeckToBall* PlayerAction::release_bhv_body_neck_to_ball() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.bhv_body_neck_to_ball)
  if (action_case() == kBhvBodyNeckToBall) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_body_neck_to_ball_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_body_neck_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_BodyNeckToBall& PlayerAction::_internal_bhv_body_neck_to_ball() const {
  return action_case() == kBhvBodyNeckToBall ? *_impl_.action_.bhv_body_neck_to_ball_ : reinterpret_cast<::protos::Bhv_BodyNeckToBall&>(::protos::_Bhv_BodyNeckToBall_default_instance_);
}
inline const ::protos::Bhv_BodyNeckToBall& PlayerAction::bhv_body_neck_to_ball() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.bhv_body_neck_to_ball)
  return _internal_bhv_body_neck_to_ball();
}
inline ::protos::Bhv_BodyNeckToBall* PlayerAction::unsafe_arena_release_bhv_body_neck_to_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.bhv_body_neck_to_ball)
  if (action_case() == kBhvBodyNeckToBall) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_body_neck_to_ball_;
    _impl_.action_.bhv_body_neck_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_bhv_body_neck_to_ball(::protos::Bhv_BodyNeckToBall* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_bhv_body_neck_to_ball();
    _impl_.action_.bhv_body_neck_to_ball_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.bhv_body_neck_to_ball)
}
inline ::protos::Bhv_BodyNeckToBall* PlayerAction::_internal_mutable_bhv_body_neck_to_ball() {
  if (action_case() != kBhvBodyNeckToBall) {
    clear_action();
    set_has_bhv_body_neck_to_ball();
    _impl_.action_.bhv_body_neck_to_ball_ = CreateMaybeMessage<::protos::Bhv_BodyNeckToBall>(GetArena());
  }
  return _impl_.action_.bhv_body_neck_to_ball_;
}
inline ::protos::Bhv_BodyNeckToBall* PlayerAction::mutable_bhv_body_neck_to_ball() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Bhv_BodyNeckToBall* _msg = _internal_mutable_bhv_body_neck_to_ball();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.bhv_body_neck_to_ball)
  return _msg;
}

// .protos.Bhv_BodyNeckToPoint bhv_body_neck_to_point = 20;
inline bool PlayerAction::has_bhv_body_neck_to_point() const {
  return action_case() == kBhvBodyNeckToPoint;
}
inline bool PlayerAction::_internal_has_bhv_body_neck_to_point() const {
  return action_case() == kBhvBodyNeckToPoint;
}
inline void PlayerAction::set_has_bhv_body_neck_to_point() {
  _impl_._oneof_case_[0] = kBhvBodyNeckToPoint;
}
inline void PlayerAction::clear_bhv_body_neck_to_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBhvBodyNeckToPoint) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.bhv_body_neck_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_BodyNeckToPoint* PlayerAction::release_bhv_body_neck_to_point() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.bhv_body_neck_to_point)
  if (action_case() == kBhvBodyNeckToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_body_neck_to_point_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_body_neck_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_BodyNeckToPoint& PlayerAction::_internal_bhv_body_neck_to_point() const {
  return action_case() == kBhvBodyNeckToPoint ? *_impl_.action_.bhv_body_neck_to_point_ : reinterpret_cast<::protos::Bhv_BodyNeckToPoint&>(::protos::_Bhv_BodyNeckToPoint_default_instance_);
}
inline const ::protos::Bhv_BodyNeckToPoint& PlayerAction::bhv_body_neck_to_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.bhv_body_neck_to_point)
  return _internal_bhv_body_neck_to_point();
}
inline ::protos::Bhv_BodyNeckToPoint* PlayerAction::unsafe_arena_release_bhv_body_neck_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.bhv_body_neck_to_point)
  if (action_case() == kBhvBodyNeckToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_body_neck_to_point_;
    _impl_.action_.bhv_body_neck_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_bhv_body_neck_to_point(::protos::Bhv_BodyNeckToPoint* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_bhv_body_neck_to_point();
    _impl_.action_.bhv_body_neck_to_point_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.bhv_body_neck_to_point)
}
inline ::protos::Bhv_BodyNeckToPoint* PlayerAction::_internal_mutable_bhv_body_neck_to_point() {
  if (action_case() != kBhvBodyNeckToPoint) {
    clear_action();
    set_has_bhv_body_neck_to_point();
    _impl_.action_.bhv_body_neck_to_point_ = CreateMaybeMessage<::protos::Bhv_BodyNeckToPoint>(GetArena());
  }
  return _impl_.action_.bhv_body_neck_to_point_;
}
inline ::protos::Bhv_BodyNeckToPoint* PlayerAction::mutable_bhv_body_neck_to_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Bhv_BodyNeckToPoint* _msg = _internal_mutable_bhv_body_neck_to_point();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.bhv_body_neck_to_point)
  return _msg;
}

// .protos.Bhv_Emergency bhv_emergency = 21;
inline bool PlayerAction::has_bhv_emergency() const {
  return action_case() == kBhvEmergency;
}
inline bool PlayerAction::_internal_has_bhv_emergency() const {
  return action_case() == kBhvEmergency;
}
inline void PlayerAction::set_has_bhv_emergency() {
  _impl_._oneof_case_[0] = kBhvEmergency;
}
inline void PlayerAction::clear_bhv_emergency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBhvEmergency) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.bhv_emergency_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_Emergency* PlayerAction::release_bhv_emergency() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.bhv_emergency)
  if (action_case() == kBhvEmergency) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_emergency_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_emergency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_Emergency& PlayerAction::_internal_bhv_emergency() const {
  return action_case() == kBhvEmergency ? *_impl_.action_.bhv_emergency_ : reinterpret_cast<::protos::Bhv_Emergency&>(::protos::_Bhv_Emergency_default_instance_);
}
inline const ::protos::Bhv_Emergency& PlayerAction::bhv_emergency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.bhv_emergency)
  return _internal_bhv_emergency();
}
inline ::protos::Bhv_Emergency* PlayerAction::unsafe_arena_release_bhv_emergency() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.bhv_emergency)
  if (action_case() == kBhvEmergency) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_emergency_;
    _impl_.action_.bhv_emergency_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_bhv_emergency(::protos::Bhv_Emergency* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_bhv_emergency();
    _impl_.action_.bhv_emergency_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.bhv_emergency)
}
inline ::protos::Bhv_Emergency* PlayerAction::_internal_mutable_bhv_emergency() {
  if (action_case() != kBhvEmergency) {
    clear_action();
    set_has_bhv_emergency();
    _impl_.action_.bhv_emergency_ = CreateMaybeMessage<::protos::Bhv_Emergency>(GetArena());
  }
  return _impl_.action_.bhv_emergency_;
}
inline ::protos::Bhv_Emergency* PlayerAction::mutable_bhv_emergency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Bhv_Emergency* _msg = _internal_mutable_bhv_emergency();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.bhv_emergency)
  return _msg;
}

// .protos.Bhv_GoToPointLookBall bhv_go_to_point_look_ball = 22;
inline bool PlayerAction::has_bhv_go_to_point_look_ball() const {
  return action_case() == kBhvGoToPointLookBall;
}
inline bool PlayerAction::_internal_has_bhv_go_to_point_look_ball() const {
  return action_case() == kBhvGoToPointLookBall;
}
inline void PlayerAction::set_has_bhv_go_to_point_look_ball() {
  _impl_._oneof_case_[0] = kBhvGoToPointLookBall;
}
inline void PlayerAction::clear_bhv_go_to_point_look_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBhvGoToPointLookBall) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.bhv_go_to_point_look_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_GoToPointLookBall* PlayerAction::release_bhv_go_to_point_look_ball() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.bhv_go_to_point_look_ball)
  if (action_case() == kBhvGoToPointLookBall) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_go_to_point_look_ball_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_go_to_point_look_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_GoToPointLookBall& PlayerAction::_internal_bhv_go_to_point_look_ball() const {
  return action_case() == kBhvGoToPointLookBall ? *_impl_.action_.bhv_go_to_point_look_ball_ : reinterpret_cast<::protos::Bhv_GoToPointLookBall&>(::protos::_Bhv_GoToPointLookBall_default_instance_);
}
inline const ::protos::Bhv_GoToPointLookBall& PlayerAction::bhv_go_to_point_look_ball() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.bhv_go_to_point_look_ball)
  return _internal_bhv_go_to_point_look_ball();
}
inline ::protos::Bhv_GoToPointLookBall* PlayerAction::unsafe_arena_release_bhv_go_to_point_look_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.bhv_go_to_point_look_ball)
  if (action_case() == kBhvGoToPointLookBall) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_go_to_point_look_ball_;
    _impl_.action_.bhv_go_to_point_look_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_bhv_go_to_point_look_ball(::protos::Bhv_GoToPointLookBall* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_bhv_go_to_point_look_ball();
    _impl_.action_.bhv_go_to_point_look_ball_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.bhv_go_to_point_look_ball)
}
inline ::protos::Bhv_GoToPointLookBall* PlayerAction::_internal_mutable_bhv_go_to_point_look_ball() {
  if (action_case() != kBhvGoToPointLookBall) {
    clear_action();
    set_has_bhv_go_to_point_look_ball();
    _impl_.action_.bhv_go_to_point_look_ball_ = CreateMaybeMessage<::protos::Bhv_GoToPointLookBall>(GetArena());
  }
  return _impl_.action_.bhv_go_to_point_look_ball_;
}
inline ::protos::Bhv_GoToPointLookBall* PlayerAction::mutable_bhv_go_to_point_look_ball() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Bhv_GoToPointLookBall* _msg = _internal_mutable_bhv_go_to_point_look_ball();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.bhv_go_to_point_look_ball)
  return _msg;
}

// .protos.Bhv_NeckBodyToBall bhv_neck_body_to_ball = 23;
inline bool PlayerAction::has_bhv_neck_body_to_ball() const {
  return action_case() == kBhvNeckBodyToBall;
}
inline bool PlayerAction::_internal_has_bhv_neck_body_to_ball() const {
  return action_case() == kBhvNeckBodyToBall;
}
inline void PlayerAction::set_has_bhv_neck_body_to_ball() {
  _impl_._oneof_case_[0] = kBhvNeckBodyToBall;
}
inline void PlayerAction::clear_bhv_neck_body_to_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBhvNeckBodyToBall) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.bhv_neck_body_to_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_NeckBodyToBall* PlayerAction::release_bhv_neck_body_to_ball() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.bhv_neck_body_to_ball)
  if (action_case() == kBhvNeckBodyToBall) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_neck_body_to_ball_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_neck_body_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_NeckBodyToBall& PlayerAction::_internal_bhv_neck_body_to_ball() const {
  return action_case() == kBhvNeckBodyToBall ? *_impl_.action_.bhv_neck_body_to_ball_ : reinterpret_cast<::protos::Bhv_NeckBodyToBall&>(::protos::_Bhv_NeckBodyToBall_default_instance_);
}
inline const ::protos::Bhv_NeckBodyToBall& PlayerAction::bhv_neck_body_to_ball() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.bhv_neck_body_to_ball)
  return _internal_bhv_neck_body_to_ball();
}
inline ::protos::Bhv_NeckBodyToBall* PlayerAction::unsafe_arena_release_bhv_neck_body_to_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.bhv_neck_body_to_ball)
  if (action_case() == kBhvNeckBodyToBall) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_neck_body_to_ball_;
    _impl_.action_.bhv_neck_body_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_bhv_neck_body_to_ball(::protos::Bhv_NeckBodyToBall* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_bhv_neck_body_to_ball();
    _impl_.action_.bhv_neck_body_to_ball_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.bhv_neck_body_to_ball)
}
inline ::protos::Bhv_NeckBodyToBall* PlayerAction::_internal_mutable_bhv_neck_body_to_ball() {
  if (action_case() != kBhvNeckBodyToBall) {
    clear_action();
    set_has_bhv_neck_body_to_ball();
    _impl_.action_.bhv_neck_body_to_ball_ = CreateMaybeMessage<::protos::Bhv_NeckBodyToBall>(GetArena());
  }
  return _impl_.action_.bhv_neck_body_to_ball_;
}
inline ::protos::Bhv_NeckBodyToBall* PlayerAction::mutable_bhv_neck_body_to_ball() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Bhv_NeckBodyToBall* _msg = _internal_mutable_bhv_neck_body_to_ball();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.bhv_neck_body_to_ball)
  return _msg;
}

// .protos.Bhv_NeckBodyToPoint bhv_neck_body_to_point = 24;
inline bool PlayerAction::has_bhv_neck_body_to_point() const {
  return action_case() == kBhvNeckBodyToPoint;
}
inline bool PlayerAction::_internal_has_bhv_neck_body_to_point() const {
  return action_case() == kBhvNeckBodyToPoint;
}
inline void PlayerAction::set_has_bhv_neck_body_to_point() {
  _impl_._oneof_case_[0] = kBhvNeckBodyToPoint;
}
inline void PlayerAction::clear_bhv_neck_body_to_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBhvNeckBodyToPoint) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.bhv_neck_body_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_NeckBodyToPoint* PlayerAction::release_bhv_neck_body_to_point() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.bhv_neck_body_to_point)
  if (action_case() == kBhvNeckBodyToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_neck_body_to_point_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_neck_body_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_NeckBodyToPoint& PlayerAction::_internal_bhv_neck_body_to_point() const {
  return action_case() == kBhvNeckBodyToPoint ? *_impl_.action_.bhv_neck_body_to_point_ : reinterpret_cast<::protos::Bhv_NeckBodyToPoint&>(::protos::_Bhv_NeckBodyToPoint_default_instance_);
}
inline const ::protos::Bhv_NeckBodyToPoint& PlayerAction::bhv_neck_body_to_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.bhv_neck_body_to_point)
  return _internal_bhv_neck_body_to_point();
}
inline ::protos::Bhv_NeckBodyToPoint* PlayerAction::unsafe_arena_release_bhv_neck_body_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.bhv_neck_body_to_point)
  if (action_case() == kBhvNeckBodyToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_neck_body_to_point_;
    _impl_.action_.bhv_neck_body_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_bhv_neck_body_to_point(::protos::Bhv_NeckBodyToPoint* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_bhv_neck_body_to_point();
    _impl_.action_.bhv_neck_body_to_point_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.bhv_neck_body_to_point)
}
inline ::protos::Bhv_NeckBodyToPoint* PlayerAction::_internal_mutable_bhv_neck_body_to_point() {
  if (action_case() != kBhvNeckBodyToPoint) {
    clear_action();
    set_has_bhv_neck_body_to_point();
    _impl_.action_.bhv_neck_body_to_point_ = CreateMaybeMessage<::protos::Bhv_NeckBodyToPoint>(GetArena());
  }
  return _impl_.action_.bhv_neck_body_to_point_;
}
inline ::protos::Bhv_NeckBodyToPoint* PlayerAction::mutable_bhv_neck_body_to_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Bhv_NeckBodyToPoint* _msg = _internal_mutable_bhv_neck_body_to_point();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.bhv_neck_body_to_point)
  return _msg;
}

// .protos.Bhv_ScanField bhv_scan_field = 25;
inline bool PlayerAction::has_bhv_scan_field() const {
  return action_case() == kBhvScanField;
}
inline bool PlayerAction::_internal_has_bhv_scan_field() const {
  return action_case() == kBhvScanField;
}
inline void PlayerAction::set_has_bhv_scan_field() {
  _impl_._oneof_case_[0] = kBhvScanField;
}
inline void PlayerAction::clear_bhv_scan_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBhvScanField) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.bhv_scan_field_;
    }
    clear_has_action();
  }
}
inline ::protos::Bhv_ScanField* PlayerAction::release_bhv_scan_field() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.bhv_scan_field)
  if (action_case() == kBhvScanField) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_scan_field_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.bhv_scan_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Bhv_ScanField& PlayerAction::_internal_bhv_scan_field() const {
  return action_case() == kBhvScanField ? *_impl_.action_.bhv_scan_field_ : reinterpret_cast<::protos::Bhv_ScanField&>(::protos::_Bhv_ScanField_default_instance_);
}
inline const ::protos::Bhv_ScanField& PlayerAction::bhv_scan_field() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.bhv_scan_field)
  return _internal_bhv_scan_field();
}
inline ::protos::Bhv_ScanField* PlayerAction::unsafe_arena_release_bhv_scan_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.bhv_scan_field)
  if (action_case() == kBhvScanField) {
    clear_has_action();
    auto* temp = _impl_.action_.bhv_scan_field_;
    _impl_.action_.bhv_scan_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_bhv_scan_field(::protos::Bhv_ScanField* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_bhv_scan_field();
    _impl_.action_.bhv_scan_field_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.bhv_scan_field)
}
inline ::protos::Bhv_ScanField* PlayerAction::_internal_mutable_bhv_scan_field() {
  if (action_case() != kBhvScanField) {
    clear_action();
    set_has_bhv_scan_field();
    _impl_.action_.bhv_scan_field_ = CreateMaybeMessage<::protos::Bhv_ScanField>(GetArena());
  }
  return _impl_.action_.bhv_scan_field_;
}
inline ::protos::Bhv_ScanField* PlayerAction::mutable_bhv_scan_field() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Bhv_ScanField* _msg = _internal_mutable_bhv_scan_field();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.bhv_scan_field)
  return _msg;
}

// .protos.Body_AdvanceBall body_advance_ball = 26;
inline bool PlayerAction::has_body_advance_ball() const {
  return action_case() == kBodyAdvanceBall;
}
inline bool PlayerAction::_internal_has_body_advance_ball() const {
  return action_case() == kBodyAdvanceBall;
}
inline void PlayerAction::set_has_body_advance_ball() {
  _impl_._oneof_case_[0] = kBodyAdvanceBall;
}
inline void PlayerAction::clear_body_advance_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyAdvanceBall) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_advance_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_AdvanceBall* PlayerAction::release_body_advance_ball() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_advance_ball)
  if (action_case() == kBodyAdvanceBall) {
    clear_has_action();
    auto* temp = _impl_.action_.body_advance_ball_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_advance_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_AdvanceBall& PlayerAction::_internal_body_advance_ball() const {
  return action_case() == kBodyAdvanceBall ? *_impl_.action_.body_advance_ball_ : reinterpret_cast<::protos::Body_AdvanceBall&>(::protos::_Body_AdvanceBall_default_instance_);
}
inline const ::protos::Body_AdvanceBall& PlayerAction::body_advance_ball() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_advance_ball)
  return _internal_body_advance_ball();
}
inline ::protos::Body_AdvanceBall* PlayerAction::unsafe_arena_release_body_advance_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_advance_ball)
  if (action_case() == kBodyAdvanceBall) {
    clear_has_action();
    auto* temp = _impl_.action_.body_advance_ball_;
    _impl_.action_.body_advance_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_advance_ball(::protos::Body_AdvanceBall* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_advance_ball();
    _impl_.action_.body_advance_ball_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_advance_ball)
}
inline ::protos::Body_AdvanceBall* PlayerAction::_internal_mutable_body_advance_ball() {
  if (action_case() != kBodyAdvanceBall) {
    clear_action();
    set_has_body_advance_ball();
    _impl_.action_.body_advance_ball_ = CreateMaybeMessage<::protos::Body_AdvanceBall>(GetArena());
  }
  return _impl_.action_.body_advance_ball_;
}
inline ::protos::Body_AdvanceBall* PlayerAction::mutable_body_advance_ball() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_AdvanceBall* _msg = _internal_mutable_body_advance_ball();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_advance_ball)
  return _msg;
}

// .protos.Body_ClearBall body_clear_ball = 27;
inline bool PlayerAction::has_body_clear_ball() const {
  return action_case() == kBodyClearBall;
}
inline bool PlayerAction::_internal_has_body_clear_ball() const {
  return action_case() == kBodyClearBall;
}
inline void PlayerAction::set_has_body_clear_ball() {
  _impl_._oneof_case_[0] = kBodyClearBall;
}
inline void PlayerAction::clear_body_clear_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyClearBall) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_clear_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_ClearBall* PlayerAction::release_body_clear_ball() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_clear_ball)
  if (action_case() == kBodyClearBall) {
    clear_has_action();
    auto* temp = _impl_.action_.body_clear_ball_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_clear_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_ClearBall& PlayerAction::_internal_body_clear_ball() const {
  return action_case() == kBodyClearBall ? *_impl_.action_.body_clear_ball_ : reinterpret_cast<::protos::Body_ClearBall&>(::protos::_Body_ClearBall_default_instance_);
}
inline const ::protos::Body_ClearBall& PlayerAction::body_clear_ball() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_clear_ball)
  return _internal_body_clear_ball();
}
inline ::protos::Body_ClearBall* PlayerAction::unsafe_arena_release_body_clear_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_clear_ball)
  if (action_case() == kBodyClearBall) {
    clear_has_action();
    auto* temp = _impl_.action_.body_clear_ball_;
    _impl_.action_.body_clear_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_clear_ball(::protos::Body_ClearBall* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_clear_ball();
    _impl_.action_.body_clear_ball_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_clear_ball)
}
inline ::protos::Body_ClearBall* PlayerAction::_internal_mutable_body_clear_ball() {
  if (action_case() != kBodyClearBall) {
    clear_action();
    set_has_body_clear_ball();
    _impl_.action_.body_clear_ball_ = CreateMaybeMessage<::protos::Body_ClearBall>(GetArena());
  }
  return _impl_.action_.body_clear_ball_;
}
inline ::protos::Body_ClearBall* PlayerAction::mutable_body_clear_ball() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_ClearBall* _msg = _internal_mutable_body_clear_ball();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_clear_ball)
  return _msg;
}

// .protos.Body_Dribble body_dribble = 28;
inline bool PlayerAction::has_body_dribble() const {
  return action_case() == kBodyDribble;
}
inline bool PlayerAction::_internal_has_body_dribble() const {
  return action_case() == kBodyDribble;
}
inline void PlayerAction::set_has_body_dribble() {
  _impl_._oneof_case_[0] = kBodyDribble;
}
inline void PlayerAction::clear_body_dribble() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyDribble) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_dribble_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_Dribble* PlayerAction::release_body_dribble() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_dribble)
  if (action_case() == kBodyDribble) {
    clear_has_action();
    auto* temp = _impl_.action_.body_dribble_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_dribble_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_Dribble& PlayerAction::_internal_body_dribble() const {
  return action_case() == kBodyDribble ? *_impl_.action_.body_dribble_ : reinterpret_cast<::protos::Body_Dribble&>(::protos::_Body_Dribble_default_instance_);
}
inline const ::protos::Body_Dribble& PlayerAction::body_dribble() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_dribble)
  return _internal_body_dribble();
}
inline ::protos::Body_Dribble* PlayerAction::unsafe_arena_release_body_dribble() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_dribble)
  if (action_case() == kBodyDribble) {
    clear_has_action();
    auto* temp = _impl_.action_.body_dribble_;
    _impl_.action_.body_dribble_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_dribble(::protos::Body_Dribble* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_dribble();
    _impl_.action_.body_dribble_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_dribble)
}
inline ::protos::Body_Dribble* PlayerAction::_internal_mutable_body_dribble() {
  if (action_case() != kBodyDribble) {
    clear_action();
    set_has_body_dribble();
    _impl_.action_.body_dribble_ = CreateMaybeMessage<::protos::Body_Dribble>(GetArena());
  }
  return _impl_.action_.body_dribble_;
}
inline ::protos::Body_Dribble* PlayerAction::mutable_body_dribble() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_Dribble* _msg = _internal_mutable_body_dribble();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_dribble)
  return _msg;
}

// .protos.Body_GoToPointDodge body_go_to_point_dodge = 29;
inline bool PlayerAction::has_body_go_to_point_dodge() const {
  return action_case() == kBodyGoToPointDodge;
}
inline bool PlayerAction::_internal_has_body_go_to_point_dodge() const {
  return action_case() == kBodyGoToPointDodge;
}
inline void PlayerAction::set_has_body_go_to_point_dodge() {
  _impl_._oneof_case_[0] = kBodyGoToPointDodge;
}
inline void PlayerAction::clear_body_go_to_point_dodge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyGoToPointDodge) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_go_to_point_dodge_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_GoToPointDodge* PlayerAction::release_body_go_to_point_dodge() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_go_to_point_dodge)
  if (action_case() == kBodyGoToPointDodge) {
    clear_has_action();
    auto* temp = _impl_.action_.body_go_to_point_dodge_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_go_to_point_dodge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_GoToPointDodge& PlayerAction::_internal_body_go_to_point_dodge() const {
  return action_case() == kBodyGoToPointDodge ? *_impl_.action_.body_go_to_point_dodge_ : reinterpret_cast<::protos::Body_GoToPointDodge&>(::protos::_Body_GoToPointDodge_default_instance_);
}
inline const ::protos::Body_GoToPointDodge& PlayerAction::body_go_to_point_dodge() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_go_to_point_dodge)
  return _internal_body_go_to_point_dodge();
}
inline ::protos::Body_GoToPointDodge* PlayerAction::unsafe_arena_release_body_go_to_point_dodge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_go_to_point_dodge)
  if (action_case() == kBodyGoToPointDodge) {
    clear_has_action();
    auto* temp = _impl_.action_.body_go_to_point_dodge_;
    _impl_.action_.body_go_to_point_dodge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_go_to_point_dodge(::protos::Body_GoToPointDodge* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_go_to_point_dodge();
    _impl_.action_.body_go_to_point_dodge_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_go_to_point_dodge)
}
inline ::protos::Body_GoToPointDodge* PlayerAction::_internal_mutable_body_go_to_point_dodge() {
  if (action_case() != kBodyGoToPointDodge) {
    clear_action();
    set_has_body_go_to_point_dodge();
    _impl_.action_.body_go_to_point_dodge_ = CreateMaybeMessage<::protos::Body_GoToPointDodge>(GetArena());
  }
  return _impl_.action_.body_go_to_point_dodge_;
}
inline ::protos::Body_GoToPointDodge* PlayerAction::mutable_body_go_to_point_dodge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_GoToPointDodge* _msg = _internal_mutable_body_go_to_point_dodge();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_go_to_point_dodge)
  return _msg;
}

// .protos.Body_HoldBall body_hold_ball = 30;
inline bool PlayerAction::has_body_hold_ball() const {
  return action_case() == kBodyHoldBall;
}
inline bool PlayerAction::_internal_has_body_hold_ball() const {
  return action_case() == kBodyHoldBall;
}
inline void PlayerAction::set_has_body_hold_ball() {
  _impl_._oneof_case_[0] = kBodyHoldBall;
}
inline void PlayerAction::clear_body_hold_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyHoldBall) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_hold_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_HoldBall* PlayerAction::release_body_hold_ball() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_hold_ball)
  if (action_case() == kBodyHoldBall) {
    clear_has_action();
    auto* temp = _impl_.action_.body_hold_ball_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_hold_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_HoldBall& PlayerAction::_internal_body_hold_ball() const {
  return action_case() == kBodyHoldBall ? *_impl_.action_.body_hold_ball_ : reinterpret_cast<::protos::Body_HoldBall&>(::protos::_Body_HoldBall_default_instance_);
}
inline const ::protos::Body_HoldBall& PlayerAction::body_hold_ball() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_hold_ball)
  return _internal_body_hold_ball();
}
inline ::protos::Body_HoldBall* PlayerAction::unsafe_arena_release_body_hold_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_hold_ball)
  if (action_case() == kBodyHoldBall) {
    clear_has_action();
    auto* temp = _impl_.action_.body_hold_ball_;
    _impl_.action_.body_hold_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_hold_ball(::protos::Body_HoldBall* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_hold_ball();
    _impl_.action_.body_hold_ball_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_hold_ball)
}
inline ::protos::Body_HoldBall* PlayerAction::_internal_mutable_body_hold_ball() {
  if (action_case() != kBodyHoldBall) {
    clear_action();
    set_has_body_hold_ball();
    _impl_.action_.body_hold_ball_ = CreateMaybeMessage<::protos::Body_HoldBall>(GetArena());
  }
  return _impl_.action_.body_hold_ball_;
}
inline ::protos::Body_HoldBall* PlayerAction::mutable_body_hold_ball() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_HoldBall* _msg = _internal_mutable_body_hold_ball();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_hold_ball)
  return _msg;
}

// .protos.Body_Intercept body_intercept = 31;
inline bool PlayerAction::has_body_intercept() const {
  return action_case() == kBodyIntercept;
}
inline bool PlayerAction::_internal_has_body_intercept() const {
  return action_case() == kBodyIntercept;
}
inline void PlayerAction::set_has_body_intercept() {
  _impl_._oneof_case_[0] = kBodyIntercept;
}
inline void PlayerAction::clear_body_intercept() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyIntercept) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_intercept_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_Intercept* PlayerAction::release_body_intercept() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_intercept)
  if (action_case() == kBodyIntercept) {
    clear_has_action();
    auto* temp = _impl_.action_.body_intercept_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_intercept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_Intercept& PlayerAction::_internal_body_intercept() const {
  return action_case() == kBodyIntercept ? *_impl_.action_.body_intercept_ : reinterpret_cast<::protos::Body_Intercept&>(::protos::_Body_Intercept_default_instance_);
}
inline const ::protos::Body_Intercept& PlayerAction::body_intercept() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_intercept)
  return _internal_body_intercept();
}
inline ::protos::Body_Intercept* PlayerAction::unsafe_arena_release_body_intercept() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_intercept)
  if (action_case() == kBodyIntercept) {
    clear_has_action();
    auto* temp = _impl_.action_.body_intercept_;
    _impl_.action_.body_intercept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_intercept(::protos::Body_Intercept* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_intercept();
    _impl_.action_.body_intercept_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_intercept)
}
inline ::protos::Body_Intercept* PlayerAction::_internal_mutable_body_intercept() {
  if (action_case() != kBodyIntercept) {
    clear_action();
    set_has_body_intercept();
    _impl_.action_.body_intercept_ = CreateMaybeMessage<::protos::Body_Intercept>(GetArena());
  }
  return _impl_.action_.body_intercept_;
}
inline ::protos::Body_Intercept* PlayerAction::mutable_body_intercept() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_Intercept* _msg = _internal_mutable_body_intercept();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_intercept)
  return _msg;
}

// .protos.Body_KickOneStep body_kick_one_step = 32;
inline bool PlayerAction::has_body_kick_one_step() const {
  return action_case() == kBodyKickOneStep;
}
inline bool PlayerAction::_internal_has_body_kick_one_step() const {
  return action_case() == kBodyKickOneStep;
}
inline void PlayerAction::set_has_body_kick_one_step() {
  _impl_._oneof_case_[0] = kBodyKickOneStep;
}
inline void PlayerAction::clear_body_kick_one_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyKickOneStep) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_kick_one_step_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_KickOneStep* PlayerAction::release_body_kick_one_step() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_kick_one_step)
  if (action_case() == kBodyKickOneStep) {
    clear_has_action();
    auto* temp = _impl_.action_.body_kick_one_step_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_kick_one_step_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_KickOneStep& PlayerAction::_internal_body_kick_one_step() const {
  return action_case() == kBodyKickOneStep ? *_impl_.action_.body_kick_one_step_ : reinterpret_cast<::protos::Body_KickOneStep&>(::protos::_Body_KickOneStep_default_instance_);
}
inline const ::protos::Body_KickOneStep& PlayerAction::body_kick_one_step() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_kick_one_step)
  return _internal_body_kick_one_step();
}
inline ::protos::Body_KickOneStep* PlayerAction::unsafe_arena_release_body_kick_one_step() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_kick_one_step)
  if (action_case() == kBodyKickOneStep) {
    clear_has_action();
    auto* temp = _impl_.action_.body_kick_one_step_;
    _impl_.action_.body_kick_one_step_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_kick_one_step(::protos::Body_KickOneStep* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_kick_one_step();
    _impl_.action_.body_kick_one_step_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_kick_one_step)
}
inline ::protos::Body_KickOneStep* PlayerAction::_internal_mutable_body_kick_one_step() {
  if (action_case() != kBodyKickOneStep) {
    clear_action();
    set_has_body_kick_one_step();
    _impl_.action_.body_kick_one_step_ = CreateMaybeMessage<::protos::Body_KickOneStep>(GetArena());
  }
  return _impl_.action_.body_kick_one_step_;
}
inline ::protos::Body_KickOneStep* PlayerAction::mutable_body_kick_one_step() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_KickOneStep* _msg = _internal_mutable_body_kick_one_step();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_kick_one_step)
  return _msg;
}

// .protos.Body_StopBall body_stop_ball = 33;
inline bool PlayerAction::has_body_stop_ball() const {
  return action_case() == kBodyStopBall;
}
inline bool PlayerAction::_internal_has_body_stop_ball() const {
  return action_case() == kBodyStopBall;
}
inline void PlayerAction::set_has_body_stop_ball() {
  _impl_._oneof_case_[0] = kBodyStopBall;
}
inline void PlayerAction::clear_body_stop_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyStopBall) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_stop_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_StopBall* PlayerAction::release_body_stop_ball() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_stop_ball)
  if (action_case() == kBodyStopBall) {
    clear_has_action();
    auto* temp = _impl_.action_.body_stop_ball_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_stop_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_StopBall& PlayerAction::_internal_body_stop_ball() const {
  return action_case() == kBodyStopBall ? *_impl_.action_.body_stop_ball_ : reinterpret_cast<::protos::Body_StopBall&>(::protos::_Body_StopBall_default_instance_);
}
inline const ::protos::Body_StopBall& PlayerAction::body_stop_ball() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_stop_ball)
  return _internal_body_stop_ball();
}
inline ::protos::Body_StopBall* PlayerAction::unsafe_arena_release_body_stop_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_stop_ball)
  if (action_case() == kBodyStopBall) {
    clear_has_action();
    auto* temp = _impl_.action_.body_stop_ball_;
    _impl_.action_.body_stop_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_stop_ball(::protos::Body_StopBall* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_stop_ball();
    _impl_.action_.body_stop_ball_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_stop_ball)
}
inline ::protos::Body_StopBall* PlayerAction::_internal_mutable_body_stop_ball() {
  if (action_case() != kBodyStopBall) {
    clear_action();
    set_has_body_stop_ball();
    _impl_.action_.body_stop_ball_ = CreateMaybeMessage<::protos::Body_StopBall>(GetArena());
  }
  return _impl_.action_.body_stop_ball_;
}
inline ::protos::Body_StopBall* PlayerAction::mutable_body_stop_ball() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_StopBall* _msg = _internal_mutable_body_stop_ball();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_stop_ball)
  return _msg;
}

// .protos.Body_StopDash body_stop_dash = 34;
inline bool PlayerAction::has_body_stop_dash() const {
  return action_case() == kBodyStopDash;
}
inline bool PlayerAction::_internal_has_body_stop_dash() const {
  return action_case() == kBodyStopDash;
}
inline void PlayerAction::set_has_body_stop_dash() {
  _impl_._oneof_case_[0] = kBodyStopDash;
}
inline void PlayerAction::clear_body_stop_dash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyStopDash) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_stop_dash_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_StopDash* PlayerAction::release_body_stop_dash() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_stop_dash)
  if (action_case() == kBodyStopDash) {
    clear_has_action();
    auto* temp = _impl_.action_.body_stop_dash_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_stop_dash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_StopDash& PlayerAction::_internal_body_stop_dash() const {
  return action_case() == kBodyStopDash ? *_impl_.action_.body_stop_dash_ : reinterpret_cast<::protos::Body_StopDash&>(::protos::_Body_StopDash_default_instance_);
}
inline const ::protos::Body_StopDash& PlayerAction::body_stop_dash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_stop_dash)
  return _internal_body_stop_dash();
}
inline ::protos::Body_StopDash* PlayerAction::unsafe_arena_release_body_stop_dash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_stop_dash)
  if (action_case() == kBodyStopDash) {
    clear_has_action();
    auto* temp = _impl_.action_.body_stop_dash_;
    _impl_.action_.body_stop_dash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_stop_dash(::protos::Body_StopDash* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_stop_dash();
    _impl_.action_.body_stop_dash_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_stop_dash)
}
inline ::protos::Body_StopDash* PlayerAction::_internal_mutable_body_stop_dash() {
  if (action_case() != kBodyStopDash) {
    clear_action();
    set_has_body_stop_dash();
    _impl_.action_.body_stop_dash_ = CreateMaybeMessage<::protos::Body_StopDash>(GetArena());
  }
  return _impl_.action_.body_stop_dash_;
}
inline ::protos::Body_StopDash* PlayerAction::mutable_body_stop_dash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_StopDash* _msg = _internal_mutable_body_stop_dash();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_stop_dash)
  return _msg;
}

// .protos.Body_TackleToPoint body_tackle_to_point = 35;
inline bool PlayerAction::has_body_tackle_to_point() const {
  return action_case() == kBodyTackleToPoint;
}
inline bool PlayerAction::_internal_has_body_tackle_to_point() const {
  return action_case() == kBodyTackleToPoint;
}
inline void PlayerAction::set_has_body_tackle_to_point() {
  _impl_._oneof_case_[0] = kBodyTackleToPoint;
}
inline void PlayerAction::clear_body_tackle_to_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyTackleToPoint) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_tackle_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_TackleToPoint* PlayerAction::release_body_tackle_to_point() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_tackle_to_point)
  if (action_case() == kBodyTackleToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.body_tackle_to_point_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_tackle_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_TackleToPoint& PlayerAction::_internal_body_tackle_to_point() const {
  return action_case() == kBodyTackleToPoint ? *_impl_.action_.body_tackle_to_point_ : reinterpret_cast<::protos::Body_TackleToPoint&>(::protos::_Body_TackleToPoint_default_instance_);
}
inline const ::protos::Body_TackleToPoint& PlayerAction::body_tackle_to_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_tackle_to_point)
  return _internal_body_tackle_to_point();
}
inline ::protos::Body_TackleToPoint* PlayerAction::unsafe_arena_release_body_tackle_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_tackle_to_point)
  if (action_case() == kBodyTackleToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.body_tackle_to_point_;
    _impl_.action_.body_tackle_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_tackle_to_point(::protos::Body_TackleToPoint* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_tackle_to_point();
    _impl_.action_.body_tackle_to_point_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_tackle_to_point)
}
inline ::protos::Body_TackleToPoint* PlayerAction::_internal_mutable_body_tackle_to_point() {
  if (action_case() != kBodyTackleToPoint) {
    clear_action();
    set_has_body_tackle_to_point();
    _impl_.action_.body_tackle_to_point_ = CreateMaybeMessage<::protos::Body_TackleToPoint>(GetArena());
  }
  return _impl_.action_.body_tackle_to_point_;
}
inline ::protos::Body_TackleToPoint* PlayerAction::mutable_body_tackle_to_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_TackleToPoint* _msg = _internal_mutable_body_tackle_to_point();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_tackle_to_point)
  return _msg;
}

// .protos.Body_TurnToAngle body_turn_to_angle = 36;
inline bool PlayerAction::has_body_turn_to_angle() const {
  return action_case() == kBodyTurnToAngle;
}
inline bool PlayerAction::_internal_has_body_turn_to_angle() const {
  return action_case() == kBodyTurnToAngle;
}
inline void PlayerAction::set_has_body_turn_to_angle() {
  _impl_._oneof_case_[0] = kBodyTurnToAngle;
}
inline void PlayerAction::clear_body_turn_to_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyTurnToAngle) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_turn_to_angle_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_TurnToAngle* PlayerAction::release_body_turn_to_angle() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_turn_to_angle)
  if (action_case() == kBodyTurnToAngle) {
    clear_has_action();
    auto* temp = _impl_.action_.body_turn_to_angle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_turn_to_angle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_TurnToAngle& PlayerAction::_internal_body_turn_to_angle() const {
  return action_case() == kBodyTurnToAngle ? *_impl_.action_.body_turn_to_angle_ : reinterpret_cast<::protos::Body_TurnToAngle&>(::protos::_Body_TurnToAngle_default_instance_);
}
inline const ::protos::Body_TurnToAngle& PlayerAction::body_turn_to_angle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_turn_to_angle)
  return _internal_body_turn_to_angle();
}
inline ::protos::Body_TurnToAngle* PlayerAction::unsafe_arena_release_body_turn_to_angle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_turn_to_angle)
  if (action_case() == kBodyTurnToAngle) {
    clear_has_action();
    auto* temp = _impl_.action_.body_turn_to_angle_;
    _impl_.action_.body_turn_to_angle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_turn_to_angle(::protos::Body_TurnToAngle* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_turn_to_angle();
    _impl_.action_.body_turn_to_angle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_turn_to_angle)
}
inline ::protos::Body_TurnToAngle* PlayerAction::_internal_mutable_body_turn_to_angle() {
  if (action_case() != kBodyTurnToAngle) {
    clear_action();
    set_has_body_turn_to_angle();
    _impl_.action_.body_turn_to_angle_ = CreateMaybeMessage<::protos::Body_TurnToAngle>(GetArena());
  }
  return _impl_.action_.body_turn_to_angle_;
}
inline ::protos::Body_TurnToAngle* PlayerAction::mutable_body_turn_to_angle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_TurnToAngle* _msg = _internal_mutable_body_turn_to_angle();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_turn_to_angle)
  return _msg;
}

// .protos.Body_TurnToBall body_turn_to_ball = 37;
inline bool PlayerAction::has_body_turn_to_ball() const {
  return action_case() == kBodyTurnToBall;
}
inline bool PlayerAction::_internal_has_body_turn_to_ball() const {
  return action_case() == kBodyTurnToBall;
}
inline void PlayerAction::set_has_body_turn_to_ball() {
  _impl_._oneof_case_[0] = kBodyTurnToBall;
}
inline void PlayerAction::clear_body_turn_to_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyTurnToBall) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_turn_to_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_TurnToBall* PlayerAction::release_body_turn_to_ball() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_turn_to_ball)
  if (action_case() == kBodyTurnToBall) {
    clear_has_action();
    auto* temp = _impl_.action_.body_turn_to_ball_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_turn_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_TurnToBall& PlayerAction::_internal_body_turn_to_ball() const {
  return action_case() == kBodyTurnToBall ? *_impl_.action_.body_turn_to_ball_ : reinterpret_cast<::protos::Body_TurnToBall&>(::protos::_Body_TurnToBall_default_instance_);
}
inline const ::protos::Body_TurnToBall& PlayerAction::body_turn_to_ball() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_turn_to_ball)
  return _internal_body_turn_to_ball();
}
inline ::protos::Body_TurnToBall* PlayerAction::unsafe_arena_release_body_turn_to_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_turn_to_ball)
  if (action_case() == kBodyTurnToBall) {
    clear_has_action();
    auto* temp = _impl_.action_.body_turn_to_ball_;
    _impl_.action_.body_turn_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_turn_to_ball(::protos::Body_TurnToBall* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_turn_to_ball();
    _impl_.action_.body_turn_to_ball_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_turn_to_ball)
}
inline ::protos::Body_TurnToBall* PlayerAction::_internal_mutable_body_turn_to_ball() {
  if (action_case() != kBodyTurnToBall) {
    clear_action();
    set_has_body_turn_to_ball();
    _impl_.action_.body_turn_to_ball_ = CreateMaybeMessage<::protos::Body_TurnToBall>(GetArena());
  }
  return _impl_.action_.body_turn_to_ball_;
}
inline ::protos::Body_TurnToBall* PlayerAction::mutable_body_turn_to_ball() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_TurnToBall* _msg = _internal_mutable_body_turn_to_ball();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_turn_to_ball)
  return _msg;
}

// .protos.Body_TurnToPoint body_turn_to_point = 38;
inline bool PlayerAction::has_body_turn_to_point() const {
  return action_case() == kBodyTurnToPoint;
}
inline bool PlayerAction::_internal_has_body_turn_to_point() const {
  return action_case() == kBodyTurnToPoint;
}
inline void PlayerAction::set_has_body_turn_to_point() {
  _impl_._oneof_case_[0] = kBodyTurnToPoint;
}
inline void PlayerAction::clear_body_turn_to_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kBodyTurnToPoint) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.body_turn_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Body_TurnToPoint* PlayerAction::release_body_turn_to_point() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.body_turn_to_point)
  if (action_case() == kBodyTurnToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.body_turn_to_point_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.body_turn_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Body_TurnToPoint& PlayerAction::_internal_body_turn_to_point() const {
  return action_case() == kBodyTurnToPoint ? *_impl_.action_.body_turn_to_point_ : reinterpret_cast<::protos::Body_TurnToPoint&>(::protos::_Body_TurnToPoint_default_instance_);
}
inline const ::protos::Body_TurnToPoint& PlayerAction::body_turn_to_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.body_turn_to_point)
  return _internal_body_turn_to_point();
}
inline ::protos::Body_TurnToPoint* PlayerAction::unsafe_arena_release_body_turn_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.body_turn_to_point)
  if (action_case() == kBodyTurnToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.body_turn_to_point_;
    _impl_.action_.body_turn_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_body_turn_to_point(::protos::Body_TurnToPoint* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_body_turn_to_point();
    _impl_.action_.body_turn_to_point_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.body_turn_to_point)
}
inline ::protos::Body_TurnToPoint* PlayerAction::_internal_mutable_body_turn_to_point() {
  if (action_case() != kBodyTurnToPoint) {
    clear_action();
    set_has_body_turn_to_point();
    _impl_.action_.body_turn_to_point_ = CreateMaybeMessage<::protos::Body_TurnToPoint>(GetArena());
  }
  return _impl_.action_.body_turn_to_point_;
}
inline ::protos::Body_TurnToPoint* PlayerAction::mutable_body_turn_to_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Body_TurnToPoint* _msg = _internal_mutable_body_turn_to_point();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.body_turn_to_point)
  return _msg;
}

// .protos.Focus_MoveToPoint focus_move_to_point = 39;
inline bool PlayerAction::has_focus_move_to_point() const {
  return action_case() == kFocusMoveToPoint;
}
inline bool PlayerAction::_internal_has_focus_move_to_point() const {
  return action_case() == kFocusMoveToPoint;
}
inline void PlayerAction::set_has_focus_move_to_point() {
  _impl_._oneof_case_[0] = kFocusMoveToPoint;
}
inline void PlayerAction::clear_focus_move_to_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kFocusMoveToPoint) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.focus_move_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Focus_MoveToPoint* PlayerAction::release_focus_move_to_point() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.focus_move_to_point)
  if (action_case() == kFocusMoveToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.focus_move_to_point_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.focus_move_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Focus_MoveToPoint& PlayerAction::_internal_focus_move_to_point() const {
  return action_case() == kFocusMoveToPoint ? *_impl_.action_.focus_move_to_point_ : reinterpret_cast<::protos::Focus_MoveToPoint&>(::protos::_Focus_MoveToPoint_default_instance_);
}
inline const ::protos::Focus_MoveToPoint& PlayerAction::focus_move_to_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.focus_move_to_point)
  return _internal_focus_move_to_point();
}
inline ::protos::Focus_MoveToPoint* PlayerAction::unsafe_arena_release_focus_move_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.focus_move_to_point)
  if (action_case() == kFocusMoveToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.focus_move_to_point_;
    _impl_.action_.focus_move_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_focus_move_to_point(::protos::Focus_MoveToPoint* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_focus_move_to_point();
    _impl_.action_.focus_move_to_point_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.focus_move_to_point)
}
inline ::protos::Focus_MoveToPoint* PlayerAction::_internal_mutable_focus_move_to_point() {
  if (action_case() != kFocusMoveToPoint) {
    clear_action();
    set_has_focus_move_to_point();
    _impl_.action_.focus_move_to_point_ = CreateMaybeMessage<::protos::Focus_MoveToPoint>(GetArena());
  }
  return _impl_.action_.focus_move_to_point_;
}
inline ::protos::Focus_MoveToPoint* PlayerAction::mutable_focus_move_to_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Focus_MoveToPoint* _msg = _internal_mutable_focus_move_to_point();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.focus_move_to_point)
  return _msg;
}

// .protos.Focus_Reset focus_reset = 40;
inline bool PlayerAction::has_focus_reset() const {
  return action_case() == kFocusReset;
}
inline bool PlayerAction::_internal_has_focus_reset() const {
  return action_case() == kFocusReset;
}
inline void PlayerAction::set_has_focus_reset() {
  _impl_._oneof_case_[0] = kFocusReset;
}
inline void PlayerAction::clear_focus_reset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kFocusReset) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.focus_reset_;
    }
    clear_has_action();
  }
}
inline ::protos::Focus_Reset* PlayerAction::release_focus_reset() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.focus_reset)
  if (action_case() == kFocusReset) {
    clear_has_action();
    auto* temp = _impl_.action_.focus_reset_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.focus_reset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Focus_Reset& PlayerAction::_internal_focus_reset() const {
  return action_case() == kFocusReset ? *_impl_.action_.focus_reset_ : reinterpret_cast<::protos::Focus_Reset&>(::protos::_Focus_Reset_default_instance_);
}
inline const ::protos::Focus_Reset& PlayerAction::focus_reset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.focus_reset)
  return _internal_focus_reset();
}
inline ::protos::Focus_Reset* PlayerAction::unsafe_arena_release_focus_reset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.focus_reset)
  if (action_case() == kFocusReset) {
    clear_has_action();
    auto* temp = _impl_.action_.focus_reset_;
    _impl_.action_.focus_reset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_focus_reset(::protos::Focus_Reset* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_focus_reset();
    _impl_.action_.focus_reset_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.focus_reset)
}
inline ::protos::Focus_Reset* PlayerAction::_internal_mutable_focus_reset() {
  if (action_case() != kFocusReset) {
    clear_action();
    set_has_focus_reset();
    _impl_.action_.focus_reset_ = CreateMaybeMessage<::protos::Focus_Reset>(GetArena());
  }
  return _impl_.action_.focus_reset_;
}
inline ::protos::Focus_Reset* PlayerAction::mutable_focus_reset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Focus_Reset* _msg = _internal_mutable_focus_reset();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.focus_reset)
  return _msg;
}

// .protos.Neck_ScanField neck_scan_field = 41;
inline bool PlayerAction::has_neck_scan_field() const {
  return action_case() == kNeckScanField;
}
inline bool PlayerAction::_internal_has_neck_scan_field() const {
  return action_case() == kNeckScanField;
}
inline void PlayerAction::set_has_neck_scan_field() {
  _impl_._oneof_case_[0] = kNeckScanField;
}
inline void PlayerAction::clear_neck_scan_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kNeckScanField) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.neck_scan_field_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_ScanField* PlayerAction::release_neck_scan_field() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.neck_scan_field)
  if (action_case() == kNeckScanField) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_scan_field_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_scan_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_ScanField& PlayerAction::_internal_neck_scan_field() const {
  return action_case() == kNeckScanField ? *_impl_.action_.neck_scan_field_ : reinterpret_cast<::protos::Neck_ScanField&>(::protos::_Neck_ScanField_default_instance_);
}
inline const ::protos::Neck_ScanField& PlayerAction::neck_scan_field() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.neck_scan_field)
  return _internal_neck_scan_field();
}
inline ::protos::Neck_ScanField* PlayerAction::unsafe_arena_release_neck_scan_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.neck_scan_field)
  if (action_case() == kNeckScanField) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_scan_field_;
    _impl_.action_.neck_scan_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_neck_scan_field(::protos::Neck_ScanField* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_neck_scan_field();
    _impl_.action_.neck_scan_field_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.neck_scan_field)
}
inline ::protos::Neck_ScanField* PlayerAction::_internal_mutable_neck_scan_field() {
  if (action_case() != kNeckScanField) {
    clear_action();
    set_has_neck_scan_field();
    _impl_.action_.neck_scan_field_ = CreateMaybeMessage<::protos::Neck_ScanField>(GetArena());
  }
  return _impl_.action_.neck_scan_field_;
}
inline ::protos::Neck_ScanField* PlayerAction::mutable_neck_scan_field() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Neck_ScanField* _msg = _internal_mutable_neck_scan_field();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.neck_scan_field)
  return _msg;
}

// .protos.Neck_ScanPlayers neck_scan_players = 42;
inline bool PlayerAction::has_neck_scan_players() const {
  return action_case() == kNeckScanPlayers;
}
inline bool PlayerAction::_internal_has_neck_scan_players() const {
  return action_case() == kNeckScanPlayers;
}
inline void PlayerAction::set_has_neck_scan_players() {
  _impl_._oneof_case_[0] = kNeckScanPlayers;
}
inline void PlayerAction::clear_neck_scan_players() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kNeckScanPlayers) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.neck_scan_players_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_ScanPlayers* PlayerAction::release_neck_scan_players() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.neck_scan_players)
  if (action_case() == kNeckScanPlayers) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_scan_players_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_scan_players_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_ScanPlayers& PlayerAction::_internal_neck_scan_players() const {
  return action_case() == kNeckScanPlayers ? *_impl_.action_.neck_scan_players_ : reinterpret_cast<::protos::Neck_ScanPlayers&>(::protos::_Neck_ScanPlayers_default_instance_);
}
inline const ::protos::Neck_ScanPlayers& PlayerAction::neck_scan_players() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.neck_scan_players)
  return _internal_neck_scan_players();
}
inline ::protos::Neck_ScanPlayers* PlayerAction::unsafe_arena_release_neck_scan_players() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.neck_scan_players)
  if (action_case() == kNeckScanPlayers) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_scan_players_;
    _impl_.action_.neck_scan_players_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_neck_scan_players(::protos::Neck_ScanPlayers* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_neck_scan_players();
    _impl_.action_.neck_scan_players_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.neck_scan_players)
}
inline ::protos::Neck_ScanPlayers* PlayerAction::_internal_mutable_neck_scan_players() {
  if (action_case() != kNeckScanPlayers) {
    clear_action();
    set_has_neck_scan_players();
    _impl_.action_.neck_scan_players_ = CreateMaybeMessage<::protos::Neck_ScanPlayers>(GetArena());
  }
  return _impl_.action_.neck_scan_players_;
}
inline ::protos::Neck_ScanPlayers* PlayerAction::mutable_neck_scan_players() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Neck_ScanPlayers* _msg = _internal_mutable_neck_scan_players();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.neck_scan_players)
  return _msg;
}

// .protos.Neck_TurnToBallAndPlayer neck_turn_to_ball_and_player = 43;
inline bool PlayerAction::has_neck_turn_to_ball_and_player() const {
  return action_case() == kNeckTurnToBallAndPlayer;
}
inline bool PlayerAction::_internal_has_neck_turn_to_ball_and_player() const {
  return action_case() == kNeckTurnToBallAndPlayer;
}
inline void PlayerAction::set_has_neck_turn_to_ball_and_player() {
  _impl_._oneof_case_[0] = kNeckTurnToBallAndPlayer;
}
inline void PlayerAction::clear_neck_turn_to_ball_and_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kNeckTurnToBallAndPlayer) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.neck_turn_to_ball_and_player_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToBallAndPlayer* PlayerAction::release_neck_turn_to_ball_and_player() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.neck_turn_to_ball_and_player)
  if (action_case() == kNeckTurnToBallAndPlayer) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_ball_and_player_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_ball_and_player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToBallAndPlayer& PlayerAction::_internal_neck_turn_to_ball_and_player() const {
  return action_case() == kNeckTurnToBallAndPlayer ? *_impl_.action_.neck_turn_to_ball_and_player_ : reinterpret_cast<::protos::Neck_TurnToBallAndPlayer&>(::protos::_Neck_TurnToBallAndPlayer_default_instance_);
}
inline const ::protos::Neck_TurnToBallAndPlayer& PlayerAction::neck_turn_to_ball_and_player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.neck_turn_to_ball_and_player)
  return _internal_neck_turn_to_ball_and_player();
}
inline ::protos::Neck_TurnToBallAndPlayer* PlayerAction::unsafe_arena_release_neck_turn_to_ball_and_player() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.neck_turn_to_ball_and_player)
  if (action_case() == kNeckTurnToBallAndPlayer) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_ball_and_player_;
    _impl_.action_.neck_turn_to_ball_and_player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_neck_turn_to_ball_and_player(::protos::Neck_TurnToBallAndPlayer* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_neck_turn_to_ball_and_player();
    _impl_.action_.neck_turn_to_ball_and_player_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.neck_turn_to_ball_and_player)
}
inline ::protos::Neck_TurnToBallAndPlayer* PlayerAction::_internal_mutable_neck_turn_to_ball_and_player() {
  if (action_case() != kNeckTurnToBallAndPlayer) {
    clear_action();
    set_has_neck_turn_to_ball_and_player();
    _impl_.action_.neck_turn_to_ball_and_player_ = CreateMaybeMessage<::protos::Neck_TurnToBallAndPlayer>(GetArena());
  }
  return _impl_.action_.neck_turn_to_ball_and_player_;
}
inline ::protos::Neck_TurnToBallAndPlayer* PlayerAction::mutable_neck_turn_to_ball_and_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Neck_TurnToBallAndPlayer* _msg = _internal_mutable_neck_turn_to_ball_and_player();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.neck_turn_to_ball_and_player)
  return _msg;
}

// .protos.Neck_TurnToBallOrScan neck_turn_to_ball_or_scan = 44;
inline bool PlayerAction::has_neck_turn_to_ball_or_scan() const {
  return action_case() == kNeckTurnToBallOrScan;
}
inline bool PlayerAction::_internal_has_neck_turn_to_ball_or_scan() const {
  return action_case() == kNeckTurnToBallOrScan;
}
inline void PlayerAction::set_has_neck_turn_to_ball_or_scan() {
  _impl_._oneof_case_[0] = kNeckTurnToBallOrScan;
}
inline void PlayerAction::clear_neck_turn_to_ball_or_scan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kNeckTurnToBallOrScan) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.neck_turn_to_ball_or_scan_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToBallOrScan* PlayerAction::release_neck_turn_to_ball_or_scan() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.neck_turn_to_ball_or_scan)
  if (action_case() == kNeckTurnToBallOrScan) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_ball_or_scan_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_ball_or_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToBallOrScan& PlayerAction::_internal_neck_turn_to_ball_or_scan() const {
  return action_case() == kNeckTurnToBallOrScan ? *_impl_.action_.neck_turn_to_ball_or_scan_ : reinterpret_cast<::protos::Neck_TurnToBallOrScan&>(::protos::_Neck_TurnToBallOrScan_default_instance_);
}
inline const ::protos::Neck_TurnToBallOrScan& PlayerAction::neck_turn_to_ball_or_scan() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.neck_turn_to_ball_or_scan)
  return _internal_neck_turn_to_ball_or_scan();
}
inline ::protos::Neck_TurnToBallOrScan* PlayerAction::unsafe_arena_release_neck_turn_to_ball_or_scan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.neck_turn_to_ball_or_scan)
  if (action_case() == kNeckTurnToBallOrScan) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_ball_or_scan_;
    _impl_.action_.neck_turn_to_ball_or_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_neck_turn_to_ball_or_scan(::protos::Neck_TurnToBallOrScan* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_neck_turn_to_ball_or_scan();
    _impl_.action_.neck_turn_to_ball_or_scan_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.neck_turn_to_ball_or_scan)
}
inline ::protos::Neck_TurnToBallOrScan* PlayerAction::_internal_mutable_neck_turn_to_ball_or_scan() {
  if (action_case() != kNeckTurnToBallOrScan) {
    clear_action();
    set_has_neck_turn_to_ball_or_scan();
    _impl_.action_.neck_turn_to_ball_or_scan_ = CreateMaybeMessage<::protos::Neck_TurnToBallOrScan>(GetArena());
  }
  return _impl_.action_.neck_turn_to_ball_or_scan_;
}
inline ::protos::Neck_TurnToBallOrScan* PlayerAction::mutable_neck_turn_to_ball_or_scan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Neck_TurnToBallOrScan* _msg = _internal_mutable_neck_turn_to_ball_or_scan();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.neck_turn_to_ball_or_scan)
  return _msg;
}

// .protos.Neck_TurnToBall neck_turn_to_ball = 45;
inline bool PlayerAction::has_neck_turn_to_ball() const {
  return action_case() == kNeckTurnToBall;
}
inline bool PlayerAction::_internal_has_neck_turn_to_ball() const {
  return action_case() == kNeckTurnToBall;
}
inline void PlayerAction::set_has_neck_turn_to_ball() {
  _impl_._oneof_case_[0] = kNeckTurnToBall;
}
inline void PlayerAction::clear_neck_turn_to_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kNeckTurnToBall) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.neck_turn_to_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToBall* PlayerAction::release_neck_turn_to_ball() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.neck_turn_to_ball)
  if (action_case() == kNeckTurnToBall) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_ball_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToBall& PlayerAction::_internal_neck_turn_to_ball() const {
  return action_case() == kNeckTurnToBall ? *_impl_.action_.neck_turn_to_ball_ : reinterpret_cast<::protos::Neck_TurnToBall&>(::protos::_Neck_TurnToBall_default_instance_);
}
inline const ::protos::Neck_TurnToBall& PlayerAction::neck_turn_to_ball() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.neck_turn_to_ball)
  return _internal_neck_turn_to_ball();
}
inline ::protos::Neck_TurnToBall* PlayerAction::unsafe_arena_release_neck_turn_to_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.neck_turn_to_ball)
  if (action_case() == kNeckTurnToBall) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_ball_;
    _impl_.action_.neck_turn_to_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_neck_turn_to_ball(::protos::Neck_TurnToBall* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_neck_turn_to_ball();
    _impl_.action_.neck_turn_to_ball_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.neck_turn_to_ball)
}
inline ::protos::Neck_TurnToBall* PlayerAction::_internal_mutable_neck_turn_to_ball() {
  if (action_case() != kNeckTurnToBall) {
    clear_action();
    set_has_neck_turn_to_ball();
    _impl_.action_.neck_turn_to_ball_ = CreateMaybeMessage<::protos::Neck_TurnToBall>(GetArena());
  }
  return _impl_.action_.neck_turn_to_ball_;
}
inline ::protos::Neck_TurnToBall* PlayerAction::mutable_neck_turn_to_ball() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Neck_TurnToBall* _msg = _internal_mutable_neck_turn_to_ball();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.neck_turn_to_ball)
  return _msg;
}

// .protos.Neck_TurnToGoalieOrScan neck_turn_to_goalie_or_scan = 46;
inline bool PlayerAction::has_neck_turn_to_goalie_or_scan() const {
  return action_case() == kNeckTurnToGoalieOrScan;
}
inline bool PlayerAction::_internal_has_neck_turn_to_goalie_or_scan() const {
  return action_case() == kNeckTurnToGoalieOrScan;
}
inline void PlayerAction::set_has_neck_turn_to_goalie_or_scan() {
  _impl_._oneof_case_[0] = kNeckTurnToGoalieOrScan;
}
inline void PlayerAction::clear_neck_turn_to_goalie_or_scan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kNeckTurnToGoalieOrScan) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.neck_turn_to_goalie_or_scan_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToGoalieOrScan* PlayerAction::release_neck_turn_to_goalie_or_scan() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.neck_turn_to_goalie_or_scan)
  if (action_case() == kNeckTurnToGoalieOrScan) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_goalie_or_scan_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_goalie_or_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToGoalieOrScan& PlayerAction::_internal_neck_turn_to_goalie_or_scan() const {
  return action_case() == kNeckTurnToGoalieOrScan ? *_impl_.action_.neck_turn_to_goalie_or_scan_ : reinterpret_cast<::protos::Neck_TurnToGoalieOrScan&>(::protos::_Neck_TurnToGoalieOrScan_default_instance_);
}
inline const ::protos::Neck_TurnToGoalieOrScan& PlayerAction::neck_turn_to_goalie_or_scan() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.neck_turn_to_goalie_or_scan)
  return _internal_neck_turn_to_goalie_or_scan();
}
inline ::protos::Neck_TurnToGoalieOrScan* PlayerAction::unsafe_arena_release_neck_turn_to_goalie_or_scan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.neck_turn_to_goalie_or_scan)
  if (action_case() == kNeckTurnToGoalieOrScan) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_goalie_or_scan_;
    _impl_.action_.neck_turn_to_goalie_or_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_neck_turn_to_goalie_or_scan(::protos::Neck_TurnToGoalieOrScan* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_neck_turn_to_goalie_or_scan();
    _impl_.action_.neck_turn_to_goalie_or_scan_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.neck_turn_to_goalie_or_scan)
}
inline ::protos::Neck_TurnToGoalieOrScan* PlayerAction::_internal_mutable_neck_turn_to_goalie_or_scan() {
  if (action_case() != kNeckTurnToGoalieOrScan) {
    clear_action();
    set_has_neck_turn_to_goalie_or_scan();
    _impl_.action_.neck_turn_to_goalie_or_scan_ = CreateMaybeMessage<::protos::Neck_TurnToGoalieOrScan>(GetArena());
  }
  return _impl_.action_.neck_turn_to_goalie_or_scan_;
}
inline ::protos::Neck_TurnToGoalieOrScan* PlayerAction::mutable_neck_turn_to_goalie_or_scan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Neck_TurnToGoalieOrScan* _msg = _internal_mutable_neck_turn_to_goalie_or_scan();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.neck_turn_to_goalie_or_scan)
  return _msg;
}

// .protos.Neck_TurnToLowConfTeammate neck_turn_to_low_conf_teammate = 47;
inline bool PlayerAction::has_neck_turn_to_low_conf_teammate() const {
  return action_case() == kNeckTurnToLowConfTeammate;
}
inline bool PlayerAction::_internal_has_neck_turn_to_low_conf_teammate() const {
  return action_case() == kNeckTurnToLowConfTeammate;
}
inline void PlayerAction::set_has_neck_turn_to_low_conf_teammate() {
  _impl_._oneof_case_[0] = kNeckTurnToLowConfTeammate;
}
inline void PlayerAction::clear_neck_turn_to_low_conf_teammate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kNeckTurnToLowConfTeammate) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.neck_turn_to_low_conf_teammate_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToLowConfTeammate* PlayerAction::release_neck_turn_to_low_conf_teammate() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.neck_turn_to_low_conf_teammate)
  if (action_case() == kNeckTurnToLowConfTeammate) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_low_conf_teammate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_low_conf_teammate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToLowConfTeammate& PlayerAction::_internal_neck_turn_to_low_conf_teammate() const {
  return action_case() == kNeckTurnToLowConfTeammate ? *_impl_.action_.neck_turn_to_low_conf_teammate_ : reinterpret_cast<::protos::Neck_TurnToLowConfTeammate&>(::protos::_Neck_TurnToLowConfTeammate_default_instance_);
}
inline const ::protos::Neck_TurnToLowConfTeammate& PlayerAction::neck_turn_to_low_conf_teammate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.neck_turn_to_low_conf_teammate)
  return _internal_neck_turn_to_low_conf_teammate();
}
inline ::protos::Neck_TurnToLowConfTeammate* PlayerAction::unsafe_arena_release_neck_turn_to_low_conf_teammate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.neck_turn_to_low_conf_teammate)
  if (action_case() == kNeckTurnToLowConfTeammate) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_low_conf_teammate_;
    _impl_.action_.neck_turn_to_low_conf_teammate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_neck_turn_to_low_conf_teammate(::protos::Neck_TurnToLowConfTeammate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_neck_turn_to_low_conf_teammate();
    _impl_.action_.neck_turn_to_low_conf_teammate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.neck_turn_to_low_conf_teammate)
}
inline ::protos::Neck_TurnToLowConfTeammate* PlayerAction::_internal_mutable_neck_turn_to_low_conf_teammate() {
  if (action_case() != kNeckTurnToLowConfTeammate) {
    clear_action();
    set_has_neck_turn_to_low_conf_teammate();
    _impl_.action_.neck_turn_to_low_conf_teammate_ = CreateMaybeMessage<::protos::Neck_TurnToLowConfTeammate>(GetArena());
  }
  return _impl_.action_.neck_turn_to_low_conf_teammate_;
}
inline ::protos::Neck_TurnToLowConfTeammate* PlayerAction::mutable_neck_turn_to_low_conf_teammate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Neck_TurnToLowConfTeammate* _msg = _internal_mutable_neck_turn_to_low_conf_teammate();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.neck_turn_to_low_conf_teammate)
  return _msg;
}

// .protos.Neck_TurnToPlayerOrScan neck_turn_to_player_or_scan = 48;
inline bool PlayerAction::has_neck_turn_to_player_or_scan() const {
  return action_case() == kNeckTurnToPlayerOrScan;
}
inline bool PlayerAction::_internal_has_neck_turn_to_player_or_scan() const {
  return action_case() == kNeckTurnToPlayerOrScan;
}
inline void PlayerAction::set_has_neck_turn_to_player_or_scan() {
  _impl_._oneof_case_[0] = kNeckTurnToPlayerOrScan;
}
inline void PlayerAction::clear_neck_turn_to_player_or_scan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kNeckTurnToPlayerOrScan) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.neck_turn_to_player_or_scan_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToPlayerOrScan* PlayerAction::release_neck_turn_to_player_or_scan() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.neck_turn_to_player_or_scan)
  if (action_case() == kNeckTurnToPlayerOrScan) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_player_or_scan_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_player_or_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToPlayerOrScan& PlayerAction::_internal_neck_turn_to_player_or_scan() const {
  return action_case() == kNeckTurnToPlayerOrScan ? *_impl_.action_.neck_turn_to_player_or_scan_ : reinterpret_cast<::protos::Neck_TurnToPlayerOrScan&>(::protos::_Neck_TurnToPlayerOrScan_default_instance_);
}
inline const ::protos::Neck_TurnToPlayerOrScan& PlayerAction::neck_turn_to_player_or_scan() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.neck_turn_to_player_or_scan)
  return _internal_neck_turn_to_player_or_scan();
}
inline ::protos::Neck_TurnToPlayerOrScan* PlayerAction::unsafe_arena_release_neck_turn_to_player_or_scan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.neck_turn_to_player_or_scan)
  if (action_case() == kNeckTurnToPlayerOrScan) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_player_or_scan_;
    _impl_.action_.neck_turn_to_player_or_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_neck_turn_to_player_or_scan(::protos::Neck_TurnToPlayerOrScan* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_neck_turn_to_player_or_scan();
    _impl_.action_.neck_turn_to_player_or_scan_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.neck_turn_to_player_or_scan)
}
inline ::protos::Neck_TurnToPlayerOrScan* PlayerAction::_internal_mutable_neck_turn_to_player_or_scan() {
  if (action_case() != kNeckTurnToPlayerOrScan) {
    clear_action();
    set_has_neck_turn_to_player_or_scan();
    _impl_.action_.neck_turn_to_player_or_scan_ = CreateMaybeMessage<::protos::Neck_TurnToPlayerOrScan>(GetArena());
  }
  return _impl_.action_.neck_turn_to_player_or_scan_;
}
inline ::protos::Neck_TurnToPlayerOrScan* PlayerAction::mutable_neck_turn_to_player_or_scan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Neck_TurnToPlayerOrScan* _msg = _internal_mutable_neck_turn_to_player_or_scan();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.neck_turn_to_player_or_scan)
  return _msg;
}

// .protos.Neck_TurnToPoint neck_turn_to_point = 49;
inline bool PlayerAction::has_neck_turn_to_point() const {
  return action_case() == kNeckTurnToPoint;
}
inline bool PlayerAction::_internal_has_neck_turn_to_point() const {
  return action_case() == kNeckTurnToPoint;
}
inline void PlayerAction::set_has_neck_turn_to_point() {
  _impl_._oneof_case_[0] = kNeckTurnToPoint;
}
inline void PlayerAction::clear_neck_turn_to_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kNeckTurnToPoint) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.neck_turn_to_point_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToPoint* PlayerAction::release_neck_turn_to_point() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.neck_turn_to_point)
  if (action_case() == kNeckTurnToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_point_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToPoint& PlayerAction::_internal_neck_turn_to_point() const {
  return action_case() == kNeckTurnToPoint ? *_impl_.action_.neck_turn_to_point_ : reinterpret_cast<::protos::Neck_TurnToPoint&>(::protos::_Neck_TurnToPoint_default_instance_);
}
inline const ::protos::Neck_TurnToPoint& PlayerAction::neck_turn_to_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.neck_turn_to_point)
  return _internal_neck_turn_to_point();
}
inline ::protos::Neck_TurnToPoint* PlayerAction::unsafe_arena_release_neck_turn_to_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.neck_turn_to_point)
  if (action_case() == kNeckTurnToPoint) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_point_;
    _impl_.action_.neck_turn_to_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_neck_turn_to_point(::protos::Neck_TurnToPoint* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_neck_turn_to_point();
    _impl_.action_.neck_turn_to_point_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.neck_turn_to_point)
}
inline ::protos::Neck_TurnToPoint* PlayerAction::_internal_mutable_neck_turn_to_point() {
  if (action_case() != kNeckTurnToPoint) {
    clear_action();
    set_has_neck_turn_to_point();
    _impl_.action_.neck_turn_to_point_ = CreateMaybeMessage<::protos::Neck_TurnToPoint>(GetArena());
  }
  return _impl_.action_.neck_turn_to_point_;
}
inline ::protos::Neck_TurnToPoint* PlayerAction::mutable_neck_turn_to_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Neck_TurnToPoint* _msg = _internal_mutable_neck_turn_to_point();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.neck_turn_to_point)
  return _msg;
}

// .protos.Neck_TurnToRelative neck_turn_to_relative = 50;
inline bool PlayerAction::has_neck_turn_to_relative() const {
  return action_case() == kNeckTurnToRelative;
}
inline bool PlayerAction::_internal_has_neck_turn_to_relative() const {
  return action_case() == kNeckTurnToRelative;
}
inline void PlayerAction::set_has_neck_turn_to_relative() {
  _impl_._oneof_case_[0] = kNeckTurnToRelative;
}
inline void PlayerAction::clear_neck_turn_to_relative() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kNeckTurnToRelative) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.neck_turn_to_relative_;
    }
    clear_has_action();
  }
}
inline ::protos::Neck_TurnToRelative* PlayerAction::release_neck_turn_to_relative() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.neck_turn_to_relative)
  if (action_case() == kNeckTurnToRelative) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_relative_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.neck_turn_to_relative_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::Neck_TurnToRelative& PlayerAction::_internal_neck_turn_to_relative() const {
  return action_case() == kNeckTurnToRelative ? *_impl_.action_.neck_turn_to_relative_ : reinterpret_cast<::protos::Neck_TurnToRelative&>(::protos::_Neck_TurnToRelative_default_instance_);
}
inline const ::protos::Neck_TurnToRelative& PlayerAction::neck_turn_to_relative() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.neck_turn_to_relative)
  return _internal_neck_turn_to_relative();
}
inline ::protos::Neck_TurnToRelative* PlayerAction::unsafe_arena_release_neck_turn_to_relative() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.neck_turn_to_relative)
  if (action_case() == kNeckTurnToRelative) {
    clear_has_action();
    auto* temp = _impl_.action_.neck_turn_to_relative_;
    _impl_.action_.neck_turn_to_relative_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_neck_turn_to_relative(::protos::Neck_TurnToRelative* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_neck_turn_to_relative();
    _impl_.action_.neck_turn_to_relative_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.neck_turn_to_relative)
}
inline ::protos::Neck_TurnToRelative* PlayerAction::_internal_mutable_neck_turn_to_relative() {
  if (action_case() != kNeckTurnToRelative) {
    clear_action();
    set_has_neck_turn_to_relative();
    _impl_.action_.neck_turn_to_relative_ = CreateMaybeMessage<::protos::Neck_TurnToRelative>(GetArena());
  }
  return _impl_.action_.neck_turn_to_relative_;
}
inline ::protos::Neck_TurnToRelative* PlayerAction::mutable_neck_turn_to_relative() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Neck_TurnToRelative* _msg = _internal_mutable_neck_turn_to_relative();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.neck_turn_to_relative)
  return _msg;
}

// .protos.View_ChangeWidth view_change_width = 51;
inline bool PlayerAction::has_view_change_width() const {
  return action_case() == kViewChangeWidth;
}
inline bool PlayerAction::_internal_has_view_change_width() const {
  return action_case() == kViewChangeWidth;
}
inline void PlayerAction::set_has_view_change_width() {
  _impl_._oneof_case_[0] = kViewChangeWidth;
}
inline void PlayerAction::clear_view_change_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kViewChangeWidth) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.view_change_width_;
    }
    clear_has_action();
  }
}
inline ::protos::View_ChangeWidth* PlayerAction::release_view_change_width() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.view_change_width)
  if (action_case() == kViewChangeWidth) {
    clear_has_action();
    auto* temp = _impl_.action_.view_change_width_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.view_change_width_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::View_ChangeWidth& PlayerAction::_internal_view_change_width() const {
  return action_case() == kViewChangeWidth ? *_impl_.action_.view_change_width_ : reinterpret_cast<::protos::View_ChangeWidth&>(::protos::_View_ChangeWidth_default_instance_);
}
inline const ::protos::View_ChangeWidth& PlayerAction::view_change_width() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.view_change_width)
  return _internal_view_change_width();
}
inline ::protos::View_ChangeWidth* PlayerAction::unsafe_arena_release_view_change_width() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.view_change_width)
  if (action_case() == kViewChangeWidth) {
    clear_has_action();
    auto* temp = _impl_.action_.view_change_width_;
    _impl_.action_.view_change_width_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_view_change_width(::protos::View_ChangeWidth* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_view_change_width();
    _impl_.action_.view_change_width_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.view_change_width)
}
inline ::protos::View_ChangeWidth* PlayerAction::_internal_mutable_view_change_width() {
  if (action_case() != kViewChangeWidth) {
    clear_action();
    set_has_view_change_width();
    _impl_.action_.view_change_width_ = CreateMaybeMessage<::protos::View_ChangeWidth>(GetArena());
  }
  return _impl_.action_.view_change_width_;
}
inline ::protos::View_ChangeWidth* PlayerAction::mutable_view_change_width() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::View_ChangeWidth* _msg = _internal_mutable_view_change_width();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.view_change_width)
  return _msg;
}

// .protos.View_Normal view_normal = 52;
inline bool PlayerAction::has_view_normal() const {
  return action_case() == kViewNormal;
}
inline bool PlayerAction::_internal_has_view_normal() const {
  return action_case() == kViewNormal;
}
inline void PlayerAction::set_has_view_normal() {
  _impl_._oneof_case_[0] = kViewNormal;
}
inline void PlayerAction::clear_view_normal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kViewNormal) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.view_normal_;
    }
    clear_has_action();
  }
}
inline ::protos::View_Normal* PlayerAction::release_view_normal() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.view_normal)
  if (action_case() == kViewNormal) {
    clear_has_action();
    auto* temp = _impl_.action_.view_normal_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.view_normal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::View_Normal& PlayerAction::_internal_view_normal() const {
  return action_case() == kViewNormal ? *_impl_.action_.view_normal_ : reinterpret_cast<::protos::View_Normal&>(::protos::_View_Normal_default_instance_);
}
inline const ::protos::View_Normal& PlayerAction::view_normal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.view_normal)
  return _internal_view_normal();
}
inline ::protos::View_Normal* PlayerAction::unsafe_arena_release_view_normal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.view_normal)
  if (action_case() == kViewNormal) {
    clear_has_action();
    auto* temp = _impl_.action_.view_normal_;
    _impl_.action_.view_normal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_view_normal(::protos::View_Normal* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_view_normal();
    _impl_.action_.view_normal_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.view_normal)
}
inline ::protos::View_Normal* PlayerAction::_internal_mutable_view_normal() {
  if (action_case() != kViewNormal) {
    clear_action();
    set_has_view_normal();
    _impl_.action_.view_normal_ = CreateMaybeMessage<::protos::View_Normal>(GetArena());
  }
  return _impl_.action_.view_normal_;
}
inline ::protos::View_Normal* PlayerAction::mutable_view_normal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::View_Normal* _msg = _internal_mutable_view_normal();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.view_normal)
  return _msg;
}

// .protos.View_Synch view_synch = 53;
inline bool PlayerAction::has_view_synch() const {
  return action_case() == kViewSynch;
}
inline bool PlayerAction::_internal_has_view_synch() const {
  return action_case() == kViewSynch;
}
inline void PlayerAction::set_has_view_synch() {
  _impl_._oneof_case_[0] = kViewSynch;
}
inline void PlayerAction::clear_view_synch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kViewSynch) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.view_synch_;
    }
    clear_has_action();
  }
}
inline ::protos::View_Synch* PlayerAction::release_view_synch() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.view_synch)
  if (action_case() == kViewSynch) {
    clear_has_action();
    auto* temp = _impl_.action_.view_synch_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.view_synch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::View_Synch& PlayerAction::_internal_view_synch() const {
  return action_case() == kViewSynch ? *_impl_.action_.view_synch_ : reinterpret_cast<::protos::View_Synch&>(::protos::_View_Synch_default_instance_);
}
inline const ::protos::View_Synch& PlayerAction::view_synch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.view_synch)
  return _internal_view_synch();
}
inline ::protos::View_Synch* PlayerAction::unsafe_arena_release_view_synch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.view_synch)
  if (action_case() == kViewSynch) {
    clear_has_action();
    auto* temp = _impl_.action_.view_synch_;
    _impl_.action_.view_synch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_view_synch(::protos::View_Synch* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_view_synch();
    _impl_.action_.view_synch_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.view_synch)
}
inline ::protos::View_Synch* PlayerAction::_internal_mutable_view_synch() {
  if (action_case() != kViewSynch) {
    clear_action();
    set_has_view_synch();
    _impl_.action_.view_synch_ = CreateMaybeMessage<::protos::View_Synch>(GetArena());
  }
  return _impl_.action_.view_synch_;
}
inline ::protos::View_Synch* PlayerAction::mutable_view_synch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::View_Synch* _msg = _internal_mutable_view_synch();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.view_synch)
  return _msg;
}

// .protos.View_Wide view_wide = 54;
inline bool PlayerAction::has_view_wide() const {
  return action_case() == kViewWide;
}
inline bool PlayerAction::_internal_has_view_wide() const {
  return action_case() == kViewWide;
}
inline void PlayerAction::set_has_view_wide() {
  _impl_._oneof_case_[0] = kViewWide;
}
inline void PlayerAction::clear_view_wide() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kViewWide) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.view_wide_;
    }
    clear_has_action();
  }
}
inline ::protos::View_Wide* PlayerAction::release_view_wide() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.view_wide)
  if (action_case() == kViewWide) {
    clear_has_action();
    auto* temp = _impl_.action_.view_wide_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.view_wide_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::View_Wide& PlayerAction::_internal_view_wide() const {
  return action_case() == kViewWide ? *_impl_.action_.view_wide_ : reinterpret_cast<::protos::View_Wide&>(::protos::_View_Wide_default_instance_);
}
inline const ::protos::View_Wide& PlayerAction::view_wide() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.view_wide)
  return _internal_view_wide();
}
inline ::protos::View_Wide* PlayerAction::unsafe_arena_release_view_wide() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.view_wide)
  if (action_case() == kViewWide) {
    clear_has_action();
    auto* temp = _impl_.action_.view_wide_;
    _impl_.action_.view_wide_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_view_wide(::protos::View_Wide* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_view_wide();
    _impl_.action_.view_wide_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.view_wide)
}
inline ::protos::View_Wide* PlayerAction::_internal_mutable_view_wide() {
  if (action_case() != kViewWide) {
    clear_action();
    set_has_view_wide();
    _impl_.action_.view_wide_ = CreateMaybeMessage<::protos::View_Wide>(GetArena());
  }
  return _impl_.action_.view_wide_;
}
inline ::protos::View_Wide* PlayerAction::mutable_view_wide() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::View_Wide* _msg = _internal_mutable_view_wide();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.view_wide)
  return _msg;
}

// .protos.HeliosGoalie helios_goalie = 55;
inline bool PlayerAction::has_helios_goalie() const {
  return action_case() == kHeliosGoalie;
}
inline bool PlayerAction::_internal_has_helios_goalie() const {
  return action_case() == kHeliosGoalie;
}
inline void PlayerAction::set_has_helios_goalie() {
  _impl_._oneof_case_[0] = kHeliosGoalie;
}
inline void PlayerAction::clear_helios_goalie() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kHeliosGoalie) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.helios_goalie_;
    }
    clear_has_action();
  }
}
inline ::protos::HeliosGoalie* PlayerAction::release_helios_goalie() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.helios_goalie)
  if (action_case() == kHeliosGoalie) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_goalie_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.helios_goalie_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::HeliosGoalie& PlayerAction::_internal_helios_goalie() const {
  return action_case() == kHeliosGoalie ? *_impl_.action_.helios_goalie_ : reinterpret_cast<::protos::HeliosGoalie&>(::protos::_HeliosGoalie_default_instance_);
}
inline const ::protos::HeliosGoalie& PlayerAction::helios_goalie() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.helios_goalie)
  return _internal_helios_goalie();
}
inline ::protos::HeliosGoalie* PlayerAction::unsafe_arena_release_helios_goalie() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.helios_goalie)
  if (action_case() == kHeliosGoalie) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_goalie_;
    _impl_.action_.helios_goalie_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_helios_goalie(::protos::HeliosGoalie* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_helios_goalie();
    _impl_.action_.helios_goalie_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.helios_goalie)
}
inline ::protos::HeliosGoalie* PlayerAction::_internal_mutable_helios_goalie() {
  if (action_case() != kHeliosGoalie) {
    clear_action();
    set_has_helios_goalie();
    _impl_.action_.helios_goalie_ = CreateMaybeMessage<::protos::HeliosGoalie>(GetArena());
  }
  return _impl_.action_.helios_goalie_;
}
inline ::protos::HeliosGoalie* PlayerAction::mutable_helios_goalie() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::HeliosGoalie* _msg = _internal_mutable_helios_goalie();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.helios_goalie)
  return _msg;
}

// .protos.HeliosGoalieMove helios_goalie_move = 56;
inline bool PlayerAction::has_helios_goalie_move() const {
  return action_case() == kHeliosGoalieMove;
}
inline bool PlayerAction::_internal_has_helios_goalie_move() const {
  return action_case() == kHeliosGoalieMove;
}
inline void PlayerAction::set_has_helios_goalie_move() {
  _impl_._oneof_case_[0] = kHeliosGoalieMove;
}
inline void PlayerAction::clear_helios_goalie_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kHeliosGoalieMove) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.helios_goalie_move_;
    }
    clear_has_action();
  }
}
inline ::protos::HeliosGoalieMove* PlayerAction::release_helios_goalie_move() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.helios_goalie_move)
  if (action_case() == kHeliosGoalieMove) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_goalie_move_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.helios_goalie_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::HeliosGoalieMove& PlayerAction::_internal_helios_goalie_move() const {
  return action_case() == kHeliosGoalieMove ? *_impl_.action_.helios_goalie_move_ : reinterpret_cast<::protos::HeliosGoalieMove&>(::protos::_HeliosGoalieMove_default_instance_);
}
inline const ::protos::HeliosGoalieMove& PlayerAction::helios_goalie_move() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.helios_goalie_move)
  return _internal_helios_goalie_move();
}
inline ::protos::HeliosGoalieMove* PlayerAction::unsafe_arena_release_helios_goalie_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.helios_goalie_move)
  if (action_case() == kHeliosGoalieMove) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_goalie_move_;
    _impl_.action_.helios_goalie_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_helios_goalie_move(::protos::HeliosGoalieMove* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_helios_goalie_move();
    _impl_.action_.helios_goalie_move_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.helios_goalie_move)
}
inline ::protos::HeliosGoalieMove* PlayerAction::_internal_mutable_helios_goalie_move() {
  if (action_case() != kHeliosGoalieMove) {
    clear_action();
    set_has_helios_goalie_move();
    _impl_.action_.helios_goalie_move_ = CreateMaybeMessage<::protos::HeliosGoalieMove>(GetArena());
  }
  return _impl_.action_.helios_goalie_move_;
}
inline ::protos::HeliosGoalieMove* PlayerAction::mutable_helios_goalie_move() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::HeliosGoalieMove* _msg = _internal_mutable_helios_goalie_move();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.helios_goalie_move)
  return _msg;
}

// .protos.HeliosGoalieKick helios_goalie_kick = 57;
inline bool PlayerAction::has_helios_goalie_kick() const {
  return action_case() == kHeliosGoalieKick;
}
inline bool PlayerAction::_internal_has_helios_goalie_kick() const {
  return action_case() == kHeliosGoalieKick;
}
inline void PlayerAction::set_has_helios_goalie_kick() {
  _impl_._oneof_case_[0] = kHeliosGoalieKick;
}
inline void PlayerAction::clear_helios_goalie_kick() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kHeliosGoalieKick) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.helios_goalie_kick_;
    }
    clear_has_action();
  }
}
inline ::protos::HeliosGoalieKick* PlayerAction::release_helios_goalie_kick() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.helios_goalie_kick)
  if (action_case() == kHeliosGoalieKick) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_goalie_kick_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.helios_goalie_kick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::HeliosGoalieKick& PlayerAction::_internal_helios_goalie_kick() const {
  return action_case() == kHeliosGoalieKick ? *_impl_.action_.helios_goalie_kick_ : reinterpret_cast<::protos::HeliosGoalieKick&>(::protos::_HeliosGoalieKick_default_instance_);
}
inline const ::protos::HeliosGoalieKick& PlayerAction::helios_goalie_kick() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.helios_goalie_kick)
  return _internal_helios_goalie_kick();
}
inline ::protos::HeliosGoalieKick* PlayerAction::unsafe_arena_release_helios_goalie_kick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.helios_goalie_kick)
  if (action_case() == kHeliosGoalieKick) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_goalie_kick_;
    _impl_.action_.helios_goalie_kick_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_helios_goalie_kick(::protos::HeliosGoalieKick* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_helios_goalie_kick();
    _impl_.action_.helios_goalie_kick_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.helios_goalie_kick)
}
inline ::protos::HeliosGoalieKick* PlayerAction::_internal_mutable_helios_goalie_kick() {
  if (action_case() != kHeliosGoalieKick) {
    clear_action();
    set_has_helios_goalie_kick();
    _impl_.action_.helios_goalie_kick_ = CreateMaybeMessage<::protos::HeliosGoalieKick>(GetArena());
  }
  return _impl_.action_.helios_goalie_kick_;
}
inline ::protos::HeliosGoalieKick* PlayerAction::mutable_helios_goalie_kick() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::HeliosGoalieKick* _msg = _internal_mutable_helios_goalie_kick();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.helios_goalie_kick)
  return _msg;
}

// .protos.HeliosShoot helios_shoot = 58;
inline bool PlayerAction::has_helios_shoot() const {
  return action_case() == kHeliosShoot;
}
inline bool PlayerAction::_internal_has_helios_shoot() const {
  return action_case() == kHeliosShoot;
}
inline void PlayerAction::set_has_helios_shoot() {
  _impl_._oneof_case_[0] = kHeliosShoot;
}
inline void PlayerAction::clear_helios_shoot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kHeliosShoot) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.helios_shoot_;
    }
    clear_has_action();
  }
}
inline ::protos::HeliosShoot* PlayerAction::release_helios_shoot() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.helios_shoot)
  if (action_case() == kHeliosShoot) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_shoot_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.helios_shoot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::HeliosShoot& PlayerAction::_internal_helios_shoot() const {
  return action_case() == kHeliosShoot ? *_impl_.action_.helios_shoot_ : reinterpret_cast<::protos::HeliosShoot&>(::protos::_HeliosShoot_default_instance_);
}
inline const ::protos::HeliosShoot& PlayerAction::helios_shoot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.helios_shoot)
  return _internal_helios_shoot();
}
inline ::protos::HeliosShoot* PlayerAction::unsafe_arena_release_helios_shoot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.helios_shoot)
  if (action_case() == kHeliosShoot) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_shoot_;
    _impl_.action_.helios_shoot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_helios_shoot(::protos::HeliosShoot* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_helios_shoot();
    _impl_.action_.helios_shoot_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.helios_shoot)
}
inline ::protos::HeliosShoot* PlayerAction::_internal_mutable_helios_shoot() {
  if (action_case() != kHeliosShoot) {
    clear_action();
    set_has_helios_shoot();
    _impl_.action_.helios_shoot_ = CreateMaybeMessage<::protos::HeliosShoot>(GetArena());
  }
  return _impl_.action_.helios_shoot_;
}
inline ::protos::HeliosShoot* PlayerAction::mutable_helios_shoot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::HeliosShoot* _msg = _internal_mutable_helios_shoot();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.helios_shoot)
  return _msg;
}

// .protos.HeliosChainAction helios_chain_action = 59;
inline bool PlayerAction::has_helios_chain_action() const {
  return action_case() == kHeliosChainAction;
}
inline bool PlayerAction::_internal_has_helios_chain_action() const {
  return action_case() == kHeliosChainAction;
}
inline void PlayerAction::set_has_helios_chain_action() {
  _impl_._oneof_case_[0] = kHeliosChainAction;
}
inline void PlayerAction::clear_helios_chain_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kHeliosChainAction) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.helios_chain_action_;
    }
    clear_has_action();
  }
}
inline ::protos::HeliosChainAction* PlayerAction::release_helios_chain_action() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.helios_chain_action)
  if (action_case() == kHeliosChainAction) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_chain_action_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.helios_chain_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::HeliosChainAction& PlayerAction::_internal_helios_chain_action() const {
  return action_case() == kHeliosChainAction ? *_impl_.action_.helios_chain_action_ : reinterpret_cast<::protos::HeliosChainAction&>(::protos::_HeliosChainAction_default_instance_);
}
inline const ::protos::HeliosChainAction& PlayerAction::helios_chain_action() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.helios_chain_action)
  return _internal_helios_chain_action();
}
inline ::protos::HeliosChainAction* PlayerAction::unsafe_arena_release_helios_chain_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.helios_chain_action)
  if (action_case() == kHeliosChainAction) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_chain_action_;
    _impl_.action_.helios_chain_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_helios_chain_action(::protos::HeliosChainAction* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_helios_chain_action();
    _impl_.action_.helios_chain_action_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.helios_chain_action)
}
inline ::protos::HeliosChainAction* PlayerAction::_internal_mutable_helios_chain_action() {
  if (action_case() != kHeliosChainAction) {
    clear_action();
    set_has_helios_chain_action();
    _impl_.action_.helios_chain_action_ = CreateMaybeMessage<::protos::HeliosChainAction>(GetArena());
  }
  return _impl_.action_.helios_chain_action_;
}
inline ::protos::HeliosChainAction* PlayerAction::mutable_helios_chain_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::HeliosChainAction* _msg = _internal_mutable_helios_chain_action();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.helios_chain_action)
  return _msg;
}

// .protos.HeliosBasicOffensive helios_basic_offensive = 60;
inline bool PlayerAction::has_helios_basic_offensive() const {
  return action_case() == kHeliosBasicOffensive;
}
inline bool PlayerAction::_internal_has_helios_basic_offensive() const {
  return action_case() == kHeliosBasicOffensive;
}
inline void PlayerAction::set_has_helios_basic_offensive() {
  _impl_._oneof_case_[0] = kHeliosBasicOffensive;
}
inline void PlayerAction::clear_helios_basic_offensive() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kHeliosBasicOffensive) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.helios_basic_offensive_;
    }
    clear_has_action();
  }
}
inline ::protos::HeliosBasicOffensive* PlayerAction::release_helios_basic_offensive() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.helios_basic_offensive)
  if (action_case() == kHeliosBasicOffensive) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_basic_offensive_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.helios_basic_offensive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::HeliosBasicOffensive& PlayerAction::_internal_helios_basic_offensive() const {
  return action_case() == kHeliosBasicOffensive ? *_impl_.action_.helios_basic_offensive_ : reinterpret_cast<::protos::HeliosBasicOffensive&>(::protos::_HeliosBasicOffensive_default_instance_);
}
inline const ::protos::HeliosBasicOffensive& PlayerAction::helios_basic_offensive() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.helios_basic_offensive)
  return _internal_helios_basic_offensive();
}
inline ::protos::HeliosBasicOffensive* PlayerAction::unsafe_arena_release_helios_basic_offensive() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.helios_basic_offensive)
  if (action_case() == kHeliosBasicOffensive) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_basic_offensive_;
    _impl_.action_.helios_basic_offensive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_helios_basic_offensive(::protos::HeliosBasicOffensive* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_helios_basic_offensive();
    _impl_.action_.helios_basic_offensive_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.helios_basic_offensive)
}
inline ::protos::HeliosBasicOffensive* PlayerAction::_internal_mutable_helios_basic_offensive() {
  if (action_case() != kHeliosBasicOffensive) {
    clear_action();
    set_has_helios_basic_offensive();
    _impl_.action_.helios_basic_offensive_ = CreateMaybeMessage<::protos::HeliosBasicOffensive>(GetArena());
  }
  return _impl_.action_.helios_basic_offensive_;
}
inline ::protos::HeliosBasicOffensive* PlayerAction::mutable_helios_basic_offensive() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::HeliosBasicOffensive* _msg = _internal_mutable_helios_basic_offensive();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.helios_basic_offensive)
  return _msg;
}

// .protos.HeliosBasicMove helios_basic_move = 61;
inline bool PlayerAction::has_helios_basic_move() const {
  return action_case() == kHeliosBasicMove;
}
inline bool PlayerAction::_internal_has_helios_basic_move() const {
  return action_case() == kHeliosBasicMove;
}
inline void PlayerAction::set_has_helios_basic_move() {
  _impl_._oneof_case_[0] = kHeliosBasicMove;
}
inline void PlayerAction::clear_helios_basic_move() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kHeliosBasicMove) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.helios_basic_move_;
    }
    clear_has_action();
  }
}
inline ::protos::HeliosBasicMove* PlayerAction::release_helios_basic_move() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.helios_basic_move)
  if (action_case() == kHeliosBasicMove) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_basic_move_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.helios_basic_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::HeliosBasicMove& PlayerAction::_internal_helios_basic_move() const {
  return action_case() == kHeliosBasicMove ? *_impl_.action_.helios_basic_move_ : reinterpret_cast<::protos::HeliosBasicMove&>(::protos::_HeliosBasicMove_default_instance_);
}
inline const ::protos::HeliosBasicMove& PlayerAction::helios_basic_move() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.helios_basic_move)
  return _internal_helios_basic_move();
}
inline ::protos::HeliosBasicMove* PlayerAction::unsafe_arena_release_helios_basic_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.helios_basic_move)
  if (action_case() == kHeliosBasicMove) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_basic_move_;
    _impl_.action_.helios_basic_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_helios_basic_move(::protos::HeliosBasicMove* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_helios_basic_move();
    _impl_.action_.helios_basic_move_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.helios_basic_move)
}
inline ::protos::HeliosBasicMove* PlayerAction::_internal_mutable_helios_basic_move() {
  if (action_case() != kHeliosBasicMove) {
    clear_action();
    set_has_helios_basic_move();
    _impl_.action_.helios_basic_move_ = CreateMaybeMessage<::protos::HeliosBasicMove>(GetArena());
  }
  return _impl_.action_.helios_basic_move_;
}
inline ::protos::HeliosBasicMove* PlayerAction::mutable_helios_basic_move() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::HeliosBasicMove* _msg = _internal_mutable_helios_basic_move();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.helios_basic_move)
  return _msg;
}

// .protos.HeliosSetPlay helios_set_play = 62;
inline bool PlayerAction::has_helios_set_play() const {
  return action_case() == kHeliosSetPlay;
}
inline bool PlayerAction::_internal_has_helios_set_play() const {
  return action_case() == kHeliosSetPlay;
}
inline void PlayerAction::set_has_helios_set_play() {
  _impl_._oneof_case_[0] = kHeliosSetPlay;
}
inline void PlayerAction::clear_helios_set_play() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kHeliosSetPlay) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.helios_set_play_;
    }
    clear_has_action();
  }
}
inline ::protos::HeliosSetPlay* PlayerAction::release_helios_set_play() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.helios_set_play)
  if (action_case() == kHeliosSetPlay) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_set_play_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.helios_set_play_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::HeliosSetPlay& PlayerAction::_internal_helios_set_play() const {
  return action_case() == kHeliosSetPlay ? *_impl_.action_.helios_set_play_ : reinterpret_cast<::protos::HeliosSetPlay&>(::protos::_HeliosSetPlay_default_instance_);
}
inline const ::protos::HeliosSetPlay& PlayerAction::helios_set_play() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.helios_set_play)
  return _internal_helios_set_play();
}
inline ::protos::HeliosSetPlay* PlayerAction::unsafe_arena_release_helios_set_play() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.helios_set_play)
  if (action_case() == kHeliosSetPlay) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_set_play_;
    _impl_.action_.helios_set_play_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_helios_set_play(::protos::HeliosSetPlay* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_helios_set_play();
    _impl_.action_.helios_set_play_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.helios_set_play)
}
inline ::protos::HeliosSetPlay* PlayerAction::_internal_mutable_helios_set_play() {
  if (action_case() != kHeliosSetPlay) {
    clear_action();
    set_has_helios_set_play();
    _impl_.action_.helios_set_play_ = CreateMaybeMessage<::protos::HeliosSetPlay>(GetArena());
  }
  return _impl_.action_.helios_set_play_;
}
inline ::protos::HeliosSetPlay* PlayerAction::mutable_helios_set_play() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::HeliosSetPlay* _msg = _internal_mutable_helios_set_play();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.helios_set_play)
  return _msg;
}

// .protos.HeliosPenalty helios_penalty = 63;
inline bool PlayerAction::has_helios_penalty() const {
  return action_case() == kHeliosPenalty;
}
inline bool PlayerAction::_internal_has_helios_penalty() const {
  return action_case() == kHeliosPenalty;
}
inline void PlayerAction::set_has_helios_penalty() {
  _impl_._oneof_case_[0] = kHeliosPenalty;
}
inline void PlayerAction::clear_helios_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kHeliosPenalty) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.helios_penalty_;
    }
    clear_has_action();
  }
}
inline ::protos::HeliosPenalty* PlayerAction::release_helios_penalty() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.helios_penalty)
  if (action_case() == kHeliosPenalty) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_penalty_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.helios_penalty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::HeliosPenalty& PlayerAction::_internal_helios_penalty() const {
  return action_case() == kHeliosPenalty ? *_impl_.action_.helios_penalty_ : reinterpret_cast<::protos::HeliosPenalty&>(::protos::_HeliosPenalty_default_instance_);
}
inline const ::protos::HeliosPenalty& PlayerAction::helios_penalty() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.helios_penalty)
  return _internal_helios_penalty();
}
inline ::protos::HeliosPenalty* PlayerAction::unsafe_arena_release_helios_penalty() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.helios_penalty)
  if (action_case() == kHeliosPenalty) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_penalty_;
    _impl_.action_.helios_penalty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_helios_penalty(::protos::HeliosPenalty* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_helios_penalty();
    _impl_.action_.helios_penalty_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.helios_penalty)
}
inline ::protos::HeliosPenalty* PlayerAction::_internal_mutable_helios_penalty() {
  if (action_case() != kHeliosPenalty) {
    clear_action();
    set_has_helios_penalty();
    _impl_.action_.helios_penalty_ = CreateMaybeMessage<::protos::HeliosPenalty>(GetArena());
  }
  return _impl_.action_.helios_penalty_;
}
inline ::protos::HeliosPenalty* PlayerAction::mutable_helios_penalty() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::HeliosPenalty* _msg = _internal_mutable_helios_penalty();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.helios_penalty)
  return _msg;
}

// .protos.HeliosCommunicaion helios_communication = 64;
inline bool PlayerAction::has_helios_communication() const {
  return action_case() == kHeliosCommunication;
}
inline bool PlayerAction::_internal_has_helios_communication() const {
  return action_case() == kHeliosCommunication;
}
inline void PlayerAction::set_has_helios_communication() {
  _impl_._oneof_case_[0] = kHeliosCommunication;
}
inline void PlayerAction::clear_helios_communication() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kHeliosCommunication) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.helios_communication_;
    }
    clear_has_action();
  }
}
inline ::protos::HeliosCommunicaion* PlayerAction::release_helios_communication() {
  // @@protoc_insertion_point(field_release:protos.PlayerAction.helios_communication)
  if (action_case() == kHeliosCommunication) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_communication_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.helios_communication_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::HeliosCommunicaion& PlayerAction::_internal_helios_communication() const {
  return action_case() == kHeliosCommunication ? *_impl_.action_.helios_communication_ : reinterpret_cast<::protos::HeliosCommunicaion&>(::protos::_HeliosCommunicaion_default_instance_);
}
inline const ::protos::HeliosCommunicaion& PlayerAction::helios_communication() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerAction.helios_communication)
  return _internal_helios_communication();
}
inline ::protos::HeliosCommunicaion* PlayerAction::unsafe_arena_release_helios_communication() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.PlayerAction.helios_communication)
  if (action_case() == kHeliosCommunication) {
    clear_has_action();
    auto* temp = _impl_.action_.helios_communication_;
    _impl_.action_.helios_communication_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerAction::unsafe_arena_set_allocated_helios_communication(::protos::HeliosCommunicaion* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_helios_communication();
    _impl_.action_.helios_communication_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PlayerAction.helios_communication)
}
inline ::protos::HeliosCommunicaion* PlayerAction::_internal_mutable_helios_communication() {
  if (action_case() != kHeliosCommunication) {
    clear_action();
    set_has_helios_communication();
    _impl_.action_.helios_communication_ = CreateMaybeMessage<::protos::HeliosCommunicaion>(GetArena());
  }
  return _impl_.action_.helios_communication_;
}
inline ::protos::HeliosCommunicaion* PlayerAction::mutable_helios_communication() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::HeliosCommunicaion* _msg = _internal_mutable_helios_communication();
  // @@protoc_insertion_point(field_mutable:protos.PlayerAction.helios_communication)
  return _msg;
}

inline bool PlayerAction::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void PlayerAction::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline PlayerAction::ActionCase PlayerAction::action_case() const {
  return PlayerAction::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlayerActions

// repeated .protos.PlayerAction actions = 1;
inline int PlayerActions::_internal_actions_size() const {
  return _internal_actions().size();
}
inline int PlayerActions::actions_size() const {
  return _internal_actions_size();
}
inline void PlayerActions::clear_actions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.actions_.Clear();
}
inline ::protos::PlayerAction* PlayerActions::mutable_actions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:protos.PlayerActions.actions)
  return _internal_mutable_actions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::protos::PlayerAction>* PlayerActions::mutable_actions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:protos.PlayerActions.actions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_actions();
}
inline const ::protos::PlayerAction& PlayerActions::actions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.PlayerActions.actions)
  return _internal_actions().Get(index);
}
inline ::protos::PlayerAction* PlayerActions::add_actions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::protos::PlayerAction* _add = _internal_mutable_actions()->Add();
  // @@protoc_insertion_point(field_add:protos.PlayerActions.actions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::protos::PlayerAction>& PlayerActions::actions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:protos.PlayerActions.actions)
  return _internal_actions();
}
inline const ::google::protobuf::RepeatedPtrField<::protos::PlayerAction>&
PlayerActions::_internal_actions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.actions_;
}
inline ::google::protobuf::RepeatedPtrField<::protos::PlayerAction>*
PlayerActions::_internal_mutable_actions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.actions_;
}

// -------------------------------------------------------------------

// ChangePlayerType

// int32 uniform_number = 1;
inline void ChangePlayerType::clear_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_ = 0;
}
inline ::int32_t ChangePlayerType::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.ChangePlayerType.uniform_number)
  return _internal_uniform_number();
}
inline void ChangePlayerType::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.ChangePlayerType.uniform_number)
}
inline ::int32_t ChangePlayerType::_internal_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_;
}
inline void ChangePlayerType::_internal_set_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_ = value;
}

// int32 type = 2;
inline void ChangePlayerType::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::int32_t ChangePlayerType::type() const {
  // @@protoc_insertion_point(field_get:protos.ChangePlayerType.type)
  return _internal_type();
}
inline void ChangePlayerType::set_type(::int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protos.ChangePlayerType.type)
}
inline ::int32_t ChangePlayerType::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void ChangePlayerType::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// DoHeliosSubstitute

// -------------------------------------------------------------------

// DoHeliosSayPlayerTypes

// -------------------------------------------------------------------

// CoachAction

// .protos.ChangePlayerType change_player_types = 1;
inline bool CoachAction::has_change_player_types() const {
  return action_case() == kChangePlayerTypes;
}
inline bool CoachAction::_internal_has_change_player_types() const {
  return action_case() == kChangePlayerTypes;
}
inline void CoachAction::set_has_change_player_types() {
  _impl_._oneof_case_[0] = kChangePlayerTypes;
}
inline void CoachAction::clear_change_player_types() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kChangePlayerTypes) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.change_player_types_;
    }
    clear_has_action();
  }
}
inline ::protos::ChangePlayerType* CoachAction::release_change_player_types() {
  // @@protoc_insertion_point(field_release:protos.CoachAction.change_player_types)
  if (action_case() == kChangePlayerTypes) {
    clear_has_action();
    auto* temp = _impl_.action_.change_player_types_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.change_player_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::ChangePlayerType& CoachAction::_internal_change_player_types() const {
  return action_case() == kChangePlayerTypes ? *_impl_.action_.change_player_types_ : reinterpret_cast<::protos::ChangePlayerType&>(::protos::_ChangePlayerType_default_instance_);
}
inline const ::protos::ChangePlayerType& CoachAction::change_player_types() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.CoachAction.change_player_types)
  return _internal_change_player_types();
}
inline ::protos::ChangePlayerType* CoachAction::unsafe_arena_release_change_player_types() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.CoachAction.change_player_types)
  if (action_case() == kChangePlayerTypes) {
    clear_has_action();
    auto* temp = _impl_.action_.change_player_types_;
    _impl_.action_.change_player_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CoachAction::unsafe_arena_set_allocated_change_player_types(::protos::ChangePlayerType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_change_player_types();
    _impl_.action_.change_player_types_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.CoachAction.change_player_types)
}
inline ::protos::ChangePlayerType* CoachAction::_internal_mutable_change_player_types() {
  if (action_case() != kChangePlayerTypes) {
    clear_action();
    set_has_change_player_types();
    _impl_.action_.change_player_types_ = CreateMaybeMessage<::protos::ChangePlayerType>(GetArena());
  }
  return _impl_.action_.change_player_types_;
}
inline ::protos::ChangePlayerType* CoachAction::mutable_change_player_types() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::ChangePlayerType* _msg = _internal_mutable_change_player_types();
  // @@protoc_insertion_point(field_mutable:protos.CoachAction.change_player_types)
  return _msg;
}

// .protos.DoHeliosSubstitute do_helios_substitute = 2;
inline bool CoachAction::has_do_helios_substitute() const {
  return action_case() == kDoHeliosSubstitute;
}
inline bool CoachAction::_internal_has_do_helios_substitute() const {
  return action_case() == kDoHeliosSubstitute;
}
inline void CoachAction::set_has_do_helios_substitute() {
  _impl_._oneof_case_[0] = kDoHeliosSubstitute;
}
inline void CoachAction::clear_do_helios_substitute() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kDoHeliosSubstitute) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.do_helios_substitute_;
    }
    clear_has_action();
  }
}
inline ::protos::DoHeliosSubstitute* CoachAction::release_do_helios_substitute() {
  // @@protoc_insertion_point(field_release:protos.CoachAction.do_helios_substitute)
  if (action_case() == kDoHeliosSubstitute) {
    clear_has_action();
    auto* temp = _impl_.action_.do_helios_substitute_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.do_helios_substitute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DoHeliosSubstitute& CoachAction::_internal_do_helios_substitute() const {
  return action_case() == kDoHeliosSubstitute ? *_impl_.action_.do_helios_substitute_ : reinterpret_cast<::protos::DoHeliosSubstitute&>(::protos::_DoHeliosSubstitute_default_instance_);
}
inline const ::protos::DoHeliosSubstitute& CoachAction::do_helios_substitute() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.CoachAction.do_helios_substitute)
  return _internal_do_helios_substitute();
}
inline ::protos::DoHeliosSubstitute* CoachAction::unsafe_arena_release_do_helios_substitute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.CoachAction.do_helios_substitute)
  if (action_case() == kDoHeliosSubstitute) {
    clear_has_action();
    auto* temp = _impl_.action_.do_helios_substitute_;
    _impl_.action_.do_helios_substitute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CoachAction::unsafe_arena_set_allocated_do_helios_substitute(::protos::DoHeliosSubstitute* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_do_helios_substitute();
    _impl_.action_.do_helios_substitute_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.CoachAction.do_helios_substitute)
}
inline ::protos::DoHeliosSubstitute* CoachAction::_internal_mutable_do_helios_substitute() {
  if (action_case() != kDoHeliosSubstitute) {
    clear_action();
    set_has_do_helios_substitute();
    _impl_.action_.do_helios_substitute_ = CreateMaybeMessage<::protos::DoHeliosSubstitute>(GetArena());
  }
  return _impl_.action_.do_helios_substitute_;
}
inline ::protos::DoHeliosSubstitute* CoachAction::mutable_do_helios_substitute() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::DoHeliosSubstitute* _msg = _internal_mutable_do_helios_substitute();
  // @@protoc_insertion_point(field_mutable:protos.CoachAction.do_helios_substitute)
  return _msg;
}

// .protos.DoHeliosSayPlayerTypes do_helios_say_player_types = 3;
inline bool CoachAction::has_do_helios_say_player_types() const {
  return action_case() == kDoHeliosSayPlayerTypes;
}
inline bool CoachAction::_internal_has_do_helios_say_player_types() const {
  return action_case() == kDoHeliosSayPlayerTypes;
}
inline void CoachAction::set_has_do_helios_say_player_types() {
  _impl_._oneof_case_[0] = kDoHeliosSayPlayerTypes;
}
inline void CoachAction::clear_do_helios_say_player_types() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kDoHeliosSayPlayerTypes) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.do_helios_say_player_types_;
    }
    clear_has_action();
  }
}
inline ::protos::DoHeliosSayPlayerTypes* CoachAction::release_do_helios_say_player_types() {
  // @@protoc_insertion_point(field_release:protos.CoachAction.do_helios_say_player_types)
  if (action_case() == kDoHeliosSayPlayerTypes) {
    clear_has_action();
    auto* temp = _impl_.action_.do_helios_say_player_types_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.do_helios_say_player_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DoHeliosSayPlayerTypes& CoachAction::_internal_do_helios_say_player_types() const {
  return action_case() == kDoHeliosSayPlayerTypes ? *_impl_.action_.do_helios_say_player_types_ : reinterpret_cast<::protos::DoHeliosSayPlayerTypes&>(::protos::_DoHeliosSayPlayerTypes_default_instance_);
}
inline const ::protos::DoHeliosSayPlayerTypes& CoachAction::do_helios_say_player_types() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.CoachAction.do_helios_say_player_types)
  return _internal_do_helios_say_player_types();
}
inline ::protos::DoHeliosSayPlayerTypes* CoachAction::unsafe_arena_release_do_helios_say_player_types() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.CoachAction.do_helios_say_player_types)
  if (action_case() == kDoHeliosSayPlayerTypes) {
    clear_has_action();
    auto* temp = _impl_.action_.do_helios_say_player_types_;
    _impl_.action_.do_helios_say_player_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CoachAction::unsafe_arena_set_allocated_do_helios_say_player_types(::protos::DoHeliosSayPlayerTypes* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_do_helios_say_player_types();
    _impl_.action_.do_helios_say_player_types_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.CoachAction.do_helios_say_player_types)
}
inline ::protos::DoHeliosSayPlayerTypes* CoachAction::_internal_mutable_do_helios_say_player_types() {
  if (action_case() != kDoHeliosSayPlayerTypes) {
    clear_action();
    set_has_do_helios_say_player_types();
    _impl_.action_.do_helios_say_player_types_ = CreateMaybeMessage<::protos::DoHeliosSayPlayerTypes>(GetArena());
  }
  return _impl_.action_.do_helios_say_player_types_;
}
inline ::protos::DoHeliosSayPlayerTypes* CoachAction::mutable_do_helios_say_player_types() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::DoHeliosSayPlayerTypes* _msg = _internal_mutable_do_helios_say_player_types();
  // @@protoc_insertion_point(field_mutable:protos.CoachAction.do_helios_say_player_types)
  return _msg;
}

inline bool CoachAction::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void CoachAction::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline CoachAction::ActionCase CoachAction::action_case() const {
  return CoachAction::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CoachActions

// repeated .protos.CoachAction actions = 1;
inline int CoachActions::_internal_actions_size() const {
  return _internal_actions().size();
}
inline int CoachActions::actions_size() const {
  return _internal_actions_size();
}
inline void CoachActions::clear_actions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.actions_.Clear();
}
inline ::protos::CoachAction* CoachActions::mutable_actions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:protos.CoachActions.actions)
  return _internal_mutable_actions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::protos::CoachAction>* CoachActions::mutable_actions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:protos.CoachActions.actions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_actions();
}
inline const ::protos::CoachAction& CoachActions::actions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.CoachActions.actions)
  return _internal_actions().Get(index);
}
inline ::protos::CoachAction* CoachActions::add_actions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::protos::CoachAction* _add = _internal_mutable_actions()->Add();
  // @@protoc_insertion_point(field_add:protos.CoachActions.actions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::protos::CoachAction>& CoachActions::actions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:protos.CoachActions.actions)
  return _internal_actions();
}
inline const ::google::protobuf::RepeatedPtrField<::protos::CoachAction>&
CoachActions::_internal_actions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.actions_;
}
inline ::google::protobuf::RepeatedPtrField<::protos::CoachAction>*
CoachActions::_internal_mutable_actions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.actions_;
}

// -------------------------------------------------------------------

// DoKickOff

// -------------------------------------------------------------------

// DoMoveBall

// .protos.Vector2D position = 1;
inline bool DoMoveBall::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void DoMoveBall::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& DoMoveBall::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& DoMoveBall::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.DoMoveBall.position)
  return _internal_position();
}
inline void DoMoveBall::unsafe_arena_set_allocated_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.DoMoveBall.position)
}
inline ::protos::Vector2D* DoMoveBall::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* DoMoveBall::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.DoMoveBall.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* DoMoveBall::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* DoMoveBall::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.DoMoveBall.position)
  return _msg;
}
inline void DoMoveBall::set_allocated_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.DoMoveBall.position)
}

// .protos.Vector2D velocity = 2;
inline bool DoMoveBall::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void DoMoveBall::clear_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::protos::Vector2D& DoMoveBall::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& DoMoveBall::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.DoMoveBall.velocity)
  return _internal_velocity();
}
inline void DoMoveBall::unsafe_arena_set_allocated_velocity(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.DoMoveBall.velocity)
}
inline ::protos::Vector2D* DoMoveBall::release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* DoMoveBall::unsafe_arena_release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.DoMoveBall.velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::protos::Vector2D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* DoMoveBall::_internal_mutable_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.velocity_;
}
inline ::protos::Vector2D* DoMoveBall::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:protos.DoMoveBall.velocity)
  return _msg;
}
inline void DoMoveBall::set_allocated_velocity(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.velocity_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.DoMoveBall.velocity)
}

// -------------------------------------------------------------------

// DoMovePlayer

// bool our_side = 1;
inline void DoMovePlayer::clear_our_side() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.our_side_ = false;
}
inline bool DoMovePlayer::our_side() const {
  // @@protoc_insertion_point(field_get:protos.DoMovePlayer.our_side)
  return _internal_our_side();
}
inline void DoMovePlayer::set_our_side(bool value) {
  _internal_set_our_side(value);
  // @@protoc_insertion_point(field_set:protos.DoMovePlayer.our_side)
}
inline bool DoMovePlayer::_internal_our_side() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.our_side_;
}
inline void DoMovePlayer::_internal_set_our_side(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.our_side_ = value;
}

// int32 uniform_number = 2;
inline void DoMovePlayer::clear_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_ = 0;
}
inline ::int32_t DoMovePlayer::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.DoMovePlayer.uniform_number)
  return _internal_uniform_number();
}
inline void DoMovePlayer::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.DoMovePlayer.uniform_number)
}
inline ::int32_t DoMovePlayer::_internal_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_;
}
inline void DoMovePlayer::_internal_set_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_ = value;
}

// .protos.Vector2D position = 3;
inline bool DoMovePlayer::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void DoMovePlayer::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::protos::Vector2D& DoMovePlayer::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::protos::Vector2D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::protos::Vector2D&>(::protos::_Vector2D_default_instance_);
}
inline const ::protos::Vector2D& DoMovePlayer::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.DoMovePlayer.position)
  return _internal_position();
}
inline void DoMovePlayer::unsafe_arena_set_allocated_position(::protos::Vector2D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.DoMovePlayer.position)
}
inline ::protos::Vector2D* DoMovePlayer::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::protos::Vector2D* DoMovePlayer::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.DoMovePlayer.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::protos::Vector2D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::protos::Vector2D* DoMovePlayer::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::Vector2D>(GetArena());
    _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(p);
  }
  return _impl_.position_;
}
inline ::protos::Vector2D* DoMovePlayer::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::Vector2D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:protos.DoMovePlayer.position)
  return _msg;
}
inline void DoMovePlayer::set_allocated_position(::protos::Vector2D* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::protos::Vector2D*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::protos::Vector2D*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::protos::Vector2D*>(value);
  // @@protoc_insertion_point(field_set_allocated:protos.DoMovePlayer.position)
}

// float body_direction = 4;
inline void DoMovePlayer::clear_body_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_direction_ = 0;
}
inline float DoMovePlayer::body_direction() const {
  // @@protoc_insertion_point(field_get:protos.DoMovePlayer.body_direction)
  return _internal_body_direction();
}
inline void DoMovePlayer::set_body_direction(float value) {
  _internal_set_body_direction(value);
  // @@protoc_insertion_point(field_set:protos.DoMovePlayer.body_direction)
}
inline float DoMovePlayer::_internal_body_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_direction_;
}
inline void DoMovePlayer::_internal_set_body_direction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.body_direction_ = value;
}

// -------------------------------------------------------------------

// DoRecover

// -------------------------------------------------------------------

// DoChangeMode

// .protos.GameModeType game_mode_type = 1;
inline void DoChangeMode::clear_game_mode_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_mode_type_ = 0;
}
inline ::protos::GameModeType DoChangeMode::game_mode_type() const {
  // @@protoc_insertion_point(field_get:protos.DoChangeMode.game_mode_type)
  return _internal_game_mode_type();
}
inline void DoChangeMode::set_game_mode_type(::protos::GameModeType value) {
  _internal_set_game_mode_type(value);
  // @@protoc_insertion_point(field_set:protos.DoChangeMode.game_mode_type)
}
inline ::protos::GameModeType DoChangeMode::_internal_game_mode_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::GameModeType>(_impl_.game_mode_type_);
}
inline void DoChangeMode::_internal_set_game_mode_type(::protos::GameModeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.game_mode_type_ = value;
}

// .protos.Side side = 2;
inline void DoChangeMode::clear_side() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_ = 0;
}
inline ::protos::Side DoChangeMode::side() const {
  // @@protoc_insertion_point(field_get:protos.DoChangeMode.side)
  return _internal_side();
}
inline void DoChangeMode::set_side(::protos::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:protos.DoChangeMode.side)
}
inline ::protos::Side DoChangeMode::_internal_side() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::Side>(_impl_.side_);
}
inline void DoChangeMode::_internal_set_side(::protos::Side value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.side_ = value;
}

// -------------------------------------------------------------------

// DoChangePlayerType

// bool our_side = 1;
inline void DoChangePlayerType::clear_our_side() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.our_side_ = false;
}
inline bool DoChangePlayerType::our_side() const {
  // @@protoc_insertion_point(field_get:protos.DoChangePlayerType.our_side)
  return _internal_our_side();
}
inline void DoChangePlayerType::set_our_side(bool value) {
  _internal_set_our_side(value);
  // @@protoc_insertion_point(field_set:protos.DoChangePlayerType.our_side)
}
inline bool DoChangePlayerType::_internal_our_side() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.our_side_;
}
inline void DoChangePlayerType::_internal_set_our_side(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.our_side_ = value;
}

// int32 uniform_number = 2;
inline void DoChangePlayerType::clear_uniform_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniform_number_ = 0;
}
inline ::int32_t DoChangePlayerType::uniform_number() const {
  // @@protoc_insertion_point(field_get:protos.DoChangePlayerType.uniform_number)
  return _internal_uniform_number();
}
inline void DoChangePlayerType::set_uniform_number(::int32_t value) {
  _internal_set_uniform_number(value);
  // @@protoc_insertion_point(field_set:protos.DoChangePlayerType.uniform_number)
}
inline ::int32_t DoChangePlayerType::_internal_uniform_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniform_number_;
}
inline void DoChangePlayerType::_internal_set_uniform_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uniform_number_ = value;
}

// int32 type = 3;
inline void DoChangePlayerType::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::int32_t DoChangePlayerType::type() const {
  // @@protoc_insertion_point(field_get:protos.DoChangePlayerType.type)
  return _internal_type();
}
inline void DoChangePlayerType::set_type(::int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protos.DoChangePlayerType.type)
}
inline ::int32_t DoChangePlayerType::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void DoChangePlayerType::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// TrainerAction

// .protos.DoKickOff do_kick_off = 1;
inline bool TrainerAction::has_do_kick_off() const {
  return action_case() == kDoKickOff;
}
inline bool TrainerAction::_internal_has_do_kick_off() const {
  return action_case() == kDoKickOff;
}
inline void TrainerAction::set_has_do_kick_off() {
  _impl_._oneof_case_[0] = kDoKickOff;
}
inline void TrainerAction::clear_do_kick_off() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kDoKickOff) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.do_kick_off_;
    }
    clear_has_action();
  }
}
inline ::protos::DoKickOff* TrainerAction::release_do_kick_off() {
  // @@protoc_insertion_point(field_release:protos.TrainerAction.do_kick_off)
  if (action_case() == kDoKickOff) {
    clear_has_action();
    auto* temp = _impl_.action_.do_kick_off_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.do_kick_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DoKickOff& TrainerAction::_internal_do_kick_off() const {
  return action_case() == kDoKickOff ? *_impl_.action_.do_kick_off_ : reinterpret_cast<::protos::DoKickOff&>(::protos::_DoKickOff_default_instance_);
}
inline const ::protos::DoKickOff& TrainerAction::do_kick_off() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.TrainerAction.do_kick_off)
  return _internal_do_kick_off();
}
inline ::protos::DoKickOff* TrainerAction::unsafe_arena_release_do_kick_off() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.TrainerAction.do_kick_off)
  if (action_case() == kDoKickOff) {
    clear_has_action();
    auto* temp = _impl_.action_.do_kick_off_;
    _impl_.action_.do_kick_off_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrainerAction::unsafe_arena_set_allocated_do_kick_off(::protos::DoKickOff* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_do_kick_off();
    _impl_.action_.do_kick_off_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.TrainerAction.do_kick_off)
}
inline ::protos::DoKickOff* TrainerAction::_internal_mutable_do_kick_off() {
  if (action_case() != kDoKickOff) {
    clear_action();
    set_has_do_kick_off();
    _impl_.action_.do_kick_off_ = CreateMaybeMessage<::protos::DoKickOff>(GetArena());
  }
  return _impl_.action_.do_kick_off_;
}
inline ::protos::DoKickOff* TrainerAction::mutable_do_kick_off() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::DoKickOff* _msg = _internal_mutable_do_kick_off();
  // @@protoc_insertion_point(field_mutable:protos.TrainerAction.do_kick_off)
  return _msg;
}

// .protos.DoMoveBall do_move_ball = 2;
inline bool TrainerAction::has_do_move_ball() const {
  return action_case() == kDoMoveBall;
}
inline bool TrainerAction::_internal_has_do_move_ball() const {
  return action_case() == kDoMoveBall;
}
inline void TrainerAction::set_has_do_move_ball() {
  _impl_._oneof_case_[0] = kDoMoveBall;
}
inline void TrainerAction::clear_do_move_ball() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kDoMoveBall) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.do_move_ball_;
    }
    clear_has_action();
  }
}
inline ::protos::DoMoveBall* TrainerAction::release_do_move_ball() {
  // @@protoc_insertion_point(field_release:protos.TrainerAction.do_move_ball)
  if (action_case() == kDoMoveBall) {
    clear_has_action();
    auto* temp = _impl_.action_.do_move_ball_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.do_move_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DoMoveBall& TrainerAction::_internal_do_move_ball() const {
  return action_case() == kDoMoveBall ? *_impl_.action_.do_move_ball_ : reinterpret_cast<::protos::DoMoveBall&>(::protos::_DoMoveBall_default_instance_);
}
inline const ::protos::DoMoveBall& TrainerAction::do_move_ball() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.TrainerAction.do_move_ball)
  return _internal_do_move_ball();
}
inline ::protos::DoMoveBall* TrainerAction::unsafe_arena_release_do_move_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.TrainerAction.do_move_ball)
  if (action_case() == kDoMoveBall) {
    clear_has_action();
    auto* temp = _impl_.action_.do_move_ball_;
    _impl_.action_.do_move_ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrainerAction::unsafe_arena_set_allocated_do_move_ball(::protos::DoMoveBall* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_do_move_ball();
    _impl_.action_.do_move_ball_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.TrainerAction.do_move_ball)
}
inline ::protos::DoMoveBall* TrainerAction::_internal_mutable_do_move_ball() {
  if (action_case() != kDoMoveBall) {
    clear_action();
    set_has_do_move_ball();
    _impl_.action_.do_move_ball_ = CreateMaybeMessage<::protos::DoMoveBall>(GetArena());
  }
  return _impl_.action_.do_move_ball_;
}
inline ::protos::DoMoveBall* TrainerAction::mutable_do_move_ball() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::DoMoveBall* _msg = _internal_mutable_do_move_ball();
  // @@protoc_insertion_point(field_mutable:protos.TrainerAction.do_move_ball)
  return _msg;
}

// .protos.DoMovePlayer do_move_player = 3;
inline bool TrainerAction::has_do_move_player() const {
  return action_case() == kDoMovePlayer;
}
inline bool TrainerAction::_internal_has_do_move_player() const {
  return action_case() == kDoMovePlayer;
}
inline void TrainerAction::set_has_do_move_player() {
  _impl_._oneof_case_[0] = kDoMovePlayer;
}
inline void TrainerAction::clear_do_move_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kDoMovePlayer) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.do_move_player_;
    }
    clear_has_action();
  }
}
inline ::protos::DoMovePlayer* TrainerAction::release_do_move_player() {
  // @@protoc_insertion_point(field_release:protos.TrainerAction.do_move_player)
  if (action_case() == kDoMovePlayer) {
    clear_has_action();
    auto* temp = _impl_.action_.do_move_player_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.do_move_player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DoMovePlayer& TrainerAction::_internal_do_move_player() const {
  return action_case() == kDoMovePlayer ? *_impl_.action_.do_move_player_ : reinterpret_cast<::protos::DoMovePlayer&>(::protos::_DoMovePlayer_default_instance_);
}
inline const ::protos::DoMovePlayer& TrainerAction::do_move_player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.TrainerAction.do_move_player)
  return _internal_do_move_player();
}
inline ::protos::DoMovePlayer* TrainerAction::unsafe_arena_release_do_move_player() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.TrainerAction.do_move_player)
  if (action_case() == kDoMovePlayer) {
    clear_has_action();
    auto* temp = _impl_.action_.do_move_player_;
    _impl_.action_.do_move_player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrainerAction::unsafe_arena_set_allocated_do_move_player(::protos::DoMovePlayer* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_do_move_player();
    _impl_.action_.do_move_player_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.TrainerAction.do_move_player)
}
inline ::protos::DoMovePlayer* TrainerAction::_internal_mutable_do_move_player() {
  if (action_case() != kDoMovePlayer) {
    clear_action();
    set_has_do_move_player();
    _impl_.action_.do_move_player_ = CreateMaybeMessage<::protos::DoMovePlayer>(GetArena());
  }
  return _impl_.action_.do_move_player_;
}
inline ::protos::DoMovePlayer* TrainerAction::mutable_do_move_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::DoMovePlayer* _msg = _internal_mutable_do_move_player();
  // @@protoc_insertion_point(field_mutable:protos.TrainerAction.do_move_player)
  return _msg;
}

// .protos.DoRecover do_recover = 4;
inline bool TrainerAction::has_do_recover() const {
  return action_case() == kDoRecover;
}
inline bool TrainerAction::_internal_has_do_recover() const {
  return action_case() == kDoRecover;
}
inline void TrainerAction::set_has_do_recover() {
  _impl_._oneof_case_[0] = kDoRecover;
}
inline void TrainerAction::clear_do_recover() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kDoRecover) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.do_recover_;
    }
    clear_has_action();
  }
}
inline ::protos::DoRecover* TrainerAction::release_do_recover() {
  // @@protoc_insertion_point(field_release:protos.TrainerAction.do_recover)
  if (action_case() == kDoRecover) {
    clear_has_action();
    auto* temp = _impl_.action_.do_recover_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.do_recover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DoRecover& TrainerAction::_internal_do_recover() const {
  return action_case() == kDoRecover ? *_impl_.action_.do_recover_ : reinterpret_cast<::protos::DoRecover&>(::protos::_DoRecover_default_instance_);
}
inline const ::protos::DoRecover& TrainerAction::do_recover() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.TrainerAction.do_recover)
  return _internal_do_recover();
}
inline ::protos::DoRecover* TrainerAction::unsafe_arena_release_do_recover() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.TrainerAction.do_recover)
  if (action_case() == kDoRecover) {
    clear_has_action();
    auto* temp = _impl_.action_.do_recover_;
    _impl_.action_.do_recover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrainerAction::unsafe_arena_set_allocated_do_recover(::protos::DoRecover* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_do_recover();
    _impl_.action_.do_recover_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.TrainerAction.do_recover)
}
inline ::protos::DoRecover* TrainerAction::_internal_mutable_do_recover() {
  if (action_case() != kDoRecover) {
    clear_action();
    set_has_do_recover();
    _impl_.action_.do_recover_ = CreateMaybeMessage<::protos::DoRecover>(GetArena());
  }
  return _impl_.action_.do_recover_;
}
inline ::protos::DoRecover* TrainerAction::mutable_do_recover() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::DoRecover* _msg = _internal_mutable_do_recover();
  // @@protoc_insertion_point(field_mutable:protos.TrainerAction.do_recover)
  return _msg;
}

// .protos.DoChangeMode do_change_mode = 5;
inline bool TrainerAction::has_do_change_mode() const {
  return action_case() == kDoChangeMode;
}
inline bool TrainerAction::_internal_has_do_change_mode() const {
  return action_case() == kDoChangeMode;
}
inline void TrainerAction::set_has_do_change_mode() {
  _impl_._oneof_case_[0] = kDoChangeMode;
}
inline void TrainerAction::clear_do_change_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kDoChangeMode) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.do_change_mode_;
    }
    clear_has_action();
  }
}
inline ::protos::DoChangeMode* TrainerAction::release_do_change_mode() {
  // @@protoc_insertion_point(field_release:protos.TrainerAction.do_change_mode)
  if (action_case() == kDoChangeMode) {
    clear_has_action();
    auto* temp = _impl_.action_.do_change_mode_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.do_change_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DoChangeMode& TrainerAction::_internal_do_change_mode() const {
  return action_case() == kDoChangeMode ? *_impl_.action_.do_change_mode_ : reinterpret_cast<::protos::DoChangeMode&>(::protos::_DoChangeMode_default_instance_);
}
inline const ::protos::DoChangeMode& TrainerAction::do_change_mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.TrainerAction.do_change_mode)
  return _internal_do_change_mode();
}
inline ::protos::DoChangeMode* TrainerAction::unsafe_arena_release_do_change_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.TrainerAction.do_change_mode)
  if (action_case() == kDoChangeMode) {
    clear_has_action();
    auto* temp = _impl_.action_.do_change_mode_;
    _impl_.action_.do_change_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrainerAction::unsafe_arena_set_allocated_do_change_mode(::protos::DoChangeMode* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_do_change_mode();
    _impl_.action_.do_change_mode_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.TrainerAction.do_change_mode)
}
inline ::protos::DoChangeMode* TrainerAction::_internal_mutable_do_change_mode() {
  if (action_case() != kDoChangeMode) {
    clear_action();
    set_has_do_change_mode();
    _impl_.action_.do_change_mode_ = CreateMaybeMessage<::protos::DoChangeMode>(GetArena());
  }
  return _impl_.action_.do_change_mode_;
}
inline ::protos::DoChangeMode* TrainerAction::mutable_do_change_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::DoChangeMode* _msg = _internal_mutable_do_change_mode();
  // @@protoc_insertion_point(field_mutable:protos.TrainerAction.do_change_mode)
  return _msg;
}

// .protos.DoChangePlayerType do_change_player_type = 6;
inline bool TrainerAction::has_do_change_player_type() const {
  return action_case() == kDoChangePlayerType;
}
inline bool TrainerAction::_internal_has_do_change_player_type() const {
  return action_case() == kDoChangePlayerType;
}
inline void TrainerAction::set_has_do_change_player_type() {
  _impl_._oneof_case_[0] = kDoChangePlayerType;
}
inline void TrainerAction::clear_do_change_player_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (action_case() == kDoChangePlayerType) {
    if (GetArena() == nullptr) {
      delete _impl_.action_.do_change_player_type_;
    }
    clear_has_action();
  }
}
inline ::protos::DoChangePlayerType* TrainerAction::release_do_change_player_type() {
  // @@protoc_insertion_point(field_release:protos.TrainerAction.do_change_player_type)
  if (action_case() == kDoChangePlayerType) {
    clear_has_action();
    auto* temp = _impl_.action_.do_change_player_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.do_change_player_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::protos::DoChangePlayerType& TrainerAction::_internal_do_change_player_type() const {
  return action_case() == kDoChangePlayerType ? *_impl_.action_.do_change_player_type_ : reinterpret_cast<::protos::DoChangePlayerType&>(::protos::_DoChangePlayerType_default_instance_);
}
inline const ::protos::DoChangePlayerType& TrainerAction::do_change_player_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.TrainerAction.do_change_player_type)
  return _internal_do_change_player_type();
}
inline ::protos::DoChangePlayerType* TrainerAction::unsafe_arena_release_do_change_player_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protos.TrainerAction.do_change_player_type)
  if (action_case() == kDoChangePlayerType) {
    clear_has_action();
    auto* temp = _impl_.action_.do_change_player_type_;
    _impl_.action_.do_change_player_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrainerAction::unsafe_arena_set_allocated_do_change_player_type(::protos::DoChangePlayerType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_action();
  if (value) {
    set_has_do_change_player_type();
    _impl_.action_.do_change_player_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.TrainerAction.do_change_player_type)
}
inline ::protos::DoChangePlayerType* TrainerAction::_internal_mutable_do_change_player_type() {
  if (action_case() != kDoChangePlayerType) {
    clear_action();
    set_has_do_change_player_type();
    _impl_.action_.do_change_player_type_ = CreateMaybeMessage<::protos::DoChangePlayerType>(GetArena());
  }
  return _impl_.action_.do_change_player_type_;
}
inline ::protos::DoChangePlayerType* TrainerAction::mutable_do_change_player_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::protos::DoChangePlayerType* _msg = _internal_mutable_do_change_player_type();
  // @@protoc_insertion_point(field_mutable:protos.TrainerAction.do_change_player_type)
  return _msg;
}

inline bool TrainerAction::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void TrainerAction::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline TrainerAction::ActionCase TrainerAction::action_case() const {
  return TrainerAction::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TrainerActions

// repeated .protos.TrainerAction actions = 1;
inline int TrainerActions::_internal_actions_size() const {
  return _internal_actions().size();
}
inline int TrainerActions::actions_size() const {
  return _internal_actions_size();
}
inline void TrainerActions::clear_actions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.actions_.Clear();
}
inline ::protos::TrainerAction* TrainerActions::mutable_actions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:protos.TrainerActions.actions)
  return _internal_mutable_actions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::protos::TrainerAction>* TrainerActions::mutable_actions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:protos.TrainerActions.actions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_actions();
}
inline const ::protos::TrainerAction& TrainerActions::actions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.TrainerActions.actions)
  return _internal_actions().Get(index);
}
inline ::protos::TrainerAction* TrainerActions::add_actions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::protos::TrainerAction* _add = _internal_mutable_actions()->Add();
  // @@protoc_insertion_point(field_add:protos.TrainerActions.actions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::protos::TrainerAction>& TrainerActions::actions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:protos.TrainerActions.actions)
  return _internal_actions();
}
inline const ::google::protobuf::RepeatedPtrField<::protos::TrainerAction>&
TrainerActions::_internal_actions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.actions_;
}
inline ::google::protobuf::RepeatedPtrField<::protos::TrainerAction>*
TrainerActions::_internal_mutable_actions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.actions_;
}

// -------------------------------------------------------------------

// ServerParam

// .protos.AgentType agent_type = 1;
inline void ServerParam::clear_agent_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_type_ = 0;
}
inline ::protos::AgentType ServerParam::agent_type() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.agent_type)
  return _internal_agent_type();
}
inline void ServerParam::set_agent_type(::protos::AgentType value) {
  _internal_set_agent_type(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.agent_type)
}
inline ::protos::AgentType ServerParam::_internal_agent_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::AgentType>(_impl_.agent_type_);
}
inline void ServerParam::_internal_set_agent_type(::protos::AgentType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_type_ = value;
}

// float inertia_moment = 2;
inline void ServerParam::clear_inertia_moment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inertia_moment_ = 0;
}
inline float ServerParam::inertia_moment() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.inertia_moment)
  return _internal_inertia_moment();
}
inline void ServerParam::set_inertia_moment(float value) {
  _internal_set_inertia_moment(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.inertia_moment)
}
inline float ServerParam::_internal_inertia_moment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inertia_moment_;
}
inline void ServerParam::_internal_set_inertia_moment(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.inertia_moment_ = value;
}

// float player_size = 3;
inline void ServerParam::clear_player_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_size_ = 0;
}
inline float ServerParam::player_size() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_size)
  return _internal_player_size();
}
inline void ServerParam::set_player_size(float value) {
  _internal_set_player_size(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_size)
}
inline float ServerParam::_internal_player_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_size_;
}
inline void ServerParam::_internal_set_player_size(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_size_ = value;
}

// float player_decay = 4;
inline void ServerParam::clear_player_decay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_decay_ = 0;
}
inline float ServerParam::player_decay() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_decay)
  return _internal_player_decay();
}
inline void ServerParam::set_player_decay(float value) {
  _internal_set_player_decay(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_decay)
}
inline float ServerParam::_internal_player_decay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_decay_;
}
inline void ServerParam::_internal_set_player_decay(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_decay_ = value;
}

// float player_rand = 5;
inline void ServerParam::clear_player_rand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_rand_ = 0;
}
inline float ServerParam::player_rand() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_rand)
  return _internal_player_rand();
}
inline void ServerParam::set_player_rand(float value) {
  _internal_set_player_rand(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_rand)
}
inline float ServerParam::_internal_player_rand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_rand_;
}
inline void ServerParam::_internal_set_player_rand(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_rand_ = value;
}

// float player_weight = 6;
inline void ServerParam::clear_player_weight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_weight_ = 0;
}
inline float ServerParam::player_weight() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_weight)
  return _internal_player_weight();
}
inline void ServerParam::set_player_weight(float value) {
  _internal_set_player_weight(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_weight)
}
inline float ServerParam::_internal_player_weight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_weight_;
}
inline void ServerParam::_internal_set_player_weight(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_weight_ = value;
}

// float player_speed_max = 7;
inline void ServerParam::clear_player_speed_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_speed_max_ = 0;
}
inline float ServerParam::player_speed_max() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_speed_max)
  return _internal_player_speed_max();
}
inline void ServerParam::set_player_speed_max(float value) {
  _internal_set_player_speed_max(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_speed_max)
}
inline float ServerParam::_internal_player_speed_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_speed_max_;
}
inline void ServerParam::_internal_set_player_speed_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_speed_max_ = value;
}

// float player_accel_max = 8;
inline void ServerParam::clear_player_accel_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_accel_max_ = 0;
}
inline float ServerParam::player_accel_max() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_accel_max)
  return _internal_player_accel_max();
}
inline void ServerParam::set_player_accel_max(float value) {
  _internal_set_player_accel_max(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_accel_max)
}
inline float ServerParam::_internal_player_accel_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_accel_max_;
}
inline void ServerParam::_internal_set_player_accel_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_accel_max_ = value;
}

// float stamina_max = 9;
inline void ServerParam::clear_stamina_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stamina_max_ = 0;
}
inline float ServerParam::stamina_max() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.stamina_max)
  return _internal_stamina_max();
}
inline void ServerParam::set_stamina_max(float value) {
  _internal_set_stamina_max(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.stamina_max)
}
inline float ServerParam::_internal_stamina_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stamina_max_;
}
inline void ServerParam::_internal_set_stamina_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stamina_max_ = value;
}

// float stamina_inc_max = 10;
inline void ServerParam::clear_stamina_inc_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stamina_inc_max_ = 0;
}
inline float ServerParam::stamina_inc_max() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.stamina_inc_max)
  return _internal_stamina_inc_max();
}
inline void ServerParam::set_stamina_inc_max(float value) {
  _internal_set_stamina_inc_max(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.stamina_inc_max)
}
inline float ServerParam::_internal_stamina_inc_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stamina_inc_max_;
}
inline void ServerParam::_internal_set_stamina_inc_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stamina_inc_max_ = value;
}

// float recover_init = 11;
inline void ServerParam::clear_recover_init() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recover_init_ = 0;
}
inline float ServerParam::recover_init() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.recover_init)
  return _internal_recover_init();
}
inline void ServerParam::set_recover_init(float value) {
  _internal_set_recover_init(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.recover_init)
}
inline float ServerParam::_internal_recover_init() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recover_init_;
}
inline void ServerParam::_internal_set_recover_init(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recover_init_ = value;
}

// float recover_dec_thr = 12;
inline void ServerParam::clear_recover_dec_thr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recover_dec_thr_ = 0;
}
inline float ServerParam::recover_dec_thr() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.recover_dec_thr)
  return _internal_recover_dec_thr();
}
inline void ServerParam::set_recover_dec_thr(float value) {
  _internal_set_recover_dec_thr(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.recover_dec_thr)
}
inline float ServerParam::_internal_recover_dec_thr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recover_dec_thr_;
}
inline void ServerParam::_internal_set_recover_dec_thr(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recover_dec_thr_ = value;
}

// float recover_min = 13;
inline void ServerParam::clear_recover_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recover_min_ = 0;
}
inline float ServerParam::recover_min() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.recover_min)
  return _internal_recover_min();
}
inline void ServerParam::set_recover_min(float value) {
  _internal_set_recover_min(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.recover_min)
}
inline float ServerParam::_internal_recover_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recover_min_;
}
inline void ServerParam::_internal_set_recover_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recover_min_ = value;
}

// float recover_dec = 14;
inline void ServerParam::clear_recover_dec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recover_dec_ = 0;
}
inline float ServerParam::recover_dec() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.recover_dec)
  return _internal_recover_dec();
}
inline void ServerParam::set_recover_dec(float value) {
  _internal_set_recover_dec(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.recover_dec)
}
inline float ServerParam::_internal_recover_dec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recover_dec_;
}
inline void ServerParam::_internal_set_recover_dec(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recover_dec_ = value;
}

// float effort_init = 15;
inline void ServerParam::clear_effort_init() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effort_init_ = 0;
}
inline float ServerParam::effort_init() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.effort_init)
  return _internal_effort_init();
}
inline void ServerParam::set_effort_init(float value) {
  _internal_set_effort_init(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.effort_init)
}
inline float ServerParam::_internal_effort_init() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effort_init_;
}
inline void ServerParam::_internal_set_effort_init(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effort_init_ = value;
}

// float effort_dec_thr = 16;
inline void ServerParam::clear_effort_dec_thr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effort_dec_thr_ = 0;
}
inline float ServerParam::effort_dec_thr() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.effort_dec_thr)
  return _internal_effort_dec_thr();
}
inline void ServerParam::set_effort_dec_thr(float value) {
  _internal_set_effort_dec_thr(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.effort_dec_thr)
}
inline float ServerParam::_internal_effort_dec_thr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effort_dec_thr_;
}
inline void ServerParam::_internal_set_effort_dec_thr(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effort_dec_thr_ = value;
}

// float effort_min = 17;
inline void ServerParam::clear_effort_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effort_min_ = 0;
}
inline float ServerParam::effort_min() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.effort_min)
  return _internal_effort_min();
}
inline void ServerParam::set_effort_min(float value) {
  _internal_set_effort_min(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.effort_min)
}
inline float ServerParam::_internal_effort_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effort_min_;
}
inline void ServerParam::_internal_set_effort_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effort_min_ = value;
}

// float effort_dec = 18;
inline void ServerParam::clear_effort_dec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effort_dec_ = 0;
}
inline float ServerParam::effort_dec() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.effort_dec)
  return _internal_effort_dec();
}
inline void ServerParam::set_effort_dec(float value) {
  _internal_set_effort_dec(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.effort_dec)
}
inline float ServerParam::_internal_effort_dec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effort_dec_;
}
inline void ServerParam::_internal_set_effort_dec(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effort_dec_ = value;
}

// float effort_inc_thr = 19;
inline void ServerParam::clear_effort_inc_thr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effort_inc_thr_ = 0;
}
inline float ServerParam::effort_inc_thr() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.effort_inc_thr)
  return _internal_effort_inc_thr();
}
inline void ServerParam::set_effort_inc_thr(float value) {
  _internal_set_effort_inc_thr(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.effort_inc_thr)
}
inline float ServerParam::_internal_effort_inc_thr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effort_inc_thr_;
}
inline void ServerParam::_internal_set_effort_inc_thr(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effort_inc_thr_ = value;
}

// float effort_inc = 20;
inline void ServerParam::clear_effort_inc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effort_inc_ = 0;
}
inline float ServerParam::effort_inc() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.effort_inc)
  return _internal_effort_inc();
}
inline void ServerParam::set_effort_inc(float value) {
  _internal_set_effort_inc(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.effort_inc)
}
inline float ServerParam::_internal_effort_inc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effort_inc_;
}
inline void ServerParam::_internal_set_effort_inc(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effort_inc_ = value;
}

// float kick_rand = 21;
inline void ServerParam::clear_kick_rand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kick_rand_ = 0;
}
inline float ServerParam::kick_rand() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.kick_rand)
  return _internal_kick_rand();
}
inline void ServerParam::set_kick_rand(float value) {
  _internal_set_kick_rand(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.kick_rand)
}
inline float ServerParam::_internal_kick_rand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kick_rand_;
}
inline void ServerParam::_internal_set_kick_rand(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kick_rand_ = value;
}

// bool team_actuator_noise = 22;
inline void ServerParam::clear_team_actuator_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.team_actuator_noise_ = false;
}
inline bool ServerParam::team_actuator_noise() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.team_actuator_noise)
  return _internal_team_actuator_noise();
}
inline void ServerParam::set_team_actuator_noise(bool value) {
  _internal_set_team_actuator_noise(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.team_actuator_noise)
}
inline bool ServerParam::_internal_team_actuator_noise() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.team_actuator_noise_;
}
inline void ServerParam::_internal_set_team_actuator_noise(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.team_actuator_noise_ = value;
}

// float player_rand_factor_l = 23;
inline void ServerParam::clear_player_rand_factor_l() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_rand_factor_l_ = 0;
}
inline float ServerParam::player_rand_factor_l() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_rand_factor_l)
  return _internal_player_rand_factor_l();
}
inline void ServerParam::set_player_rand_factor_l(float value) {
  _internal_set_player_rand_factor_l(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_rand_factor_l)
}
inline float ServerParam::_internal_player_rand_factor_l() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_rand_factor_l_;
}
inline void ServerParam::_internal_set_player_rand_factor_l(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_rand_factor_l_ = value;
}

// float player_rand_factor_r = 24;
inline void ServerParam::clear_player_rand_factor_r() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_rand_factor_r_ = 0;
}
inline float ServerParam::player_rand_factor_r() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_rand_factor_r)
  return _internal_player_rand_factor_r();
}
inline void ServerParam::set_player_rand_factor_r(float value) {
  _internal_set_player_rand_factor_r(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_rand_factor_r)
}
inline float ServerParam::_internal_player_rand_factor_r() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_rand_factor_r_;
}
inline void ServerParam::_internal_set_player_rand_factor_r(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_rand_factor_r_ = value;
}

// float kick_rand_factor_l = 25;
inline void ServerParam::clear_kick_rand_factor_l() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kick_rand_factor_l_ = 0;
}
inline float ServerParam::kick_rand_factor_l() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.kick_rand_factor_l)
  return _internal_kick_rand_factor_l();
}
inline void ServerParam::set_kick_rand_factor_l(float value) {
  _internal_set_kick_rand_factor_l(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.kick_rand_factor_l)
}
inline float ServerParam::_internal_kick_rand_factor_l() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kick_rand_factor_l_;
}
inline void ServerParam::_internal_set_kick_rand_factor_l(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kick_rand_factor_l_ = value;
}

// float kick_rand_factor_r = 26;
inline void ServerParam::clear_kick_rand_factor_r() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kick_rand_factor_r_ = 0;
}
inline float ServerParam::kick_rand_factor_r() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.kick_rand_factor_r)
  return _internal_kick_rand_factor_r();
}
inline void ServerParam::set_kick_rand_factor_r(float value) {
  _internal_set_kick_rand_factor_r(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.kick_rand_factor_r)
}
inline float ServerParam::_internal_kick_rand_factor_r() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kick_rand_factor_r_;
}
inline void ServerParam::_internal_set_kick_rand_factor_r(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kick_rand_factor_r_ = value;
}

// float ball_size = 27;
inline void ServerParam::clear_ball_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ball_size_ = 0;
}
inline float ServerParam::ball_size() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.ball_size)
  return _internal_ball_size();
}
inline void ServerParam::set_ball_size(float value) {
  _internal_set_ball_size(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.ball_size)
}
inline float ServerParam::_internal_ball_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ball_size_;
}
inline void ServerParam::_internal_set_ball_size(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ball_size_ = value;
}

// float ball_decay = 28;
inline void ServerParam::clear_ball_decay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ball_decay_ = 0;
}
inline float ServerParam::ball_decay() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.ball_decay)
  return _internal_ball_decay();
}
inline void ServerParam::set_ball_decay(float value) {
  _internal_set_ball_decay(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.ball_decay)
}
inline float ServerParam::_internal_ball_decay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ball_decay_;
}
inline void ServerParam::_internal_set_ball_decay(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ball_decay_ = value;
}

// float ball_rand = 29;
inline void ServerParam::clear_ball_rand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ball_rand_ = 0;
}
inline float ServerParam::ball_rand() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.ball_rand)
  return _internal_ball_rand();
}
inline void ServerParam::set_ball_rand(float value) {
  _internal_set_ball_rand(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.ball_rand)
}
inline float ServerParam::_internal_ball_rand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ball_rand_;
}
inline void ServerParam::_internal_set_ball_rand(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ball_rand_ = value;
}

// float ball_weight = 30;
inline void ServerParam::clear_ball_weight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ball_weight_ = 0;
}
inline float ServerParam::ball_weight() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.ball_weight)
  return _internal_ball_weight();
}
inline void ServerParam::set_ball_weight(float value) {
  _internal_set_ball_weight(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.ball_weight)
}
inline float ServerParam::_internal_ball_weight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ball_weight_;
}
inline void ServerParam::_internal_set_ball_weight(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ball_weight_ = value;
}

// float ball_speed_max = 31;
inline void ServerParam::clear_ball_speed_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ball_speed_max_ = 0;
}
inline float ServerParam::ball_speed_max() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.ball_speed_max)
  return _internal_ball_speed_max();
}
inline void ServerParam::set_ball_speed_max(float value) {
  _internal_set_ball_speed_max(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.ball_speed_max)
}
inline float ServerParam::_internal_ball_speed_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ball_speed_max_;
}
inline void ServerParam::_internal_set_ball_speed_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ball_speed_max_ = value;
}

// float ball_accel_max = 32;
inline void ServerParam::clear_ball_accel_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ball_accel_max_ = 0;
}
inline float ServerParam::ball_accel_max() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.ball_accel_max)
  return _internal_ball_accel_max();
}
inline void ServerParam::set_ball_accel_max(float value) {
  _internal_set_ball_accel_max(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.ball_accel_max)
}
inline float ServerParam::_internal_ball_accel_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ball_accel_max_;
}
inline void ServerParam::_internal_set_ball_accel_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ball_accel_max_ = value;
}

// float dash_power_rate = 33;
inline void ServerParam::clear_dash_power_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_power_rate_ = 0;
}
inline float ServerParam::dash_power_rate() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.dash_power_rate)
  return _internal_dash_power_rate();
}
inline void ServerParam::set_dash_power_rate(float value) {
  _internal_set_dash_power_rate(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.dash_power_rate)
}
inline float ServerParam::_internal_dash_power_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_power_rate_;
}
inline void ServerParam::_internal_set_dash_power_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dash_power_rate_ = value;
}

// float kick_power_rate = 34;
inline void ServerParam::clear_kick_power_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kick_power_rate_ = 0;
}
inline float ServerParam::kick_power_rate() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.kick_power_rate)
  return _internal_kick_power_rate();
}
inline void ServerParam::set_kick_power_rate(float value) {
  _internal_set_kick_power_rate(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.kick_power_rate)
}
inline float ServerParam::_internal_kick_power_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kick_power_rate_;
}
inline void ServerParam::_internal_set_kick_power_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kick_power_rate_ = value;
}

// float kickable_margin = 35;
inline void ServerParam::clear_kickable_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kickable_margin_ = 0;
}
inline float ServerParam::kickable_margin() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.kickable_margin)
  return _internal_kickable_margin();
}
inline void ServerParam::set_kickable_margin(float value) {
  _internal_set_kickable_margin(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.kickable_margin)
}
inline float ServerParam::_internal_kickable_margin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kickable_margin_;
}
inline void ServerParam::_internal_set_kickable_margin(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kickable_margin_ = value;
}

// float control_radius = 36;
inline void ServerParam::clear_control_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.control_radius_ = 0;
}
inline float ServerParam::control_radius() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.control_radius)
  return _internal_control_radius();
}
inline void ServerParam::set_control_radius(float value) {
  _internal_set_control_radius(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.control_radius)
}
inline float ServerParam::_internal_control_radius() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.control_radius_;
}
inline void ServerParam::_internal_set_control_radius(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.control_radius_ = value;
}

// float control_radius_width = 37;
inline void ServerParam::clear_control_radius_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.control_radius_width_ = 0;
}
inline float ServerParam::control_radius_width() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.control_radius_width)
  return _internal_control_radius_width();
}
inline void ServerParam::set_control_radius_width(float value) {
  _internal_set_control_radius_width(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.control_radius_width)
}
inline float ServerParam::_internal_control_radius_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.control_radius_width_;
}
inline void ServerParam::_internal_set_control_radius_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.control_radius_width_ = value;
}

// float max_power = 38;
inline void ServerParam::clear_max_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_power_ = 0;
}
inline float ServerParam::max_power() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.max_power)
  return _internal_max_power();
}
inline void ServerParam::set_max_power(float value) {
  _internal_set_max_power(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.max_power)
}
inline float ServerParam::_internal_max_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_power_;
}
inline void ServerParam::_internal_set_max_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_power_ = value;
}

// float min_power = 39;
inline void ServerParam::clear_min_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_power_ = 0;
}
inline float ServerParam::min_power() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.min_power)
  return _internal_min_power();
}
inline void ServerParam::set_min_power(float value) {
  _internal_set_min_power(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.min_power)
}
inline float ServerParam::_internal_min_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_power_;
}
inline void ServerParam::_internal_set_min_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_power_ = value;
}

// float max_moment = 40;
inline void ServerParam::clear_max_moment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_moment_ = 0;
}
inline float ServerParam::max_moment() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.max_moment)
  return _internal_max_moment();
}
inline void ServerParam::set_max_moment(float value) {
  _internal_set_max_moment(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.max_moment)
}
inline float ServerParam::_internal_max_moment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_moment_;
}
inline void ServerParam::_internal_set_max_moment(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_moment_ = value;
}

// float min_moment = 41;
inline void ServerParam::clear_min_moment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_moment_ = 0;
}
inline float ServerParam::min_moment() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.min_moment)
  return _internal_min_moment();
}
inline void ServerParam::set_min_moment(float value) {
  _internal_set_min_moment(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.min_moment)
}
inline float ServerParam::_internal_min_moment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_moment_;
}
inline void ServerParam::_internal_set_min_moment(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_moment_ = value;
}

// float max_neck_moment = 42;
inline void ServerParam::clear_max_neck_moment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_neck_moment_ = 0;
}
inline float ServerParam::max_neck_moment() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.max_neck_moment)
  return _internal_max_neck_moment();
}
inline void ServerParam::set_max_neck_moment(float value) {
  _internal_set_max_neck_moment(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.max_neck_moment)
}
inline float ServerParam::_internal_max_neck_moment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_neck_moment_;
}
inline void ServerParam::_internal_set_max_neck_moment(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_neck_moment_ = value;
}

// float min_neck_moment = 43;
inline void ServerParam::clear_min_neck_moment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_neck_moment_ = 0;
}
inline float ServerParam::min_neck_moment() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.min_neck_moment)
  return _internal_min_neck_moment();
}
inline void ServerParam::set_min_neck_moment(float value) {
  _internal_set_min_neck_moment(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.min_neck_moment)
}
inline float ServerParam::_internal_min_neck_moment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_neck_moment_;
}
inline void ServerParam::_internal_set_min_neck_moment(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_neck_moment_ = value;
}

// float max_neck_angle = 44;
inline void ServerParam::clear_max_neck_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_neck_angle_ = 0;
}
inline float ServerParam::max_neck_angle() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.max_neck_angle)
  return _internal_max_neck_angle();
}
inline void ServerParam::set_max_neck_angle(float value) {
  _internal_set_max_neck_angle(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.max_neck_angle)
}
inline float ServerParam::_internal_max_neck_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_neck_angle_;
}
inline void ServerParam::_internal_set_max_neck_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_neck_angle_ = value;
}

// float min_neck_angle = 45;
inline void ServerParam::clear_min_neck_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_neck_angle_ = 0;
}
inline float ServerParam::min_neck_angle() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.min_neck_angle)
  return _internal_min_neck_angle();
}
inline void ServerParam::set_min_neck_angle(float value) {
  _internal_set_min_neck_angle(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.min_neck_angle)
}
inline float ServerParam::_internal_min_neck_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_neck_angle_;
}
inline void ServerParam::_internal_set_min_neck_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_neck_angle_ = value;
}

// float visible_angle = 46;
inline void ServerParam::clear_visible_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.visible_angle_ = 0;
}
inline float ServerParam::visible_angle() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.visible_angle)
  return _internal_visible_angle();
}
inline void ServerParam::set_visible_angle(float value) {
  _internal_set_visible_angle(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.visible_angle)
}
inline float ServerParam::_internal_visible_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visible_angle_;
}
inline void ServerParam::_internal_set_visible_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.visible_angle_ = value;
}

// float visible_distance = 47;
inline void ServerParam::clear_visible_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.visible_distance_ = 0;
}
inline float ServerParam::visible_distance() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.visible_distance)
  return _internal_visible_distance();
}
inline void ServerParam::set_visible_distance(float value) {
  _internal_set_visible_distance(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.visible_distance)
}
inline float ServerParam::_internal_visible_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visible_distance_;
}
inline void ServerParam::_internal_set_visible_distance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.visible_distance_ = value;
}

// float wind_dir = 48;
inline void ServerParam::clear_wind_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wind_dir_ = 0;
}
inline float ServerParam::wind_dir() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.wind_dir)
  return _internal_wind_dir();
}
inline void ServerParam::set_wind_dir(float value) {
  _internal_set_wind_dir(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.wind_dir)
}
inline float ServerParam::_internal_wind_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wind_dir_;
}
inline void ServerParam::_internal_set_wind_dir(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wind_dir_ = value;
}

// float wind_force = 49;
inline void ServerParam::clear_wind_force() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wind_force_ = 0;
}
inline float ServerParam::wind_force() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.wind_force)
  return _internal_wind_force();
}
inline void ServerParam::set_wind_force(float value) {
  _internal_set_wind_force(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.wind_force)
}
inline float ServerParam::_internal_wind_force() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wind_force_;
}
inline void ServerParam::_internal_set_wind_force(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wind_force_ = value;
}

// float wind_angle = 50;
inline void ServerParam::clear_wind_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wind_angle_ = 0;
}
inline float ServerParam::wind_angle() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.wind_angle)
  return _internal_wind_angle();
}
inline void ServerParam::set_wind_angle(float value) {
  _internal_set_wind_angle(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.wind_angle)
}
inline float ServerParam::_internal_wind_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wind_angle_;
}
inline void ServerParam::_internal_set_wind_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wind_angle_ = value;
}

// float wind_rand = 51;
inline void ServerParam::clear_wind_rand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wind_rand_ = 0;
}
inline float ServerParam::wind_rand() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.wind_rand)
  return _internal_wind_rand();
}
inline void ServerParam::set_wind_rand(float value) {
  _internal_set_wind_rand(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.wind_rand)
}
inline float ServerParam::_internal_wind_rand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wind_rand_;
}
inline void ServerParam::_internal_set_wind_rand(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wind_rand_ = value;
}

// float kickable_area = 52;
inline void ServerParam::clear_kickable_area() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kickable_area_ = 0;
}
inline float ServerParam::kickable_area() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.kickable_area)
  return _internal_kickable_area();
}
inline void ServerParam::set_kickable_area(float value) {
  _internal_set_kickable_area(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.kickable_area)
}
inline float ServerParam::_internal_kickable_area() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kickable_area_;
}
inline void ServerParam::_internal_set_kickable_area(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kickable_area_ = value;
}

// float catch_area_l = 53;
inline void ServerParam::clear_catch_area_l() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catch_area_l_ = 0;
}
inline float ServerParam::catch_area_l() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.catch_area_l)
  return _internal_catch_area_l();
}
inline void ServerParam::set_catch_area_l(float value) {
  _internal_set_catch_area_l(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.catch_area_l)
}
inline float ServerParam::_internal_catch_area_l() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.catch_area_l_;
}
inline void ServerParam::_internal_set_catch_area_l(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.catch_area_l_ = value;
}

// float catch_area_w = 54;
inline void ServerParam::clear_catch_area_w() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catch_area_w_ = 0;
}
inline float ServerParam::catch_area_w() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.catch_area_w)
  return _internal_catch_area_w();
}
inline void ServerParam::set_catch_area_w(float value) {
  _internal_set_catch_area_w(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.catch_area_w)
}
inline float ServerParam::_internal_catch_area_w() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.catch_area_w_;
}
inline void ServerParam::_internal_set_catch_area_w(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.catch_area_w_ = value;
}

// float catch_probability = 55;
inline void ServerParam::clear_catch_probability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catch_probability_ = 0;
}
inline float ServerParam::catch_probability() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.catch_probability)
  return _internal_catch_probability();
}
inline void ServerParam::set_catch_probability(float value) {
  _internal_set_catch_probability(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.catch_probability)
}
inline float ServerParam::_internal_catch_probability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.catch_probability_;
}
inline void ServerParam::_internal_set_catch_probability(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.catch_probability_ = value;
}

// int32 goalie_max_moves = 56;
inline void ServerParam::clear_goalie_max_moves() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goalie_max_moves_ = 0;
}
inline ::int32_t ServerParam::goalie_max_moves() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.goalie_max_moves)
  return _internal_goalie_max_moves();
}
inline void ServerParam::set_goalie_max_moves(::int32_t value) {
  _internal_set_goalie_max_moves(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.goalie_max_moves)
}
inline ::int32_t ServerParam::_internal_goalie_max_moves() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goalie_max_moves_;
}
inline void ServerParam::_internal_set_goalie_max_moves(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.goalie_max_moves_ = value;
}

// float corner_kick_margin = 57;
inline void ServerParam::clear_corner_kick_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.corner_kick_margin_ = 0;
}
inline float ServerParam::corner_kick_margin() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.corner_kick_margin)
  return _internal_corner_kick_margin();
}
inline void ServerParam::set_corner_kick_margin(float value) {
  _internal_set_corner_kick_margin(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.corner_kick_margin)
}
inline float ServerParam::_internal_corner_kick_margin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.corner_kick_margin_;
}
inline void ServerParam::_internal_set_corner_kick_margin(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.corner_kick_margin_ = value;
}

// float offside_active_area_size = 58;
inline void ServerParam::clear_offside_active_area_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offside_active_area_size_ = 0;
}
inline float ServerParam::offside_active_area_size() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.offside_active_area_size)
  return _internal_offside_active_area_size();
}
inline void ServerParam::set_offside_active_area_size(float value) {
  _internal_set_offside_active_area_size(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.offside_active_area_size)
}
inline float ServerParam::_internal_offside_active_area_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offside_active_area_size_;
}
inline void ServerParam::_internal_set_offside_active_area_size(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.offside_active_area_size_ = value;
}

// bool wind_none = 59;
inline void ServerParam::clear_wind_none() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wind_none_ = false;
}
inline bool ServerParam::wind_none() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.wind_none)
  return _internal_wind_none();
}
inline void ServerParam::set_wind_none(bool value) {
  _internal_set_wind_none(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.wind_none)
}
inline bool ServerParam::_internal_wind_none() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wind_none_;
}
inline void ServerParam::_internal_set_wind_none(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wind_none_ = value;
}

// bool use_wind_random = 60;
inline void ServerParam::clear_use_wind_random() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_wind_random_ = false;
}
inline bool ServerParam::use_wind_random() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.use_wind_random)
  return _internal_use_wind_random();
}
inline void ServerParam::set_use_wind_random(bool value) {
  _internal_set_use_wind_random(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.use_wind_random)
}
inline bool ServerParam::_internal_use_wind_random() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_wind_random_;
}
inline void ServerParam::_internal_set_use_wind_random(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.use_wind_random_ = value;
}

// int32 coach_say_count_max = 61;
inline void ServerParam::clear_coach_say_count_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.coach_say_count_max_ = 0;
}
inline ::int32_t ServerParam::coach_say_count_max() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.coach_say_count_max)
  return _internal_coach_say_count_max();
}
inline void ServerParam::set_coach_say_count_max(::int32_t value) {
  _internal_set_coach_say_count_max(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.coach_say_count_max)
}
inline ::int32_t ServerParam::_internal_coach_say_count_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.coach_say_count_max_;
}
inline void ServerParam::_internal_set_coach_say_count_max(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.coach_say_count_max_ = value;
}

// int32 coach_say_msg_size = 62;
inline void ServerParam::clear_coach_say_msg_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.coach_say_msg_size_ = 0;
}
inline ::int32_t ServerParam::coach_say_msg_size() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.coach_say_msg_size)
  return _internal_coach_say_msg_size();
}
inline void ServerParam::set_coach_say_msg_size(::int32_t value) {
  _internal_set_coach_say_msg_size(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.coach_say_msg_size)
}
inline ::int32_t ServerParam::_internal_coach_say_msg_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.coach_say_msg_size_;
}
inline void ServerParam::_internal_set_coach_say_msg_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.coach_say_msg_size_ = value;
}

// int32 clang_win_size = 63;
inline void ServerParam::clear_clang_win_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clang_win_size_ = 0;
}
inline ::int32_t ServerParam::clang_win_size() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.clang_win_size)
  return _internal_clang_win_size();
}
inline void ServerParam::set_clang_win_size(::int32_t value) {
  _internal_set_clang_win_size(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.clang_win_size)
}
inline ::int32_t ServerParam::_internal_clang_win_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clang_win_size_;
}
inline void ServerParam::_internal_set_clang_win_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clang_win_size_ = value;
}

// int32 clang_define_win = 64;
inline void ServerParam::clear_clang_define_win() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clang_define_win_ = 0;
}
inline ::int32_t ServerParam::clang_define_win() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.clang_define_win)
  return _internal_clang_define_win();
}
inline void ServerParam::set_clang_define_win(::int32_t value) {
  _internal_set_clang_define_win(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.clang_define_win)
}
inline ::int32_t ServerParam::_internal_clang_define_win() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clang_define_win_;
}
inline void ServerParam::_internal_set_clang_define_win(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clang_define_win_ = value;
}

// int32 clang_meta_win = 65;
inline void ServerParam::clear_clang_meta_win() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clang_meta_win_ = 0;
}
inline ::int32_t ServerParam::clang_meta_win() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.clang_meta_win)
  return _internal_clang_meta_win();
}
inline void ServerParam::set_clang_meta_win(::int32_t value) {
  _internal_set_clang_meta_win(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.clang_meta_win)
}
inline ::int32_t ServerParam::_internal_clang_meta_win() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clang_meta_win_;
}
inline void ServerParam::_internal_set_clang_meta_win(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clang_meta_win_ = value;
}

// int32 clang_advice_win = 66;
inline void ServerParam::clear_clang_advice_win() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clang_advice_win_ = 0;
}
inline ::int32_t ServerParam::clang_advice_win() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.clang_advice_win)
  return _internal_clang_advice_win();
}
inline void ServerParam::set_clang_advice_win(::int32_t value) {
  _internal_set_clang_advice_win(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.clang_advice_win)
}
inline ::int32_t ServerParam::_internal_clang_advice_win() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clang_advice_win_;
}
inline void ServerParam::_internal_set_clang_advice_win(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clang_advice_win_ = value;
}

// int32 clang_info_win = 67;
inline void ServerParam::clear_clang_info_win() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clang_info_win_ = 0;
}
inline ::int32_t ServerParam::clang_info_win() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.clang_info_win)
  return _internal_clang_info_win();
}
inline void ServerParam::set_clang_info_win(::int32_t value) {
  _internal_set_clang_info_win(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.clang_info_win)
}
inline ::int32_t ServerParam::_internal_clang_info_win() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clang_info_win_;
}
inline void ServerParam::_internal_set_clang_info_win(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clang_info_win_ = value;
}

// int32 clang_mess_delay = 68;
inline void ServerParam::clear_clang_mess_delay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clang_mess_delay_ = 0;
}
inline ::int32_t ServerParam::clang_mess_delay() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.clang_mess_delay)
  return _internal_clang_mess_delay();
}
inline void ServerParam::set_clang_mess_delay(::int32_t value) {
  _internal_set_clang_mess_delay(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.clang_mess_delay)
}
inline ::int32_t ServerParam::_internal_clang_mess_delay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clang_mess_delay_;
}
inline void ServerParam::_internal_set_clang_mess_delay(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clang_mess_delay_ = value;
}

// int32 clang_mess_per_cycle = 69;
inline void ServerParam::clear_clang_mess_per_cycle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clang_mess_per_cycle_ = 0;
}
inline ::int32_t ServerParam::clang_mess_per_cycle() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.clang_mess_per_cycle)
  return _internal_clang_mess_per_cycle();
}
inline void ServerParam::set_clang_mess_per_cycle(::int32_t value) {
  _internal_set_clang_mess_per_cycle(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.clang_mess_per_cycle)
}
inline ::int32_t ServerParam::_internal_clang_mess_per_cycle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clang_mess_per_cycle_;
}
inline void ServerParam::_internal_set_clang_mess_per_cycle(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clang_mess_per_cycle_ = value;
}

// int32 half_time = 70;
inline void ServerParam::clear_half_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.half_time_ = 0;
}
inline ::int32_t ServerParam::half_time() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.half_time)
  return _internal_half_time();
}
inline void ServerParam::set_half_time(::int32_t value) {
  _internal_set_half_time(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.half_time)
}
inline ::int32_t ServerParam::_internal_half_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.half_time_;
}
inline void ServerParam::_internal_set_half_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.half_time_ = value;
}

// int32 simulator_step = 71;
inline void ServerParam::clear_simulator_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.simulator_step_ = 0;
}
inline ::int32_t ServerParam::simulator_step() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.simulator_step)
  return _internal_simulator_step();
}
inline void ServerParam::set_simulator_step(::int32_t value) {
  _internal_set_simulator_step(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.simulator_step)
}
inline ::int32_t ServerParam::_internal_simulator_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.simulator_step_;
}
inline void ServerParam::_internal_set_simulator_step(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.simulator_step_ = value;
}

// int32 send_step = 72;
inline void ServerParam::clear_send_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.send_step_ = 0;
}
inline ::int32_t ServerParam::send_step() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.send_step)
  return _internal_send_step();
}
inline void ServerParam::set_send_step(::int32_t value) {
  _internal_set_send_step(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.send_step)
}
inline ::int32_t ServerParam::_internal_send_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.send_step_;
}
inline void ServerParam::_internal_set_send_step(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.send_step_ = value;
}

// int32 recv_step = 73;
inline void ServerParam::clear_recv_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recv_step_ = 0;
}
inline ::int32_t ServerParam::recv_step() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.recv_step)
  return _internal_recv_step();
}
inline void ServerParam::set_recv_step(::int32_t value) {
  _internal_set_recv_step(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.recv_step)
}
inline ::int32_t ServerParam::_internal_recv_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recv_step_;
}
inline void ServerParam::_internal_set_recv_step(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recv_step_ = value;
}

// int32 sense_body_step = 74;
inline void ServerParam::clear_sense_body_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sense_body_step_ = 0;
}
inline ::int32_t ServerParam::sense_body_step() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.sense_body_step)
  return _internal_sense_body_step();
}
inline void ServerParam::set_sense_body_step(::int32_t value) {
  _internal_set_sense_body_step(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.sense_body_step)
}
inline ::int32_t ServerParam::_internal_sense_body_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sense_body_step_;
}
inline void ServerParam::_internal_set_sense_body_step(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sense_body_step_ = value;
}

// int32 lcm_step = 75;
inline void ServerParam::clear_lcm_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lcm_step_ = 0;
}
inline ::int32_t ServerParam::lcm_step() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.lcm_step)
  return _internal_lcm_step();
}
inline void ServerParam::set_lcm_step(::int32_t value) {
  _internal_set_lcm_step(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.lcm_step)
}
inline ::int32_t ServerParam::_internal_lcm_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lcm_step_;
}
inline void ServerParam::_internal_set_lcm_step(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lcm_step_ = value;
}

// int32 player_say_msg_size = 76;
inline void ServerParam::clear_player_say_msg_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_say_msg_size_ = 0;
}
inline ::int32_t ServerParam::player_say_msg_size() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_say_msg_size)
  return _internal_player_say_msg_size();
}
inline void ServerParam::set_player_say_msg_size(::int32_t value) {
  _internal_set_player_say_msg_size(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_say_msg_size)
}
inline ::int32_t ServerParam::_internal_player_say_msg_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_say_msg_size_;
}
inline void ServerParam::_internal_set_player_say_msg_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_say_msg_size_ = value;
}

// int32 player_hear_max = 77;
inline void ServerParam::clear_player_hear_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_hear_max_ = 0;
}
inline ::int32_t ServerParam::player_hear_max() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_hear_max)
  return _internal_player_hear_max();
}
inline void ServerParam::set_player_hear_max(::int32_t value) {
  _internal_set_player_hear_max(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_hear_max)
}
inline ::int32_t ServerParam::_internal_player_hear_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_hear_max_;
}
inline void ServerParam::_internal_set_player_hear_max(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_hear_max_ = value;
}

// int32 player_hear_inc = 78;
inline void ServerParam::clear_player_hear_inc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_hear_inc_ = 0;
}
inline ::int32_t ServerParam::player_hear_inc() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_hear_inc)
  return _internal_player_hear_inc();
}
inline void ServerParam::set_player_hear_inc(::int32_t value) {
  _internal_set_player_hear_inc(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_hear_inc)
}
inline ::int32_t ServerParam::_internal_player_hear_inc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_hear_inc_;
}
inline void ServerParam::_internal_set_player_hear_inc(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_hear_inc_ = value;
}

// int32 player_hear_decay = 79;
inline void ServerParam::clear_player_hear_decay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_hear_decay_ = 0;
}
inline ::int32_t ServerParam::player_hear_decay() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_hear_decay)
  return _internal_player_hear_decay();
}
inline void ServerParam::set_player_hear_decay(::int32_t value) {
  _internal_set_player_hear_decay(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_hear_decay)
}
inline ::int32_t ServerParam::_internal_player_hear_decay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_hear_decay_;
}
inline void ServerParam::_internal_set_player_hear_decay(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_hear_decay_ = value;
}

// int32 catch_ban_cycle = 80;
inline void ServerParam::clear_catch_ban_cycle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catch_ban_cycle_ = 0;
}
inline ::int32_t ServerParam::catch_ban_cycle() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.catch_ban_cycle)
  return _internal_catch_ban_cycle();
}
inline void ServerParam::set_catch_ban_cycle(::int32_t value) {
  _internal_set_catch_ban_cycle(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.catch_ban_cycle)
}
inline ::int32_t ServerParam::_internal_catch_ban_cycle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.catch_ban_cycle_;
}
inline void ServerParam::_internal_set_catch_ban_cycle(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.catch_ban_cycle_ = value;
}

// int32 slow_down_factor = 81;
inline void ServerParam::clear_slow_down_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slow_down_factor_ = 0;
}
inline ::int32_t ServerParam::slow_down_factor() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.slow_down_factor)
  return _internal_slow_down_factor();
}
inline void ServerParam::set_slow_down_factor(::int32_t value) {
  _internal_set_slow_down_factor(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.slow_down_factor)
}
inline ::int32_t ServerParam::_internal_slow_down_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slow_down_factor_;
}
inline void ServerParam::_internal_set_slow_down_factor(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.slow_down_factor_ = value;
}

// bool use_offside = 82;
inline void ServerParam::clear_use_offside() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_offside_ = false;
}
inline bool ServerParam::use_offside() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.use_offside)
  return _internal_use_offside();
}
inline void ServerParam::set_use_offside(bool value) {
  _internal_set_use_offside(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.use_offside)
}
inline bool ServerParam::_internal_use_offside() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_offside_;
}
inline void ServerParam::_internal_set_use_offside(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.use_offside_ = value;
}

// bool kickoff_offside = 83;
inline void ServerParam::clear_kickoff_offside() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kickoff_offside_ = false;
}
inline bool ServerParam::kickoff_offside() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.kickoff_offside)
  return _internal_kickoff_offside();
}
inline void ServerParam::set_kickoff_offside(bool value) {
  _internal_set_kickoff_offside(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.kickoff_offside)
}
inline bool ServerParam::_internal_kickoff_offside() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kickoff_offside_;
}
inline void ServerParam::_internal_set_kickoff_offside(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kickoff_offside_ = value;
}

// float offside_kick_margin = 84;
inline void ServerParam::clear_offside_kick_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offside_kick_margin_ = 0;
}
inline float ServerParam::offside_kick_margin() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.offside_kick_margin)
  return _internal_offside_kick_margin();
}
inline void ServerParam::set_offside_kick_margin(float value) {
  _internal_set_offside_kick_margin(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.offside_kick_margin)
}
inline float ServerParam::_internal_offside_kick_margin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offside_kick_margin_;
}
inline void ServerParam::_internal_set_offside_kick_margin(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.offside_kick_margin_ = value;
}

// float audio_cut_dist = 85;
inline void ServerParam::clear_audio_cut_dist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_cut_dist_ = 0;
}
inline float ServerParam::audio_cut_dist() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.audio_cut_dist)
  return _internal_audio_cut_dist();
}
inline void ServerParam::set_audio_cut_dist(float value) {
  _internal_set_audio_cut_dist(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.audio_cut_dist)
}
inline float ServerParam::_internal_audio_cut_dist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_cut_dist_;
}
inline void ServerParam::_internal_set_audio_cut_dist(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.audio_cut_dist_ = value;
}

// float dist_quantize_step = 86;
inline void ServerParam::clear_dist_quantize_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dist_quantize_step_ = 0;
}
inline float ServerParam::dist_quantize_step() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.dist_quantize_step)
  return _internal_dist_quantize_step();
}
inline void ServerParam::set_dist_quantize_step(float value) {
  _internal_set_dist_quantize_step(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.dist_quantize_step)
}
inline float ServerParam::_internal_dist_quantize_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dist_quantize_step_;
}
inline void ServerParam::_internal_set_dist_quantize_step(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dist_quantize_step_ = value;
}

// float landmark_dist_quantize_step = 87;
inline void ServerParam::clear_landmark_dist_quantize_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.landmark_dist_quantize_step_ = 0;
}
inline float ServerParam::landmark_dist_quantize_step() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.landmark_dist_quantize_step)
  return _internal_landmark_dist_quantize_step();
}
inline void ServerParam::set_landmark_dist_quantize_step(float value) {
  _internal_set_landmark_dist_quantize_step(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.landmark_dist_quantize_step)
}
inline float ServerParam::_internal_landmark_dist_quantize_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.landmark_dist_quantize_step_;
}
inline void ServerParam::_internal_set_landmark_dist_quantize_step(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.landmark_dist_quantize_step_ = value;
}

// float dir_quantize_step = 88;
inline void ServerParam::clear_dir_quantize_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dir_quantize_step_ = 0;
}
inline float ServerParam::dir_quantize_step() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.dir_quantize_step)
  return _internal_dir_quantize_step();
}
inline void ServerParam::set_dir_quantize_step(float value) {
  _internal_set_dir_quantize_step(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.dir_quantize_step)
}
inline float ServerParam::_internal_dir_quantize_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dir_quantize_step_;
}
inline void ServerParam::_internal_set_dir_quantize_step(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dir_quantize_step_ = value;
}

// float dist_quantize_step_l = 89;
inline void ServerParam::clear_dist_quantize_step_l() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dist_quantize_step_l_ = 0;
}
inline float ServerParam::dist_quantize_step_l() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.dist_quantize_step_l)
  return _internal_dist_quantize_step_l();
}
inline void ServerParam::set_dist_quantize_step_l(float value) {
  _internal_set_dist_quantize_step_l(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.dist_quantize_step_l)
}
inline float ServerParam::_internal_dist_quantize_step_l() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dist_quantize_step_l_;
}
inline void ServerParam::_internal_set_dist_quantize_step_l(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dist_quantize_step_l_ = value;
}

// float dist_quantize_step_r = 90;
inline void ServerParam::clear_dist_quantize_step_r() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dist_quantize_step_r_ = 0;
}
inline float ServerParam::dist_quantize_step_r() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.dist_quantize_step_r)
  return _internal_dist_quantize_step_r();
}
inline void ServerParam::set_dist_quantize_step_r(float value) {
  _internal_set_dist_quantize_step_r(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.dist_quantize_step_r)
}
inline float ServerParam::_internal_dist_quantize_step_r() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dist_quantize_step_r_;
}
inline void ServerParam::_internal_set_dist_quantize_step_r(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dist_quantize_step_r_ = value;
}

// float landmark_dist_quantize_step_l = 91;
inline void ServerParam::clear_landmark_dist_quantize_step_l() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.landmark_dist_quantize_step_l_ = 0;
}
inline float ServerParam::landmark_dist_quantize_step_l() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.landmark_dist_quantize_step_l)
  return _internal_landmark_dist_quantize_step_l();
}
inline void ServerParam::set_landmark_dist_quantize_step_l(float value) {
  _internal_set_landmark_dist_quantize_step_l(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.landmark_dist_quantize_step_l)
}
inline float ServerParam::_internal_landmark_dist_quantize_step_l() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.landmark_dist_quantize_step_l_;
}
inline void ServerParam::_internal_set_landmark_dist_quantize_step_l(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.landmark_dist_quantize_step_l_ = value;
}

// float landmark_dist_quantize_step_r = 92;
inline void ServerParam::clear_landmark_dist_quantize_step_r() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.landmark_dist_quantize_step_r_ = 0;
}
inline float ServerParam::landmark_dist_quantize_step_r() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.landmark_dist_quantize_step_r)
  return _internal_landmark_dist_quantize_step_r();
}
inline void ServerParam::set_landmark_dist_quantize_step_r(float value) {
  _internal_set_landmark_dist_quantize_step_r(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.landmark_dist_quantize_step_r)
}
inline float ServerParam::_internal_landmark_dist_quantize_step_r() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.landmark_dist_quantize_step_r_;
}
inline void ServerParam::_internal_set_landmark_dist_quantize_step_r(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.landmark_dist_quantize_step_r_ = value;
}

// float dir_quantize_step_l = 93;
inline void ServerParam::clear_dir_quantize_step_l() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dir_quantize_step_l_ = 0;
}
inline float ServerParam::dir_quantize_step_l() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.dir_quantize_step_l)
  return _internal_dir_quantize_step_l();
}
inline void ServerParam::set_dir_quantize_step_l(float value) {
  _internal_set_dir_quantize_step_l(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.dir_quantize_step_l)
}
inline float ServerParam::_internal_dir_quantize_step_l() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dir_quantize_step_l_;
}
inline void ServerParam::_internal_set_dir_quantize_step_l(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dir_quantize_step_l_ = value;
}

// float dir_quantize_step_r = 94;
inline void ServerParam::clear_dir_quantize_step_r() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dir_quantize_step_r_ = 0;
}
inline float ServerParam::dir_quantize_step_r() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.dir_quantize_step_r)
  return _internal_dir_quantize_step_r();
}
inline void ServerParam::set_dir_quantize_step_r(float value) {
  _internal_set_dir_quantize_step_r(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.dir_quantize_step_r)
}
inline float ServerParam::_internal_dir_quantize_step_r() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dir_quantize_step_r_;
}
inline void ServerParam::_internal_set_dir_quantize_step_r(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dir_quantize_step_r_ = value;
}

// bool coach_mode = 95;
inline void ServerParam::clear_coach_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.coach_mode_ = false;
}
inline bool ServerParam::coach_mode() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.coach_mode)
  return _internal_coach_mode();
}
inline void ServerParam::set_coach_mode(bool value) {
  _internal_set_coach_mode(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.coach_mode)
}
inline bool ServerParam::_internal_coach_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.coach_mode_;
}
inline void ServerParam::_internal_set_coach_mode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.coach_mode_ = value;
}

// bool coach_with_referee_mode = 96;
inline void ServerParam::clear_coach_with_referee_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.coach_with_referee_mode_ = false;
}
inline bool ServerParam::coach_with_referee_mode() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.coach_with_referee_mode)
  return _internal_coach_with_referee_mode();
}
inline void ServerParam::set_coach_with_referee_mode(bool value) {
  _internal_set_coach_with_referee_mode(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.coach_with_referee_mode)
}
inline bool ServerParam::_internal_coach_with_referee_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.coach_with_referee_mode_;
}
inline void ServerParam::_internal_set_coach_with_referee_mode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.coach_with_referee_mode_ = value;
}

// bool use_old_coach_hear = 97;
inline void ServerParam::clear_use_old_coach_hear() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_old_coach_hear_ = false;
}
inline bool ServerParam::use_old_coach_hear() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.use_old_coach_hear)
  return _internal_use_old_coach_hear();
}
inline void ServerParam::set_use_old_coach_hear(bool value) {
  _internal_set_use_old_coach_hear(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.use_old_coach_hear)
}
inline bool ServerParam::_internal_use_old_coach_hear() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_old_coach_hear_;
}
inline void ServerParam::_internal_set_use_old_coach_hear(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.use_old_coach_hear_ = value;
}

// float slowness_on_top_for_left_team = 98;
inline void ServerParam::clear_slowness_on_top_for_left_team() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slowness_on_top_for_left_team_ = 0;
}
inline float ServerParam::slowness_on_top_for_left_team() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.slowness_on_top_for_left_team)
  return _internal_slowness_on_top_for_left_team();
}
inline void ServerParam::set_slowness_on_top_for_left_team(float value) {
  _internal_set_slowness_on_top_for_left_team(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.slowness_on_top_for_left_team)
}
inline float ServerParam::_internal_slowness_on_top_for_left_team() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slowness_on_top_for_left_team_;
}
inline void ServerParam::_internal_set_slowness_on_top_for_left_team(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.slowness_on_top_for_left_team_ = value;
}

// float slowness_on_top_for_right_team = 99;
inline void ServerParam::clear_slowness_on_top_for_right_team() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slowness_on_top_for_right_team_ = 0;
}
inline float ServerParam::slowness_on_top_for_right_team() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.slowness_on_top_for_right_team)
  return _internal_slowness_on_top_for_right_team();
}
inline void ServerParam::set_slowness_on_top_for_right_team(float value) {
  _internal_set_slowness_on_top_for_right_team(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.slowness_on_top_for_right_team)
}
inline float ServerParam::_internal_slowness_on_top_for_right_team() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slowness_on_top_for_right_team_;
}
inline void ServerParam::_internal_set_slowness_on_top_for_right_team(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.slowness_on_top_for_right_team_ = value;
}

// int32 start_goal_l = 100;
inline void ServerParam::clear_start_goal_l() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_goal_l_ = 0;
}
inline ::int32_t ServerParam::start_goal_l() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.start_goal_l)
  return _internal_start_goal_l();
}
inline void ServerParam::set_start_goal_l(::int32_t value) {
  _internal_set_start_goal_l(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.start_goal_l)
}
inline ::int32_t ServerParam::_internal_start_goal_l() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_goal_l_;
}
inline void ServerParam::_internal_set_start_goal_l(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_goal_l_ = value;
}

// int32 start_goal_r = 101;
inline void ServerParam::clear_start_goal_r() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_goal_r_ = 0;
}
inline ::int32_t ServerParam::start_goal_r() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.start_goal_r)
  return _internal_start_goal_r();
}
inline void ServerParam::set_start_goal_r(::int32_t value) {
  _internal_set_start_goal_r(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.start_goal_r)
}
inline ::int32_t ServerParam::_internal_start_goal_r() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_goal_r_;
}
inline void ServerParam::_internal_set_start_goal_r(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_goal_r_ = value;
}

// bool fullstate_l = 102;
inline void ServerParam::clear_fullstate_l() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fullstate_l_ = false;
}
inline bool ServerParam::fullstate_l() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.fullstate_l)
  return _internal_fullstate_l();
}
inline void ServerParam::set_fullstate_l(bool value) {
  _internal_set_fullstate_l(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.fullstate_l)
}
inline bool ServerParam::_internal_fullstate_l() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fullstate_l_;
}
inline void ServerParam::_internal_set_fullstate_l(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fullstate_l_ = value;
}

// bool fullstate_r = 103;
inline void ServerParam::clear_fullstate_r() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fullstate_r_ = false;
}
inline bool ServerParam::fullstate_r() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.fullstate_r)
  return _internal_fullstate_r();
}
inline void ServerParam::set_fullstate_r(bool value) {
  _internal_set_fullstate_r(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.fullstate_r)
}
inline bool ServerParam::_internal_fullstate_r() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fullstate_r_;
}
inline void ServerParam::_internal_set_fullstate_r(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fullstate_r_ = value;
}

// int32 drop_ball_time = 104;
inline void ServerParam::clear_drop_ball_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.drop_ball_time_ = 0;
}
inline ::int32_t ServerParam::drop_ball_time() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.drop_ball_time)
  return _internal_drop_ball_time();
}
inline void ServerParam::set_drop_ball_time(::int32_t value) {
  _internal_set_drop_ball_time(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.drop_ball_time)
}
inline ::int32_t ServerParam::_internal_drop_ball_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.drop_ball_time_;
}
inline void ServerParam::_internal_set_drop_ball_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.drop_ball_time_ = value;
}

// bool synch_mode = 105;
inline void ServerParam::clear_synch_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.synch_mode_ = false;
}
inline bool ServerParam::synch_mode() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.synch_mode)
  return _internal_synch_mode();
}
inline void ServerParam::set_synch_mode(bool value) {
  _internal_set_synch_mode(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.synch_mode)
}
inline bool ServerParam::_internal_synch_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.synch_mode_;
}
inline void ServerParam::_internal_set_synch_mode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.synch_mode_ = value;
}

// int32 synch_offset = 106;
inline void ServerParam::clear_synch_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.synch_offset_ = 0;
}
inline ::int32_t ServerParam::synch_offset() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.synch_offset)
  return _internal_synch_offset();
}
inline void ServerParam::set_synch_offset(::int32_t value) {
  _internal_set_synch_offset(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.synch_offset)
}
inline ::int32_t ServerParam::_internal_synch_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.synch_offset_;
}
inline void ServerParam::_internal_set_synch_offset(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.synch_offset_ = value;
}

// int32 synch_micro_sleep = 107;
inline void ServerParam::clear_synch_micro_sleep() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.synch_micro_sleep_ = 0;
}
inline ::int32_t ServerParam::synch_micro_sleep() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.synch_micro_sleep)
  return _internal_synch_micro_sleep();
}
inline void ServerParam::set_synch_micro_sleep(::int32_t value) {
  _internal_set_synch_micro_sleep(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.synch_micro_sleep)
}
inline ::int32_t ServerParam::_internal_synch_micro_sleep() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.synch_micro_sleep_;
}
inline void ServerParam::_internal_set_synch_micro_sleep(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.synch_micro_sleep_ = value;
}

// int32 point_to_ban = 108;
inline void ServerParam::clear_point_to_ban() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.point_to_ban_ = 0;
}
inline ::int32_t ServerParam::point_to_ban() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.point_to_ban)
  return _internal_point_to_ban();
}
inline void ServerParam::set_point_to_ban(::int32_t value) {
  _internal_set_point_to_ban(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.point_to_ban)
}
inline ::int32_t ServerParam::_internal_point_to_ban() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.point_to_ban_;
}
inline void ServerParam::_internal_set_point_to_ban(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.point_to_ban_ = value;
}

// int32 point_to_duration = 109;
inline void ServerParam::clear_point_to_duration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.point_to_duration_ = 0;
}
inline ::int32_t ServerParam::point_to_duration() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.point_to_duration)
  return _internal_point_to_duration();
}
inline void ServerParam::set_point_to_duration(::int32_t value) {
  _internal_set_point_to_duration(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.point_to_duration)
}
inline ::int32_t ServerParam::_internal_point_to_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.point_to_duration_;
}
inline void ServerParam::_internal_set_point_to_duration(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.point_to_duration_ = value;
}

// int32 player_port = 110;
inline void ServerParam::clear_player_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_port_ = 0;
}
inline ::int32_t ServerParam::player_port() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_port)
  return _internal_player_port();
}
inline void ServerParam::set_player_port(::int32_t value) {
  _internal_set_player_port(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_port)
}
inline ::int32_t ServerParam::_internal_player_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_port_;
}
inline void ServerParam::_internal_set_player_port(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_port_ = value;
}

// int32 trainer_port = 111;
inline void ServerParam::clear_trainer_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trainer_port_ = 0;
}
inline ::int32_t ServerParam::trainer_port() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.trainer_port)
  return _internal_trainer_port();
}
inline void ServerParam::set_trainer_port(::int32_t value) {
  _internal_set_trainer_port(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.trainer_port)
}
inline ::int32_t ServerParam::_internal_trainer_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trainer_port_;
}
inline void ServerParam::_internal_set_trainer_port(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.trainer_port_ = value;
}

// int32 online_coach_port = 112;
inline void ServerParam::clear_online_coach_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.online_coach_port_ = 0;
}
inline ::int32_t ServerParam::online_coach_port() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.online_coach_port)
  return _internal_online_coach_port();
}
inline void ServerParam::set_online_coach_port(::int32_t value) {
  _internal_set_online_coach_port(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.online_coach_port)
}
inline ::int32_t ServerParam::_internal_online_coach_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.online_coach_port_;
}
inline void ServerParam::_internal_set_online_coach_port(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.online_coach_port_ = value;
}

// bool verbose_mode = 113;
inline void ServerParam::clear_verbose_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbose_mode_ = false;
}
inline bool ServerParam::verbose_mode() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.verbose_mode)
  return _internal_verbose_mode();
}
inline void ServerParam::set_verbose_mode(bool value) {
  _internal_set_verbose_mode(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.verbose_mode)
}
inline bool ServerParam::_internal_verbose_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.verbose_mode_;
}
inline void ServerParam::_internal_set_verbose_mode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbose_mode_ = value;
}

// int32 coach_send_vi_step = 114;
inline void ServerParam::clear_coach_send_vi_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.coach_send_vi_step_ = 0;
}
inline ::int32_t ServerParam::coach_send_vi_step() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.coach_send_vi_step)
  return _internal_coach_send_vi_step();
}
inline void ServerParam::set_coach_send_vi_step(::int32_t value) {
  _internal_set_coach_send_vi_step(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.coach_send_vi_step)
}
inline ::int32_t ServerParam::_internal_coach_send_vi_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.coach_send_vi_step_;
}
inline void ServerParam::_internal_set_coach_send_vi_step(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.coach_send_vi_step_ = value;
}

// string replay_file = 115;
inline void ServerParam::clear_replay_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.replay_file_.ClearToEmpty();
}
inline const std::string& ServerParam::replay_file() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.replay_file)
  return _internal_replay_file();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_replay_file(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.replay_file_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.replay_file)
}
inline std::string* ServerParam::mutable_replay_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_replay_file();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.replay_file)
  return _s;
}
inline const std::string& ServerParam::_internal_replay_file() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.replay_file_.Get();
}
inline void ServerParam::_internal_set_replay_file(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.replay_file_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_replay_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.replay_file_.Mutable( GetArena());
}
inline std::string* ServerParam::release_replay_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.replay_file)
  return _impl_.replay_file_.Release();
}
inline void ServerParam::set_allocated_replay_file(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.replay_file_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.replay_file_.IsDefault()) {
          _impl_.replay_file_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.replay_file)
}

// string landmark_file = 116;
inline void ServerParam::clear_landmark_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.landmark_file_.ClearToEmpty();
}
inline const std::string& ServerParam::landmark_file() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.landmark_file)
  return _internal_landmark_file();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_landmark_file(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.landmark_file_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.landmark_file)
}
inline std::string* ServerParam::mutable_landmark_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_landmark_file();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.landmark_file)
  return _s;
}
inline const std::string& ServerParam::_internal_landmark_file() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.landmark_file_.Get();
}
inline void ServerParam::_internal_set_landmark_file(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.landmark_file_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_landmark_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.landmark_file_.Mutable( GetArena());
}
inline std::string* ServerParam::release_landmark_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.landmark_file)
  return _impl_.landmark_file_.Release();
}
inline void ServerParam::set_allocated_landmark_file(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.landmark_file_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.landmark_file_.IsDefault()) {
          _impl_.landmark_file_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.landmark_file)
}

// bool send_comms = 117;
inline void ServerParam::clear_send_comms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.send_comms_ = false;
}
inline bool ServerParam::send_comms() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.send_comms)
  return _internal_send_comms();
}
inline void ServerParam::set_send_comms(bool value) {
  _internal_set_send_comms(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.send_comms)
}
inline bool ServerParam::_internal_send_comms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.send_comms_;
}
inline void ServerParam::_internal_set_send_comms(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.send_comms_ = value;
}

// bool text_logging = 118;
inline void ServerParam::clear_text_logging() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_logging_ = false;
}
inline bool ServerParam::text_logging() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.text_logging)
  return _internal_text_logging();
}
inline void ServerParam::set_text_logging(bool value) {
  _internal_set_text_logging(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.text_logging)
}
inline bool ServerParam::_internal_text_logging() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_logging_;
}
inline void ServerParam::_internal_set_text_logging(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_logging_ = value;
}

// bool game_logging = 119;
inline void ServerParam::clear_game_logging() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_logging_ = false;
}
inline bool ServerParam::game_logging() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.game_logging)
  return _internal_game_logging();
}
inline void ServerParam::set_game_logging(bool value) {
  _internal_set_game_logging(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.game_logging)
}
inline bool ServerParam::_internal_game_logging() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_logging_;
}
inline void ServerParam::_internal_set_game_logging(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.game_logging_ = value;
}

// int32 game_log_version = 120;
inline void ServerParam::clear_game_log_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_log_version_ = 0;
}
inline ::int32_t ServerParam::game_log_version() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.game_log_version)
  return _internal_game_log_version();
}
inline void ServerParam::set_game_log_version(::int32_t value) {
  _internal_set_game_log_version(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.game_log_version)
}
inline ::int32_t ServerParam::_internal_game_log_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_log_version_;
}
inline void ServerParam::_internal_set_game_log_version(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.game_log_version_ = value;
}

// string text_log_dir = 121;
inline void ServerParam::clear_text_log_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_log_dir_.ClearToEmpty();
}
inline const std::string& ServerParam::text_log_dir() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.text_log_dir)
  return _internal_text_log_dir();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_text_log_dir(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_log_dir_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.text_log_dir)
}
inline std::string* ServerParam::mutable_text_log_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text_log_dir();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.text_log_dir)
  return _s;
}
inline const std::string& ServerParam::_internal_text_log_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_log_dir_.Get();
}
inline void ServerParam::_internal_set_text_log_dir(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_log_dir_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_text_log_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_log_dir_.Mutable( GetArena());
}
inline std::string* ServerParam::release_text_log_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.text_log_dir)
  return _impl_.text_log_dir_.Release();
}
inline void ServerParam::set_allocated_text_log_dir(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_log_dir_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_log_dir_.IsDefault()) {
          _impl_.text_log_dir_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.text_log_dir)
}

// string game_log_dir = 122;
inline void ServerParam::clear_game_log_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_log_dir_.ClearToEmpty();
}
inline const std::string& ServerParam::game_log_dir() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.game_log_dir)
  return _internal_game_log_dir();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_game_log_dir(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.game_log_dir_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.game_log_dir)
}
inline std::string* ServerParam::mutable_game_log_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_game_log_dir();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.game_log_dir)
  return _s;
}
inline const std::string& ServerParam::_internal_game_log_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_log_dir_.Get();
}
inline void ServerParam::_internal_set_game_log_dir(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.game_log_dir_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_game_log_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.game_log_dir_.Mutable( GetArena());
}
inline std::string* ServerParam::release_game_log_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.game_log_dir)
  return _impl_.game_log_dir_.Release();
}
inline void ServerParam::set_allocated_game_log_dir(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_log_dir_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.game_log_dir_.IsDefault()) {
          _impl_.game_log_dir_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.game_log_dir)
}

// string text_log_fixed_name = 123;
inline void ServerParam::clear_text_log_fixed_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_log_fixed_name_.ClearToEmpty();
}
inline const std::string& ServerParam::text_log_fixed_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.text_log_fixed_name)
  return _internal_text_log_fixed_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_text_log_fixed_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_log_fixed_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.text_log_fixed_name)
}
inline std::string* ServerParam::mutable_text_log_fixed_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text_log_fixed_name();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.text_log_fixed_name)
  return _s;
}
inline const std::string& ServerParam::_internal_text_log_fixed_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_log_fixed_name_.Get();
}
inline void ServerParam::_internal_set_text_log_fixed_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_log_fixed_name_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_text_log_fixed_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_log_fixed_name_.Mutable( GetArena());
}
inline std::string* ServerParam::release_text_log_fixed_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.text_log_fixed_name)
  return _impl_.text_log_fixed_name_.Release();
}
inline void ServerParam::set_allocated_text_log_fixed_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_log_fixed_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_log_fixed_name_.IsDefault()) {
          _impl_.text_log_fixed_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.text_log_fixed_name)
}

// string game_log_fixed_name = 124;
inline void ServerParam::clear_game_log_fixed_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_log_fixed_name_.ClearToEmpty();
}
inline const std::string& ServerParam::game_log_fixed_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.game_log_fixed_name)
  return _internal_game_log_fixed_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_game_log_fixed_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.game_log_fixed_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.game_log_fixed_name)
}
inline std::string* ServerParam::mutable_game_log_fixed_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_game_log_fixed_name();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.game_log_fixed_name)
  return _s;
}
inline const std::string& ServerParam::_internal_game_log_fixed_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_log_fixed_name_.Get();
}
inline void ServerParam::_internal_set_game_log_fixed_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.game_log_fixed_name_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_game_log_fixed_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.game_log_fixed_name_.Mutable( GetArena());
}
inline std::string* ServerParam::release_game_log_fixed_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.game_log_fixed_name)
  return _impl_.game_log_fixed_name_.Release();
}
inline void ServerParam::set_allocated_game_log_fixed_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_log_fixed_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.game_log_fixed_name_.IsDefault()) {
          _impl_.game_log_fixed_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.game_log_fixed_name)
}

// bool use_text_log_fixed = 125;
inline void ServerParam::clear_use_text_log_fixed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_text_log_fixed_ = false;
}
inline bool ServerParam::use_text_log_fixed() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.use_text_log_fixed)
  return _internal_use_text_log_fixed();
}
inline void ServerParam::set_use_text_log_fixed(bool value) {
  _internal_set_use_text_log_fixed(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.use_text_log_fixed)
}
inline bool ServerParam::_internal_use_text_log_fixed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_text_log_fixed_;
}
inline void ServerParam::_internal_set_use_text_log_fixed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.use_text_log_fixed_ = value;
}

// bool use_game_log_fixed = 126;
inline void ServerParam::clear_use_game_log_fixed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_game_log_fixed_ = false;
}
inline bool ServerParam::use_game_log_fixed() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.use_game_log_fixed)
  return _internal_use_game_log_fixed();
}
inline void ServerParam::set_use_game_log_fixed(bool value) {
  _internal_set_use_game_log_fixed(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.use_game_log_fixed)
}
inline bool ServerParam::_internal_use_game_log_fixed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_game_log_fixed_;
}
inline void ServerParam::_internal_set_use_game_log_fixed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.use_game_log_fixed_ = value;
}

// bool use_text_log_dated = 127;
inline void ServerParam::clear_use_text_log_dated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_text_log_dated_ = false;
}
inline bool ServerParam::use_text_log_dated() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.use_text_log_dated)
  return _internal_use_text_log_dated();
}
inline void ServerParam::set_use_text_log_dated(bool value) {
  _internal_set_use_text_log_dated(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.use_text_log_dated)
}
inline bool ServerParam::_internal_use_text_log_dated() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_text_log_dated_;
}
inline void ServerParam::_internal_set_use_text_log_dated(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.use_text_log_dated_ = value;
}

// bool use_game_log_dated = 128;
inline void ServerParam::clear_use_game_log_dated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_game_log_dated_ = false;
}
inline bool ServerParam::use_game_log_dated() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.use_game_log_dated)
  return _internal_use_game_log_dated();
}
inline void ServerParam::set_use_game_log_dated(bool value) {
  _internal_set_use_game_log_dated(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.use_game_log_dated)
}
inline bool ServerParam::_internal_use_game_log_dated() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_game_log_dated_;
}
inline void ServerParam::_internal_set_use_game_log_dated(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.use_game_log_dated_ = value;
}

// string log_date_format = 129;
inline void ServerParam::clear_log_date_format() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_date_format_.ClearToEmpty();
}
inline const std::string& ServerParam::log_date_format() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.log_date_format)
  return _internal_log_date_format();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_log_date_format(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.log_date_format_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.log_date_format)
}
inline std::string* ServerParam::mutable_log_date_format() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_log_date_format();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.log_date_format)
  return _s;
}
inline const std::string& ServerParam::_internal_log_date_format() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_date_format_.Get();
}
inline void ServerParam::_internal_set_log_date_format(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.log_date_format_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_log_date_format() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.log_date_format_.Mutable( GetArena());
}
inline std::string* ServerParam::release_log_date_format() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.log_date_format)
  return _impl_.log_date_format_.Release();
}
inline void ServerParam::set_allocated_log_date_format(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_date_format_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.log_date_format_.IsDefault()) {
          _impl_.log_date_format_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.log_date_format)
}

// bool log_times = 130;
inline void ServerParam::clear_log_times() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_times_ = false;
}
inline bool ServerParam::log_times() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.log_times)
  return _internal_log_times();
}
inline void ServerParam::set_log_times(bool value) {
  _internal_set_log_times(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.log_times)
}
inline bool ServerParam::_internal_log_times() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_times_;
}
inline void ServerParam::_internal_set_log_times(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.log_times_ = value;
}

// bool record_message = 131;
inline void ServerParam::clear_record_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.record_message_ = false;
}
inline bool ServerParam::record_message() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.record_message)
  return _internal_record_message();
}
inline void ServerParam::set_record_message(bool value) {
  _internal_set_record_message(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.record_message)
}
inline bool ServerParam::_internal_record_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.record_message_;
}
inline void ServerParam::_internal_set_record_message(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.record_message_ = value;
}

// int32 text_log_compression = 132;
inline void ServerParam::clear_text_log_compression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_log_compression_ = 0;
}
inline ::int32_t ServerParam::text_log_compression() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.text_log_compression)
  return _internal_text_log_compression();
}
inline void ServerParam::set_text_log_compression(::int32_t value) {
  _internal_set_text_log_compression(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.text_log_compression)
}
inline ::int32_t ServerParam::_internal_text_log_compression() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_log_compression_;
}
inline void ServerParam::_internal_set_text_log_compression(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_log_compression_ = value;
}

// int32 game_log_compression = 133;
inline void ServerParam::clear_game_log_compression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_log_compression_ = 0;
}
inline ::int32_t ServerParam::game_log_compression() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.game_log_compression)
  return _internal_game_log_compression();
}
inline void ServerParam::set_game_log_compression(::int32_t value) {
  _internal_set_game_log_compression(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.game_log_compression)
}
inline ::int32_t ServerParam::_internal_game_log_compression() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_log_compression_;
}
inline void ServerParam::_internal_set_game_log_compression(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.game_log_compression_ = value;
}

// bool use_profile = 134;
inline void ServerParam::clear_use_profile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_profile_ = false;
}
inline bool ServerParam::use_profile() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.use_profile)
  return _internal_use_profile();
}
inline void ServerParam::set_use_profile(bool value) {
  _internal_set_use_profile(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.use_profile)
}
inline bool ServerParam::_internal_use_profile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_profile_;
}
inline void ServerParam::_internal_set_use_profile(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.use_profile_ = value;
}

// float tackle_dist = 135;
inline void ServerParam::clear_tackle_dist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tackle_dist_ = 0;
}
inline float ServerParam::tackle_dist() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.tackle_dist)
  return _internal_tackle_dist();
}
inline void ServerParam::set_tackle_dist(float value) {
  _internal_set_tackle_dist(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.tackle_dist)
}
inline float ServerParam::_internal_tackle_dist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tackle_dist_;
}
inline void ServerParam::_internal_set_tackle_dist(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tackle_dist_ = value;
}

// float tackle_back_dist = 136;
inline void ServerParam::clear_tackle_back_dist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tackle_back_dist_ = 0;
}
inline float ServerParam::tackle_back_dist() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.tackle_back_dist)
  return _internal_tackle_back_dist();
}
inline void ServerParam::set_tackle_back_dist(float value) {
  _internal_set_tackle_back_dist(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.tackle_back_dist)
}
inline float ServerParam::_internal_tackle_back_dist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tackle_back_dist_;
}
inline void ServerParam::_internal_set_tackle_back_dist(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tackle_back_dist_ = value;
}

// float tackle_width = 137;
inline void ServerParam::clear_tackle_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tackle_width_ = 0;
}
inline float ServerParam::tackle_width() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.tackle_width)
  return _internal_tackle_width();
}
inline void ServerParam::set_tackle_width(float value) {
  _internal_set_tackle_width(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.tackle_width)
}
inline float ServerParam::_internal_tackle_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tackle_width_;
}
inline void ServerParam::_internal_set_tackle_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tackle_width_ = value;
}

// float tackle_exponent = 138;
inline void ServerParam::clear_tackle_exponent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tackle_exponent_ = 0;
}
inline float ServerParam::tackle_exponent() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.tackle_exponent)
  return _internal_tackle_exponent();
}
inline void ServerParam::set_tackle_exponent(float value) {
  _internal_set_tackle_exponent(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.tackle_exponent)
}
inline float ServerParam::_internal_tackle_exponent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tackle_exponent_;
}
inline void ServerParam::_internal_set_tackle_exponent(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tackle_exponent_ = value;
}

// int32 tackle_cycles = 139;
inline void ServerParam::clear_tackle_cycles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tackle_cycles_ = 0;
}
inline ::int32_t ServerParam::tackle_cycles() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.tackle_cycles)
  return _internal_tackle_cycles();
}
inline void ServerParam::set_tackle_cycles(::int32_t value) {
  _internal_set_tackle_cycles(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.tackle_cycles)
}
inline ::int32_t ServerParam::_internal_tackle_cycles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tackle_cycles_;
}
inline void ServerParam::_internal_set_tackle_cycles(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tackle_cycles_ = value;
}

// float tackle_power_rate = 140;
inline void ServerParam::clear_tackle_power_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tackle_power_rate_ = 0;
}
inline float ServerParam::tackle_power_rate() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.tackle_power_rate)
  return _internal_tackle_power_rate();
}
inline void ServerParam::set_tackle_power_rate(float value) {
  _internal_set_tackle_power_rate(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.tackle_power_rate)
}
inline float ServerParam::_internal_tackle_power_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tackle_power_rate_;
}
inline void ServerParam::_internal_set_tackle_power_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tackle_power_rate_ = value;
}

// int32 freeform_wait_period = 141;
inline void ServerParam::clear_freeform_wait_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.freeform_wait_period_ = 0;
}
inline ::int32_t ServerParam::freeform_wait_period() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.freeform_wait_period)
  return _internal_freeform_wait_period();
}
inline void ServerParam::set_freeform_wait_period(::int32_t value) {
  _internal_set_freeform_wait_period(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.freeform_wait_period)
}
inline ::int32_t ServerParam::_internal_freeform_wait_period() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.freeform_wait_period_;
}
inline void ServerParam::_internal_set_freeform_wait_period(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.freeform_wait_period_ = value;
}

// int32 freeform_send_period = 142;
inline void ServerParam::clear_freeform_send_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.freeform_send_period_ = 0;
}
inline ::int32_t ServerParam::freeform_send_period() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.freeform_send_period)
  return _internal_freeform_send_period();
}
inline void ServerParam::set_freeform_send_period(::int32_t value) {
  _internal_set_freeform_send_period(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.freeform_send_period)
}
inline ::int32_t ServerParam::_internal_freeform_send_period() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.freeform_send_period_;
}
inline void ServerParam::_internal_set_freeform_send_period(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.freeform_send_period_ = value;
}

// bool free_kick_faults = 143;
inline void ServerParam::clear_free_kick_faults() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.free_kick_faults_ = false;
}
inline bool ServerParam::free_kick_faults() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.free_kick_faults)
  return _internal_free_kick_faults();
}
inline void ServerParam::set_free_kick_faults(bool value) {
  _internal_set_free_kick_faults(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.free_kick_faults)
}
inline bool ServerParam::_internal_free_kick_faults() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.free_kick_faults_;
}
inline void ServerParam::_internal_set_free_kick_faults(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.free_kick_faults_ = value;
}

// bool back_passes = 144;
inline void ServerParam::clear_back_passes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.back_passes_ = false;
}
inline bool ServerParam::back_passes() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.back_passes)
  return _internal_back_passes();
}
inline void ServerParam::set_back_passes(bool value) {
  _internal_set_back_passes(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.back_passes)
}
inline bool ServerParam::_internal_back_passes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.back_passes_;
}
inline void ServerParam::_internal_set_back_passes(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.back_passes_ = value;
}

// bool proper_goal_kicks = 145;
inline void ServerParam::clear_proper_goal_kicks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.proper_goal_kicks_ = false;
}
inline bool ServerParam::proper_goal_kicks() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.proper_goal_kicks)
  return _internal_proper_goal_kicks();
}
inline void ServerParam::set_proper_goal_kicks(bool value) {
  _internal_set_proper_goal_kicks(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.proper_goal_kicks)
}
inline bool ServerParam::_internal_proper_goal_kicks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.proper_goal_kicks_;
}
inline void ServerParam::_internal_set_proper_goal_kicks(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.proper_goal_kicks_ = value;
}

// float stopped_ball_vel = 146;
inline void ServerParam::clear_stopped_ball_vel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stopped_ball_vel_ = 0;
}
inline float ServerParam::stopped_ball_vel() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.stopped_ball_vel)
  return _internal_stopped_ball_vel();
}
inline void ServerParam::set_stopped_ball_vel(float value) {
  _internal_set_stopped_ball_vel(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.stopped_ball_vel)
}
inline float ServerParam::_internal_stopped_ball_vel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stopped_ball_vel_;
}
inline void ServerParam::_internal_set_stopped_ball_vel(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stopped_ball_vel_ = value;
}

// int32 max_goal_kicks = 147;
inline void ServerParam::clear_max_goal_kicks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_goal_kicks_ = 0;
}
inline ::int32_t ServerParam::max_goal_kicks() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.max_goal_kicks)
  return _internal_max_goal_kicks();
}
inline void ServerParam::set_max_goal_kicks(::int32_t value) {
  _internal_set_max_goal_kicks(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.max_goal_kicks)
}
inline ::int32_t ServerParam::_internal_max_goal_kicks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_goal_kicks_;
}
inline void ServerParam::_internal_set_max_goal_kicks(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_goal_kicks_ = value;
}

// int32 clang_del_win = 148;
inline void ServerParam::clear_clang_del_win() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clang_del_win_ = 0;
}
inline ::int32_t ServerParam::clang_del_win() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.clang_del_win)
  return _internal_clang_del_win();
}
inline void ServerParam::set_clang_del_win(::int32_t value) {
  _internal_set_clang_del_win(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.clang_del_win)
}
inline ::int32_t ServerParam::_internal_clang_del_win() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clang_del_win_;
}
inline void ServerParam::_internal_set_clang_del_win(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clang_del_win_ = value;
}

// int32 clang_rule_win = 149;
inline void ServerParam::clear_clang_rule_win() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clang_rule_win_ = 0;
}
inline ::int32_t ServerParam::clang_rule_win() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.clang_rule_win)
  return _internal_clang_rule_win();
}
inline void ServerParam::set_clang_rule_win(::int32_t value) {
  _internal_set_clang_rule_win(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.clang_rule_win)
}
inline ::int32_t ServerParam::_internal_clang_rule_win() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clang_rule_win_;
}
inline void ServerParam::_internal_set_clang_rule_win(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clang_rule_win_ = value;
}

// bool auto_mode = 150;
inline void ServerParam::clear_auto_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.auto_mode_ = false;
}
inline bool ServerParam::auto_mode() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.auto_mode)
  return _internal_auto_mode();
}
inline void ServerParam::set_auto_mode(bool value) {
  _internal_set_auto_mode(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.auto_mode)
}
inline bool ServerParam::_internal_auto_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.auto_mode_;
}
inline void ServerParam::_internal_set_auto_mode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.auto_mode_ = value;
}

// int32 kick_off_wait = 151;
inline void ServerParam::clear_kick_off_wait() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kick_off_wait_ = 0;
}
inline ::int32_t ServerParam::kick_off_wait() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.kick_off_wait)
  return _internal_kick_off_wait();
}
inline void ServerParam::set_kick_off_wait(::int32_t value) {
  _internal_set_kick_off_wait(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.kick_off_wait)
}
inline ::int32_t ServerParam::_internal_kick_off_wait() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kick_off_wait_;
}
inline void ServerParam::_internal_set_kick_off_wait(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kick_off_wait_ = value;
}

// int32 connect_wait = 152;
inline void ServerParam::clear_connect_wait() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connect_wait_ = 0;
}
inline ::int32_t ServerParam::connect_wait() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.connect_wait)
  return _internal_connect_wait();
}
inline void ServerParam::set_connect_wait(::int32_t value) {
  _internal_set_connect_wait(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.connect_wait)
}
inline ::int32_t ServerParam::_internal_connect_wait() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connect_wait_;
}
inline void ServerParam::_internal_set_connect_wait(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.connect_wait_ = value;
}

// int32 game_over_wait = 153;
inline void ServerParam::clear_game_over_wait() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.game_over_wait_ = 0;
}
inline ::int32_t ServerParam::game_over_wait() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.game_over_wait)
  return _internal_game_over_wait();
}
inline void ServerParam::set_game_over_wait(::int32_t value) {
  _internal_set_game_over_wait(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.game_over_wait)
}
inline ::int32_t ServerParam::_internal_game_over_wait() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_over_wait_;
}
inline void ServerParam::_internal_set_game_over_wait(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.game_over_wait_ = value;
}

// string team_l_start = 154;
inline void ServerParam::clear_team_l_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.team_l_start_.ClearToEmpty();
}
inline const std::string& ServerParam::team_l_start() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.team_l_start)
  return _internal_team_l_start();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_team_l_start(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.team_l_start_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.team_l_start)
}
inline std::string* ServerParam::mutable_team_l_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_team_l_start();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.team_l_start)
  return _s;
}
inline const std::string& ServerParam::_internal_team_l_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.team_l_start_.Get();
}
inline void ServerParam::_internal_set_team_l_start(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.team_l_start_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_team_l_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.team_l_start_.Mutable( GetArena());
}
inline std::string* ServerParam::release_team_l_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.team_l_start)
  return _impl_.team_l_start_.Release();
}
inline void ServerParam::set_allocated_team_l_start(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.team_l_start_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.team_l_start_.IsDefault()) {
          _impl_.team_l_start_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.team_l_start)
}

// string team_r_start = 155;
inline void ServerParam::clear_team_r_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.team_r_start_.ClearToEmpty();
}
inline const std::string& ServerParam::team_r_start() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.team_r_start)
  return _internal_team_r_start();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_team_r_start(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.team_r_start_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.team_r_start)
}
inline std::string* ServerParam::mutable_team_r_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_team_r_start();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.team_r_start)
  return _s;
}
inline const std::string& ServerParam::_internal_team_r_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.team_r_start_.Get();
}
inline void ServerParam::_internal_set_team_r_start(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.team_r_start_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_team_r_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.team_r_start_.Mutable( GetArena());
}
inline std::string* ServerParam::release_team_r_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.team_r_start)
  return _impl_.team_r_start_.Release();
}
inline void ServerParam::set_allocated_team_r_start(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.team_r_start_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.team_r_start_.IsDefault()) {
          _impl_.team_r_start_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.team_r_start)
}

// bool keepaway_mode = 156;
inline void ServerParam::clear_keepaway_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keepaway_mode_ = false;
}
inline bool ServerParam::keepaway_mode() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.keepaway_mode)
  return _internal_keepaway_mode();
}
inline void ServerParam::set_keepaway_mode(bool value) {
  _internal_set_keepaway_mode(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.keepaway_mode)
}
inline bool ServerParam::_internal_keepaway_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keepaway_mode_;
}
inline void ServerParam::_internal_set_keepaway_mode(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keepaway_mode_ = value;
}

// float keepaway_length = 157;
inline void ServerParam::clear_keepaway_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keepaway_length_ = 0;
}
inline float ServerParam::keepaway_length() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.keepaway_length)
  return _internal_keepaway_length();
}
inline void ServerParam::set_keepaway_length(float value) {
  _internal_set_keepaway_length(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.keepaway_length)
}
inline float ServerParam::_internal_keepaway_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keepaway_length_;
}
inline void ServerParam::_internal_set_keepaway_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keepaway_length_ = value;
}

// float keepaway_width = 158;
inline void ServerParam::clear_keepaway_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keepaway_width_ = 0;
}
inline float ServerParam::keepaway_width() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.keepaway_width)
  return _internal_keepaway_width();
}
inline void ServerParam::set_keepaway_width(float value) {
  _internal_set_keepaway_width(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.keepaway_width)
}
inline float ServerParam::_internal_keepaway_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keepaway_width_;
}
inline void ServerParam::_internal_set_keepaway_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keepaway_width_ = value;
}

// bool keepaway_logging = 159;
inline void ServerParam::clear_keepaway_logging() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keepaway_logging_ = false;
}
inline bool ServerParam::keepaway_logging() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.keepaway_logging)
  return _internal_keepaway_logging();
}
inline void ServerParam::set_keepaway_logging(bool value) {
  _internal_set_keepaway_logging(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.keepaway_logging)
}
inline bool ServerParam::_internal_keepaway_logging() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keepaway_logging_;
}
inline void ServerParam::_internal_set_keepaway_logging(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keepaway_logging_ = value;
}

// string keepaway_log_dir = 160;
inline void ServerParam::clear_keepaway_log_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keepaway_log_dir_.ClearToEmpty();
}
inline const std::string& ServerParam::keepaway_log_dir() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.keepaway_log_dir)
  return _internal_keepaway_log_dir();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_keepaway_log_dir(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keepaway_log_dir_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.keepaway_log_dir)
}
inline std::string* ServerParam::mutable_keepaway_log_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_keepaway_log_dir();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.keepaway_log_dir)
  return _s;
}
inline const std::string& ServerParam::_internal_keepaway_log_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keepaway_log_dir_.Get();
}
inline void ServerParam::_internal_set_keepaway_log_dir(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keepaway_log_dir_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_keepaway_log_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.keepaway_log_dir_.Mutable( GetArena());
}
inline std::string* ServerParam::release_keepaway_log_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.keepaway_log_dir)
  return _impl_.keepaway_log_dir_.Release();
}
inline void ServerParam::set_allocated_keepaway_log_dir(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keepaway_log_dir_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.keepaway_log_dir_.IsDefault()) {
          _impl_.keepaway_log_dir_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.keepaway_log_dir)
}

// string keepaway_log_fixed_name = 161;
inline void ServerParam::clear_keepaway_log_fixed_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keepaway_log_fixed_name_.ClearToEmpty();
}
inline const std::string& ServerParam::keepaway_log_fixed_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.keepaway_log_fixed_name)
  return _internal_keepaway_log_fixed_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_keepaway_log_fixed_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keepaway_log_fixed_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.keepaway_log_fixed_name)
}
inline std::string* ServerParam::mutable_keepaway_log_fixed_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_keepaway_log_fixed_name();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.keepaway_log_fixed_name)
  return _s;
}
inline const std::string& ServerParam::_internal_keepaway_log_fixed_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keepaway_log_fixed_name_.Get();
}
inline void ServerParam::_internal_set_keepaway_log_fixed_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keepaway_log_fixed_name_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_keepaway_log_fixed_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.keepaway_log_fixed_name_.Mutable( GetArena());
}
inline std::string* ServerParam::release_keepaway_log_fixed_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.keepaway_log_fixed_name)
  return _impl_.keepaway_log_fixed_name_.Release();
}
inline void ServerParam::set_allocated_keepaway_log_fixed_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keepaway_log_fixed_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.keepaway_log_fixed_name_.IsDefault()) {
          _impl_.keepaway_log_fixed_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.keepaway_log_fixed_name)
}

// bool keepaway_log_fixed = 162;
inline void ServerParam::clear_keepaway_log_fixed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keepaway_log_fixed_ = false;
}
inline bool ServerParam::keepaway_log_fixed() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.keepaway_log_fixed)
  return _internal_keepaway_log_fixed();
}
inline void ServerParam::set_keepaway_log_fixed(bool value) {
  _internal_set_keepaway_log_fixed(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.keepaway_log_fixed)
}
inline bool ServerParam::_internal_keepaway_log_fixed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keepaway_log_fixed_;
}
inline void ServerParam::_internal_set_keepaway_log_fixed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keepaway_log_fixed_ = value;
}

// bool keepaway_log_dated = 163;
inline void ServerParam::clear_keepaway_log_dated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keepaway_log_dated_ = false;
}
inline bool ServerParam::keepaway_log_dated() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.keepaway_log_dated)
  return _internal_keepaway_log_dated();
}
inline void ServerParam::set_keepaway_log_dated(bool value) {
  _internal_set_keepaway_log_dated(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.keepaway_log_dated)
}
inline bool ServerParam::_internal_keepaway_log_dated() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keepaway_log_dated_;
}
inline void ServerParam::_internal_set_keepaway_log_dated(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keepaway_log_dated_ = value;
}

// int32 keepaway_start = 164;
inline void ServerParam::clear_keepaway_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keepaway_start_ = 0;
}
inline ::int32_t ServerParam::keepaway_start() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.keepaway_start)
  return _internal_keepaway_start();
}
inline void ServerParam::set_keepaway_start(::int32_t value) {
  _internal_set_keepaway_start(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.keepaway_start)
}
inline ::int32_t ServerParam::_internal_keepaway_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keepaway_start_;
}
inline void ServerParam::_internal_set_keepaway_start(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.keepaway_start_ = value;
}

// int32 nr_normal_halfs = 165;
inline void ServerParam::clear_nr_normal_halfs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nr_normal_halfs_ = 0;
}
inline ::int32_t ServerParam::nr_normal_halfs() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.nr_normal_halfs)
  return _internal_nr_normal_halfs();
}
inline void ServerParam::set_nr_normal_halfs(::int32_t value) {
  _internal_set_nr_normal_halfs(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.nr_normal_halfs)
}
inline ::int32_t ServerParam::_internal_nr_normal_halfs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nr_normal_halfs_;
}
inline void ServerParam::_internal_set_nr_normal_halfs(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nr_normal_halfs_ = value;
}

// int32 nr_extra_halfs = 166;
inline void ServerParam::clear_nr_extra_halfs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nr_extra_halfs_ = 0;
}
inline ::int32_t ServerParam::nr_extra_halfs() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.nr_extra_halfs)
  return _internal_nr_extra_halfs();
}
inline void ServerParam::set_nr_extra_halfs(::int32_t value) {
  _internal_set_nr_extra_halfs(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.nr_extra_halfs)
}
inline ::int32_t ServerParam::_internal_nr_extra_halfs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nr_extra_halfs_;
}
inline void ServerParam::_internal_set_nr_extra_halfs(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nr_extra_halfs_ = value;
}

// bool penalty_shoot_outs = 167;
inline void ServerParam::clear_penalty_shoot_outs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.penalty_shoot_outs_ = false;
}
inline bool ServerParam::penalty_shoot_outs() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.penalty_shoot_outs)
  return _internal_penalty_shoot_outs();
}
inline void ServerParam::set_penalty_shoot_outs(bool value) {
  _internal_set_penalty_shoot_outs(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.penalty_shoot_outs)
}
inline bool ServerParam::_internal_penalty_shoot_outs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.penalty_shoot_outs_;
}
inline void ServerParam::_internal_set_penalty_shoot_outs(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.penalty_shoot_outs_ = value;
}

// int32 pen_before_setup_wait = 168;
inline void ServerParam::clear_pen_before_setup_wait() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pen_before_setup_wait_ = 0;
}
inline ::int32_t ServerParam::pen_before_setup_wait() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pen_before_setup_wait)
  return _internal_pen_before_setup_wait();
}
inline void ServerParam::set_pen_before_setup_wait(::int32_t value) {
  _internal_set_pen_before_setup_wait(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pen_before_setup_wait)
}
inline ::int32_t ServerParam::_internal_pen_before_setup_wait() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pen_before_setup_wait_;
}
inline void ServerParam::_internal_set_pen_before_setup_wait(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pen_before_setup_wait_ = value;
}

// int32 pen_setup_wait = 169;
inline void ServerParam::clear_pen_setup_wait() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pen_setup_wait_ = 0;
}
inline ::int32_t ServerParam::pen_setup_wait() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pen_setup_wait)
  return _internal_pen_setup_wait();
}
inline void ServerParam::set_pen_setup_wait(::int32_t value) {
  _internal_set_pen_setup_wait(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pen_setup_wait)
}
inline ::int32_t ServerParam::_internal_pen_setup_wait() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pen_setup_wait_;
}
inline void ServerParam::_internal_set_pen_setup_wait(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pen_setup_wait_ = value;
}

// int32 pen_ready_wait = 170;
inline void ServerParam::clear_pen_ready_wait() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pen_ready_wait_ = 0;
}
inline ::int32_t ServerParam::pen_ready_wait() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pen_ready_wait)
  return _internal_pen_ready_wait();
}
inline void ServerParam::set_pen_ready_wait(::int32_t value) {
  _internal_set_pen_ready_wait(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pen_ready_wait)
}
inline ::int32_t ServerParam::_internal_pen_ready_wait() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pen_ready_wait_;
}
inline void ServerParam::_internal_set_pen_ready_wait(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pen_ready_wait_ = value;
}

// int32 pen_taken_wait = 171;
inline void ServerParam::clear_pen_taken_wait() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pen_taken_wait_ = 0;
}
inline ::int32_t ServerParam::pen_taken_wait() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pen_taken_wait)
  return _internal_pen_taken_wait();
}
inline void ServerParam::set_pen_taken_wait(::int32_t value) {
  _internal_set_pen_taken_wait(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pen_taken_wait)
}
inline ::int32_t ServerParam::_internal_pen_taken_wait() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pen_taken_wait_;
}
inline void ServerParam::_internal_set_pen_taken_wait(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pen_taken_wait_ = value;
}

// int32 pen_nr_kicks = 172;
inline void ServerParam::clear_pen_nr_kicks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pen_nr_kicks_ = 0;
}
inline ::int32_t ServerParam::pen_nr_kicks() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pen_nr_kicks)
  return _internal_pen_nr_kicks();
}
inline void ServerParam::set_pen_nr_kicks(::int32_t value) {
  _internal_set_pen_nr_kicks(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pen_nr_kicks)
}
inline ::int32_t ServerParam::_internal_pen_nr_kicks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pen_nr_kicks_;
}
inline void ServerParam::_internal_set_pen_nr_kicks(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pen_nr_kicks_ = value;
}

// int32 pen_max_extra_kicks = 173;
inline void ServerParam::clear_pen_max_extra_kicks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pen_max_extra_kicks_ = 0;
}
inline ::int32_t ServerParam::pen_max_extra_kicks() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pen_max_extra_kicks)
  return _internal_pen_max_extra_kicks();
}
inline void ServerParam::set_pen_max_extra_kicks(::int32_t value) {
  _internal_set_pen_max_extra_kicks(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pen_max_extra_kicks)
}
inline ::int32_t ServerParam::_internal_pen_max_extra_kicks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pen_max_extra_kicks_;
}
inline void ServerParam::_internal_set_pen_max_extra_kicks(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pen_max_extra_kicks_ = value;
}

// float pen_dist_x = 174;
inline void ServerParam::clear_pen_dist_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pen_dist_x_ = 0;
}
inline float ServerParam::pen_dist_x() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pen_dist_x)
  return _internal_pen_dist_x();
}
inline void ServerParam::set_pen_dist_x(float value) {
  _internal_set_pen_dist_x(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pen_dist_x)
}
inline float ServerParam::_internal_pen_dist_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pen_dist_x_;
}
inline void ServerParam::_internal_set_pen_dist_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pen_dist_x_ = value;
}

// bool pen_random_winner = 175;
inline void ServerParam::clear_pen_random_winner() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pen_random_winner_ = false;
}
inline bool ServerParam::pen_random_winner() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pen_random_winner)
  return _internal_pen_random_winner();
}
inline void ServerParam::set_pen_random_winner(bool value) {
  _internal_set_pen_random_winner(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pen_random_winner)
}
inline bool ServerParam::_internal_pen_random_winner() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pen_random_winner_;
}
inline void ServerParam::_internal_set_pen_random_winner(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pen_random_winner_ = value;
}

// bool pen_allow_mult_kicks = 176;
inline void ServerParam::clear_pen_allow_mult_kicks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pen_allow_mult_kicks_ = false;
}
inline bool ServerParam::pen_allow_mult_kicks() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pen_allow_mult_kicks)
  return _internal_pen_allow_mult_kicks();
}
inline void ServerParam::set_pen_allow_mult_kicks(bool value) {
  _internal_set_pen_allow_mult_kicks(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pen_allow_mult_kicks)
}
inline bool ServerParam::_internal_pen_allow_mult_kicks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pen_allow_mult_kicks_;
}
inline void ServerParam::_internal_set_pen_allow_mult_kicks(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pen_allow_mult_kicks_ = value;
}

// float pen_max_goalie_dist_x = 177;
inline void ServerParam::clear_pen_max_goalie_dist_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pen_max_goalie_dist_x_ = 0;
}
inline float ServerParam::pen_max_goalie_dist_x() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pen_max_goalie_dist_x)
  return _internal_pen_max_goalie_dist_x();
}
inline void ServerParam::set_pen_max_goalie_dist_x(float value) {
  _internal_set_pen_max_goalie_dist_x(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pen_max_goalie_dist_x)
}
inline float ServerParam::_internal_pen_max_goalie_dist_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pen_max_goalie_dist_x_;
}
inline void ServerParam::_internal_set_pen_max_goalie_dist_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pen_max_goalie_dist_x_ = value;
}

// bool pen_coach_moves_players = 178;
inline void ServerParam::clear_pen_coach_moves_players() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pen_coach_moves_players_ = false;
}
inline bool ServerParam::pen_coach_moves_players() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pen_coach_moves_players)
  return _internal_pen_coach_moves_players();
}
inline void ServerParam::set_pen_coach_moves_players(bool value) {
  _internal_set_pen_coach_moves_players(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pen_coach_moves_players)
}
inline bool ServerParam::_internal_pen_coach_moves_players() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pen_coach_moves_players_;
}
inline void ServerParam::_internal_set_pen_coach_moves_players(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pen_coach_moves_players_ = value;
}

// string module_dir = 179;
inline void ServerParam::clear_module_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.module_dir_.ClearToEmpty();
}
inline const std::string& ServerParam::module_dir() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.module_dir)
  return _internal_module_dir();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_module_dir(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.module_dir_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.module_dir)
}
inline std::string* ServerParam::mutable_module_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_module_dir();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.module_dir)
  return _s;
}
inline const std::string& ServerParam::_internal_module_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.module_dir_.Get();
}
inline void ServerParam::_internal_set_module_dir(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.module_dir_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_module_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.module_dir_.Mutable( GetArena());
}
inline std::string* ServerParam::release_module_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.module_dir)
  return _impl_.module_dir_.Release();
}
inline void ServerParam::set_allocated_module_dir(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.module_dir_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.module_dir_.IsDefault()) {
          _impl_.module_dir_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.module_dir)
}

// float ball_stuck_area = 180;
inline void ServerParam::clear_ball_stuck_area() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ball_stuck_area_ = 0;
}
inline float ServerParam::ball_stuck_area() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.ball_stuck_area)
  return _internal_ball_stuck_area();
}
inline void ServerParam::set_ball_stuck_area(float value) {
  _internal_set_ball_stuck_area(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.ball_stuck_area)
}
inline float ServerParam::_internal_ball_stuck_area() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ball_stuck_area_;
}
inline void ServerParam::_internal_set_ball_stuck_area(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ball_stuck_area_ = value;
}

// string coach_msg_file = 181;
inline void ServerParam::clear_coach_msg_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.coach_msg_file_.ClearToEmpty();
}
inline const std::string& ServerParam::coach_msg_file() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.coach_msg_file)
  return _internal_coach_msg_file();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_coach_msg_file(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.coach_msg_file_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.coach_msg_file)
}
inline std::string* ServerParam::mutable_coach_msg_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_coach_msg_file();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.coach_msg_file)
  return _s;
}
inline const std::string& ServerParam::_internal_coach_msg_file() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.coach_msg_file_.Get();
}
inline void ServerParam::_internal_set_coach_msg_file(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.coach_msg_file_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_coach_msg_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.coach_msg_file_.Mutable( GetArena());
}
inline std::string* ServerParam::release_coach_msg_file() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.coach_msg_file)
  return _impl_.coach_msg_file_.Release();
}
inline void ServerParam::set_allocated_coach_msg_file(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.coach_msg_file_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.coach_msg_file_.IsDefault()) {
          _impl_.coach_msg_file_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.coach_msg_file)
}

// float max_tackle_power = 182;
inline void ServerParam::clear_max_tackle_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_tackle_power_ = 0;
}
inline float ServerParam::max_tackle_power() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.max_tackle_power)
  return _internal_max_tackle_power();
}
inline void ServerParam::set_max_tackle_power(float value) {
  _internal_set_max_tackle_power(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.max_tackle_power)
}
inline float ServerParam::_internal_max_tackle_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_tackle_power_;
}
inline void ServerParam::_internal_set_max_tackle_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_tackle_power_ = value;
}

// float max_back_tackle_power = 183;
inline void ServerParam::clear_max_back_tackle_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_back_tackle_power_ = 0;
}
inline float ServerParam::max_back_tackle_power() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.max_back_tackle_power)
  return _internal_max_back_tackle_power();
}
inline void ServerParam::set_max_back_tackle_power(float value) {
  _internal_set_max_back_tackle_power(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.max_back_tackle_power)
}
inline float ServerParam::_internal_max_back_tackle_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_back_tackle_power_;
}
inline void ServerParam::_internal_set_max_back_tackle_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_back_tackle_power_ = value;
}

// float player_speed_max_min = 184;
inline void ServerParam::clear_player_speed_max_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_speed_max_min_ = 0;
}
inline float ServerParam::player_speed_max_min() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.player_speed_max_min)
  return _internal_player_speed_max_min();
}
inline void ServerParam::set_player_speed_max_min(float value) {
  _internal_set_player_speed_max_min(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.player_speed_max_min)
}
inline float ServerParam::_internal_player_speed_max_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_speed_max_min_;
}
inline void ServerParam::_internal_set_player_speed_max_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_speed_max_min_ = value;
}

// float extra_stamina = 185;
inline void ServerParam::clear_extra_stamina() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extra_stamina_ = 0;
}
inline float ServerParam::extra_stamina() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.extra_stamina)
  return _internal_extra_stamina();
}
inline void ServerParam::set_extra_stamina(float value) {
  _internal_set_extra_stamina(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.extra_stamina)
}
inline float ServerParam::_internal_extra_stamina() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extra_stamina_;
}
inline void ServerParam::_internal_set_extra_stamina(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.extra_stamina_ = value;
}

// int32 synch_see_offset = 186;
inline void ServerParam::clear_synch_see_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.synch_see_offset_ = 0;
}
inline ::int32_t ServerParam::synch_see_offset() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.synch_see_offset)
  return _internal_synch_see_offset();
}
inline void ServerParam::set_synch_see_offset(::int32_t value) {
  _internal_set_synch_see_offset(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.synch_see_offset)
}
inline ::int32_t ServerParam::_internal_synch_see_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.synch_see_offset_;
}
inline void ServerParam::_internal_set_synch_see_offset(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.synch_see_offset_ = value;
}

// int32 extra_half_time = 187;
inline void ServerParam::clear_extra_half_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extra_half_time_ = 0;
}
inline ::int32_t ServerParam::extra_half_time() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.extra_half_time)
  return _internal_extra_half_time();
}
inline void ServerParam::set_extra_half_time(::int32_t value) {
  _internal_set_extra_half_time(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.extra_half_time)
}
inline ::int32_t ServerParam::_internal_extra_half_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extra_half_time_;
}
inline void ServerParam::_internal_set_extra_half_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.extra_half_time_ = value;
}

// float stamina_capacity = 188;
inline void ServerParam::clear_stamina_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stamina_capacity_ = 0;
}
inline float ServerParam::stamina_capacity() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.stamina_capacity)
  return _internal_stamina_capacity();
}
inline void ServerParam::set_stamina_capacity(float value) {
  _internal_set_stamina_capacity(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.stamina_capacity)
}
inline float ServerParam::_internal_stamina_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stamina_capacity_;
}
inline void ServerParam::_internal_set_stamina_capacity(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stamina_capacity_ = value;
}

// float max_dash_angle = 189;
inline void ServerParam::clear_max_dash_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_dash_angle_ = 0;
}
inline float ServerParam::max_dash_angle() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.max_dash_angle)
  return _internal_max_dash_angle();
}
inline void ServerParam::set_max_dash_angle(float value) {
  _internal_set_max_dash_angle(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.max_dash_angle)
}
inline float ServerParam::_internal_max_dash_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_dash_angle_;
}
inline void ServerParam::_internal_set_max_dash_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_dash_angle_ = value;
}

// float min_dash_angle = 190;
inline void ServerParam::clear_min_dash_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_dash_angle_ = 0;
}
inline float ServerParam::min_dash_angle() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.min_dash_angle)
  return _internal_min_dash_angle();
}
inline void ServerParam::set_min_dash_angle(float value) {
  _internal_set_min_dash_angle(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.min_dash_angle)
}
inline float ServerParam::_internal_min_dash_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_dash_angle_;
}
inline void ServerParam::_internal_set_min_dash_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_dash_angle_ = value;
}

// float dash_angle_step = 191;
inline void ServerParam::clear_dash_angle_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_angle_step_ = 0;
}
inline float ServerParam::dash_angle_step() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.dash_angle_step)
  return _internal_dash_angle_step();
}
inline void ServerParam::set_dash_angle_step(float value) {
  _internal_set_dash_angle_step(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.dash_angle_step)
}
inline float ServerParam::_internal_dash_angle_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_angle_step_;
}
inline void ServerParam::_internal_set_dash_angle_step(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dash_angle_step_ = value;
}

// float side_dash_rate = 192;
inline void ServerParam::clear_side_dash_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_dash_rate_ = 0;
}
inline float ServerParam::side_dash_rate() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.side_dash_rate)
  return _internal_side_dash_rate();
}
inline void ServerParam::set_side_dash_rate(float value) {
  _internal_set_side_dash_rate(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.side_dash_rate)
}
inline float ServerParam::_internal_side_dash_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.side_dash_rate_;
}
inline void ServerParam::_internal_set_side_dash_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.side_dash_rate_ = value;
}

// float back_dash_rate = 193;
inline void ServerParam::clear_back_dash_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.back_dash_rate_ = 0;
}
inline float ServerParam::back_dash_rate() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.back_dash_rate)
  return _internal_back_dash_rate();
}
inline void ServerParam::set_back_dash_rate(float value) {
  _internal_set_back_dash_rate(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.back_dash_rate)
}
inline float ServerParam::_internal_back_dash_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.back_dash_rate_;
}
inline void ServerParam::_internal_set_back_dash_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.back_dash_rate_ = value;
}

// float max_dash_power = 194;
inline void ServerParam::clear_max_dash_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_dash_power_ = 0;
}
inline float ServerParam::max_dash_power() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.max_dash_power)
  return _internal_max_dash_power();
}
inline void ServerParam::set_max_dash_power(float value) {
  _internal_set_max_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.max_dash_power)
}
inline float ServerParam::_internal_max_dash_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_dash_power_;
}
inline void ServerParam::_internal_set_max_dash_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_dash_power_ = value;
}

// float min_dash_power = 195;
inline void ServerParam::clear_min_dash_power() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_dash_power_ = 0;
}
inline float ServerParam::min_dash_power() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.min_dash_power)
  return _internal_min_dash_power();
}
inline void ServerParam::set_min_dash_power(float value) {
  _internal_set_min_dash_power(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.min_dash_power)
}
inline float ServerParam::_internal_min_dash_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_dash_power_;
}
inline void ServerParam::_internal_set_min_dash_power(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_dash_power_ = value;
}

// float tackle_rand_factor = 196;
inline void ServerParam::clear_tackle_rand_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tackle_rand_factor_ = 0;
}
inline float ServerParam::tackle_rand_factor() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.tackle_rand_factor)
  return _internal_tackle_rand_factor();
}
inline void ServerParam::set_tackle_rand_factor(float value) {
  _internal_set_tackle_rand_factor(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.tackle_rand_factor)
}
inline float ServerParam::_internal_tackle_rand_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tackle_rand_factor_;
}
inline void ServerParam::_internal_set_tackle_rand_factor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tackle_rand_factor_ = value;
}

// float foul_detect_probability = 197;
inline void ServerParam::clear_foul_detect_probability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.foul_detect_probability_ = 0;
}
inline float ServerParam::foul_detect_probability() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.foul_detect_probability)
  return _internal_foul_detect_probability();
}
inline void ServerParam::set_foul_detect_probability(float value) {
  _internal_set_foul_detect_probability(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.foul_detect_probability)
}
inline float ServerParam::_internal_foul_detect_probability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.foul_detect_probability_;
}
inline void ServerParam::_internal_set_foul_detect_probability(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.foul_detect_probability_ = value;
}

// float foul_exponent = 198;
inline void ServerParam::clear_foul_exponent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.foul_exponent_ = 0;
}
inline float ServerParam::foul_exponent() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.foul_exponent)
  return _internal_foul_exponent();
}
inline void ServerParam::set_foul_exponent(float value) {
  _internal_set_foul_exponent(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.foul_exponent)
}
inline float ServerParam::_internal_foul_exponent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.foul_exponent_;
}
inline void ServerParam::_internal_set_foul_exponent(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.foul_exponent_ = value;
}

// int32 foul_cycles = 199;
inline void ServerParam::clear_foul_cycles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.foul_cycles_ = 0;
}
inline ::int32_t ServerParam::foul_cycles() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.foul_cycles)
  return _internal_foul_cycles();
}
inline void ServerParam::set_foul_cycles(::int32_t value) {
  _internal_set_foul_cycles(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.foul_cycles)
}
inline ::int32_t ServerParam::_internal_foul_cycles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.foul_cycles_;
}
inline void ServerParam::_internal_set_foul_cycles(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.foul_cycles_ = value;
}

// bool golden_goal = 200;
inline void ServerParam::clear_golden_goal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.golden_goal_ = false;
}
inline bool ServerParam::golden_goal() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.golden_goal)
  return _internal_golden_goal();
}
inline void ServerParam::set_golden_goal(bool value) {
  _internal_set_golden_goal(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.golden_goal)
}
inline bool ServerParam::_internal_golden_goal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.golden_goal_;
}
inline void ServerParam::_internal_set_golden_goal(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.golden_goal_ = value;
}

// float red_card_probability = 201;
inline void ServerParam::clear_red_card_probability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.red_card_probability_ = 0;
}
inline float ServerParam::red_card_probability() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.red_card_probability)
  return _internal_red_card_probability();
}
inline void ServerParam::set_red_card_probability(float value) {
  _internal_set_red_card_probability(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.red_card_probability)
}
inline float ServerParam::_internal_red_card_probability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.red_card_probability_;
}
inline void ServerParam::_internal_set_red_card_probability(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.red_card_probability_ = value;
}

// int32 illegal_defense_duration = 202;
inline void ServerParam::clear_illegal_defense_duration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.illegal_defense_duration_ = 0;
}
inline ::int32_t ServerParam::illegal_defense_duration() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.illegal_defense_duration)
  return _internal_illegal_defense_duration();
}
inline void ServerParam::set_illegal_defense_duration(::int32_t value) {
  _internal_set_illegal_defense_duration(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.illegal_defense_duration)
}
inline ::int32_t ServerParam::_internal_illegal_defense_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.illegal_defense_duration_;
}
inline void ServerParam::_internal_set_illegal_defense_duration(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.illegal_defense_duration_ = value;
}

// int32 illegal_defense_number = 203;
inline void ServerParam::clear_illegal_defense_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.illegal_defense_number_ = 0;
}
inline ::int32_t ServerParam::illegal_defense_number() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.illegal_defense_number)
  return _internal_illegal_defense_number();
}
inline void ServerParam::set_illegal_defense_number(::int32_t value) {
  _internal_set_illegal_defense_number(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.illegal_defense_number)
}
inline ::int32_t ServerParam::_internal_illegal_defense_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.illegal_defense_number_;
}
inline void ServerParam::_internal_set_illegal_defense_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.illegal_defense_number_ = value;
}

// float illegal_defense_dist_x = 204;
inline void ServerParam::clear_illegal_defense_dist_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.illegal_defense_dist_x_ = 0;
}
inline float ServerParam::illegal_defense_dist_x() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.illegal_defense_dist_x)
  return _internal_illegal_defense_dist_x();
}
inline void ServerParam::set_illegal_defense_dist_x(float value) {
  _internal_set_illegal_defense_dist_x(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.illegal_defense_dist_x)
}
inline float ServerParam::_internal_illegal_defense_dist_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.illegal_defense_dist_x_;
}
inline void ServerParam::_internal_set_illegal_defense_dist_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.illegal_defense_dist_x_ = value;
}

// float illegal_defense_width = 205;
inline void ServerParam::clear_illegal_defense_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.illegal_defense_width_ = 0;
}
inline float ServerParam::illegal_defense_width() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.illegal_defense_width)
  return _internal_illegal_defense_width();
}
inline void ServerParam::set_illegal_defense_width(float value) {
  _internal_set_illegal_defense_width(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.illegal_defense_width)
}
inline float ServerParam::_internal_illegal_defense_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.illegal_defense_width_;
}
inline void ServerParam::_internal_set_illegal_defense_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.illegal_defense_width_ = value;
}

// string fixed_teamname_l = 206;
inline void ServerParam::clear_fixed_teamname_l() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fixed_teamname_l_.ClearToEmpty();
}
inline const std::string& ServerParam::fixed_teamname_l() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.fixed_teamname_l)
  return _internal_fixed_teamname_l();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_fixed_teamname_l(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fixed_teamname_l_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.fixed_teamname_l)
}
inline std::string* ServerParam::mutable_fixed_teamname_l() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fixed_teamname_l();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.fixed_teamname_l)
  return _s;
}
inline const std::string& ServerParam::_internal_fixed_teamname_l() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixed_teamname_l_.Get();
}
inline void ServerParam::_internal_set_fixed_teamname_l(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fixed_teamname_l_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_fixed_teamname_l() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.fixed_teamname_l_.Mutable( GetArena());
}
inline std::string* ServerParam::release_fixed_teamname_l() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.fixed_teamname_l)
  return _impl_.fixed_teamname_l_.Release();
}
inline void ServerParam::set_allocated_fixed_teamname_l(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fixed_teamname_l_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fixed_teamname_l_.IsDefault()) {
          _impl_.fixed_teamname_l_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.fixed_teamname_l)
}

// string fixed_teamname_r = 207;
inline void ServerParam::clear_fixed_teamname_r() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fixed_teamname_r_.ClearToEmpty();
}
inline const std::string& ServerParam::fixed_teamname_r() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:protos.ServerParam.fixed_teamname_r)
  return _internal_fixed_teamname_r();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerParam::set_fixed_teamname_r(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fixed_teamname_r_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:protos.ServerParam.fixed_teamname_r)
}
inline std::string* ServerParam::mutable_fixed_teamname_r() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fixed_teamname_r();
  // @@protoc_insertion_point(field_mutable:protos.ServerParam.fixed_teamname_r)
  return _s;
}
inline const std::string& ServerParam::_internal_fixed_teamname_r() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixed_teamname_r_.Get();
}
inline void ServerParam::_internal_set_fixed_teamname_r(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fixed_teamname_r_.Set(value, GetArena());
}
inline std::string* ServerParam::_internal_mutable_fixed_teamname_r() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.fixed_teamname_r_.Mutable( GetArena());
}
inline std::string* ServerParam::release_fixed_teamname_r() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:protos.ServerParam.fixed_teamname_r)
  return _impl_.fixed_teamname_r_.Release();
}
inline void ServerParam::set_allocated_fixed_teamname_r(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fixed_teamname_r_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fixed_teamname_r_.IsDefault()) {
          _impl_.fixed_teamname_r_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protos.ServerParam.fixed_teamname_r)
}

// float max_catch_angle = 208;
inline void ServerParam::clear_max_catch_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_catch_angle_ = 0;
}
inline float ServerParam::max_catch_angle() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.max_catch_angle)
  return _internal_max_catch_angle();
}
inline void ServerParam::set_max_catch_angle(float value) {
  _internal_set_max_catch_angle(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.max_catch_angle)
}
inline float ServerParam::_internal_max_catch_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_catch_angle_;
}
inline void ServerParam::_internal_set_max_catch_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_catch_angle_ = value;
}

// float min_catch_angle = 209;
inline void ServerParam::clear_min_catch_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_catch_angle_ = 0;
}
inline float ServerParam::min_catch_angle() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.min_catch_angle)
  return _internal_min_catch_angle();
}
inline void ServerParam::set_min_catch_angle(float value) {
  _internal_set_min_catch_angle(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.min_catch_angle)
}
inline float ServerParam::_internal_min_catch_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_catch_angle_;
}
inline void ServerParam::_internal_set_min_catch_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_catch_angle_ = value;
}

// int32 random_seed = 210;
inline void ServerParam::clear_random_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.random_seed_ = 0;
}
inline ::int32_t ServerParam::random_seed() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.random_seed)
  return _internal_random_seed();
}
inline void ServerParam::set_random_seed(::int32_t value) {
  _internal_set_random_seed(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.random_seed)
}
inline ::int32_t ServerParam::_internal_random_seed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.random_seed_;
}
inline void ServerParam::_internal_set_random_seed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.random_seed_ = value;
}

// float long_kick_power_factor = 211;
inline void ServerParam::clear_long_kick_power_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.long_kick_power_factor_ = 0;
}
inline float ServerParam::long_kick_power_factor() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.long_kick_power_factor)
  return _internal_long_kick_power_factor();
}
inline void ServerParam::set_long_kick_power_factor(float value) {
  _internal_set_long_kick_power_factor(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.long_kick_power_factor)
}
inline float ServerParam::_internal_long_kick_power_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.long_kick_power_factor_;
}
inline void ServerParam::_internal_set_long_kick_power_factor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.long_kick_power_factor_ = value;
}

// int32 long_kick_delay = 212;
inline void ServerParam::clear_long_kick_delay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.long_kick_delay_ = 0;
}
inline ::int32_t ServerParam::long_kick_delay() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.long_kick_delay)
  return _internal_long_kick_delay();
}
inline void ServerParam::set_long_kick_delay(::int32_t value) {
  _internal_set_long_kick_delay(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.long_kick_delay)
}
inline ::int32_t ServerParam::_internal_long_kick_delay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.long_kick_delay_;
}
inline void ServerParam::_internal_set_long_kick_delay(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.long_kick_delay_ = value;
}

// int32 max_monitors = 213;
inline void ServerParam::clear_max_monitors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_monitors_ = 0;
}
inline ::int32_t ServerParam::max_monitors() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.max_monitors)
  return _internal_max_monitors();
}
inline void ServerParam::set_max_monitors(::int32_t value) {
  _internal_set_max_monitors(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.max_monitors)
}
inline ::int32_t ServerParam::_internal_max_monitors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_monitors_;
}
inline void ServerParam::_internal_set_max_monitors(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_monitors_ = value;
}

// float catchable_area = 214;
inline void ServerParam::clear_catchable_area() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catchable_area_ = 0;
}
inline float ServerParam::catchable_area() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.catchable_area)
  return _internal_catchable_area();
}
inline void ServerParam::set_catchable_area(float value) {
  _internal_set_catchable_area(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.catchable_area)
}
inline float ServerParam::_internal_catchable_area() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.catchable_area_;
}
inline void ServerParam::_internal_set_catchable_area(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.catchable_area_ = value;
}

// float real_speed_max = 215;
inline void ServerParam::clear_real_speed_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.real_speed_max_ = 0;
}
inline float ServerParam::real_speed_max() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.real_speed_max)
  return _internal_real_speed_max();
}
inline void ServerParam::set_real_speed_max(float value) {
  _internal_set_real_speed_max(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.real_speed_max)
}
inline float ServerParam::_internal_real_speed_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.real_speed_max_;
}
inline void ServerParam::_internal_set_real_speed_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.real_speed_max_ = value;
}

// float pitch_half_length = 216;
inline void ServerParam::clear_pitch_half_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pitch_half_length_ = 0;
}
inline float ServerParam::pitch_half_length() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pitch_half_length)
  return _internal_pitch_half_length();
}
inline void ServerParam::set_pitch_half_length(float value) {
  _internal_set_pitch_half_length(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pitch_half_length)
}
inline float ServerParam::_internal_pitch_half_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pitch_half_length_;
}
inline void ServerParam::_internal_set_pitch_half_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pitch_half_length_ = value;
}

// float pitch_half_width = 217;
inline void ServerParam::clear_pitch_half_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pitch_half_width_ = 0;
}
inline float ServerParam::pitch_half_width() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.pitch_half_width)
  return _internal_pitch_half_width();
}
inline void ServerParam::set_pitch_half_width(float value) {
  _internal_set_pitch_half_width(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.pitch_half_width)
}
inline float ServerParam::_internal_pitch_half_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pitch_half_width_;
}
inline void ServerParam::_internal_set_pitch_half_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pitch_half_width_ = value;
}

// float our_penalty_area_line_x = 218;
inline void ServerParam::clear_our_penalty_area_line_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.our_penalty_area_line_x_ = 0;
}
inline float ServerParam::our_penalty_area_line_x() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.our_penalty_area_line_x)
  return _internal_our_penalty_area_line_x();
}
inline void ServerParam::set_our_penalty_area_line_x(float value) {
  _internal_set_our_penalty_area_line_x(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.our_penalty_area_line_x)
}
inline float ServerParam::_internal_our_penalty_area_line_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.our_penalty_area_line_x_;
}
inline void ServerParam::_internal_set_our_penalty_area_line_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.our_penalty_area_line_x_ = value;
}

// float their_penalty_area_line_x = 219;
inline void ServerParam::clear_their_penalty_area_line_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.their_penalty_area_line_x_ = 0;
}
inline float ServerParam::their_penalty_area_line_x() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.their_penalty_area_line_x)
  return _internal_their_penalty_area_line_x();
}
inline void ServerParam::set_their_penalty_area_line_x(float value) {
  _internal_set_their_penalty_area_line_x(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.their_penalty_area_line_x)
}
inline float ServerParam::_internal_their_penalty_area_line_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.their_penalty_area_line_x_;
}
inline void ServerParam::_internal_set_their_penalty_area_line_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.their_penalty_area_line_x_ = value;
}

// float penalty_area_half_width = 220;
inline void ServerParam::clear_penalty_area_half_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.penalty_area_half_width_ = 0;
}
inline float ServerParam::penalty_area_half_width() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.penalty_area_half_width)
  return _internal_penalty_area_half_width();
}
inline void ServerParam::set_penalty_area_half_width(float value) {
  _internal_set_penalty_area_half_width(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.penalty_area_half_width)
}
inline float ServerParam::_internal_penalty_area_half_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.penalty_area_half_width_;
}
inline void ServerParam::_internal_set_penalty_area_half_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.penalty_area_half_width_ = value;
}

// float penalty_area_length = 221;
inline void ServerParam::clear_penalty_area_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.penalty_area_length_ = 0;
}
inline float ServerParam::penalty_area_length() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.penalty_area_length)
  return _internal_penalty_area_length();
}
inline void ServerParam::set_penalty_area_length(float value) {
  _internal_set_penalty_area_length(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.penalty_area_length)
}
inline float ServerParam::_internal_penalty_area_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.penalty_area_length_;
}
inline void ServerParam::_internal_set_penalty_area_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.penalty_area_length_ = value;
}

// float goal_width = 222;
inline void ServerParam::clear_goal_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goal_width_ = 0;
}
inline float ServerParam::goal_width() const {
  // @@protoc_insertion_point(field_get:protos.ServerParam.goal_width)
  return _internal_goal_width();
}
inline void ServerParam::set_goal_width(float value) {
  _internal_set_goal_width(value);
  // @@protoc_insertion_point(field_set:protos.ServerParam.goal_width)
}
inline float ServerParam::_internal_goal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goal_width_;
}
inline void ServerParam::_internal_set_goal_width(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.goal_width_ = value;
}

// -------------------------------------------------------------------

// PlayerParam

// .protos.AgentType agent_type = 1;
inline void PlayerParam::clear_agent_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_type_ = 0;
}
inline ::protos::AgentType PlayerParam::agent_type() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.agent_type)
  return _internal_agent_type();
}
inline void PlayerParam::set_agent_type(::protos::AgentType value) {
  _internal_set_agent_type(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.agent_type)
}
inline ::protos::AgentType PlayerParam::_internal_agent_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::AgentType>(_impl_.agent_type_);
}
inline void PlayerParam::_internal_set_agent_type(::protos::AgentType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_type_ = value;
}

// int32 player_types = 2;
inline void PlayerParam::clear_player_types() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_types_ = 0;
}
inline ::int32_t PlayerParam::player_types() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.player_types)
  return _internal_player_types();
}
inline void PlayerParam::set_player_types(::int32_t value) {
  _internal_set_player_types(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.player_types)
}
inline ::int32_t PlayerParam::_internal_player_types() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_types_;
}
inline void PlayerParam::_internal_set_player_types(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_types_ = value;
}

// int32 subs_max = 3;
inline void PlayerParam::clear_subs_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subs_max_ = 0;
}
inline ::int32_t PlayerParam::subs_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.subs_max)
  return _internal_subs_max();
}
inline void PlayerParam::set_subs_max(::int32_t value) {
  _internal_set_subs_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.subs_max)
}
inline ::int32_t PlayerParam::_internal_subs_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subs_max_;
}
inline void PlayerParam::_internal_set_subs_max(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.subs_max_ = value;
}

// int32 pt_max = 4;
inline void PlayerParam::clear_pt_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pt_max_ = 0;
}
inline ::int32_t PlayerParam::pt_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.pt_max)
  return _internal_pt_max();
}
inline void PlayerParam::set_pt_max(::int32_t value) {
  _internal_set_pt_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.pt_max)
}
inline ::int32_t PlayerParam::_internal_pt_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pt_max_;
}
inline void PlayerParam::_internal_set_pt_max(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pt_max_ = value;
}

// bool allow_mult_default_type = 5;
inline void PlayerParam::clear_allow_mult_default_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allow_mult_default_type_ = false;
}
inline bool PlayerParam::allow_mult_default_type() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.allow_mult_default_type)
  return _internal_allow_mult_default_type();
}
inline void PlayerParam::set_allow_mult_default_type(bool value) {
  _internal_set_allow_mult_default_type(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.allow_mult_default_type)
}
inline bool PlayerParam::_internal_allow_mult_default_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allow_mult_default_type_;
}
inline void PlayerParam::_internal_set_allow_mult_default_type(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.allow_mult_default_type_ = value;
}

// float player_speed_max_delta_min = 6;
inline void PlayerParam::clear_player_speed_max_delta_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_speed_max_delta_min_ = 0;
}
inline float PlayerParam::player_speed_max_delta_min() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.player_speed_max_delta_min)
  return _internal_player_speed_max_delta_min();
}
inline void PlayerParam::set_player_speed_max_delta_min(float value) {
  _internal_set_player_speed_max_delta_min(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.player_speed_max_delta_min)
}
inline float PlayerParam::_internal_player_speed_max_delta_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_speed_max_delta_min_;
}
inline void PlayerParam::_internal_set_player_speed_max_delta_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_speed_max_delta_min_ = value;
}

// float player_speed_max_delta_max = 7;
inline void PlayerParam::clear_player_speed_max_delta_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_speed_max_delta_max_ = 0;
}
inline float PlayerParam::player_speed_max_delta_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.player_speed_max_delta_max)
  return _internal_player_speed_max_delta_max();
}
inline void PlayerParam::set_player_speed_max_delta_max(float value) {
  _internal_set_player_speed_max_delta_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.player_speed_max_delta_max)
}
inline float PlayerParam::_internal_player_speed_max_delta_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_speed_max_delta_max_;
}
inline void PlayerParam::_internal_set_player_speed_max_delta_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_speed_max_delta_max_ = value;
}

// float stamina_inc_max_delta_factor = 8;
inline void PlayerParam::clear_stamina_inc_max_delta_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stamina_inc_max_delta_factor_ = 0;
}
inline float PlayerParam::stamina_inc_max_delta_factor() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.stamina_inc_max_delta_factor)
  return _internal_stamina_inc_max_delta_factor();
}
inline void PlayerParam::set_stamina_inc_max_delta_factor(float value) {
  _internal_set_stamina_inc_max_delta_factor(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.stamina_inc_max_delta_factor)
}
inline float PlayerParam::_internal_stamina_inc_max_delta_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stamina_inc_max_delta_factor_;
}
inline void PlayerParam::_internal_set_stamina_inc_max_delta_factor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stamina_inc_max_delta_factor_ = value;
}

// float player_decay_delta_min = 9;
inline void PlayerParam::clear_player_decay_delta_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_decay_delta_min_ = 0;
}
inline float PlayerParam::player_decay_delta_min() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.player_decay_delta_min)
  return _internal_player_decay_delta_min();
}
inline void PlayerParam::set_player_decay_delta_min(float value) {
  _internal_set_player_decay_delta_min(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.player_decay_delta_min)
}
inline float PlayerParam::_internal_player_decay_delta_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_decay_delta_min_;
}
inline void PlayerParam::_internal_set_player_decay_delta_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_decay_delta_min_ = value;
}

// float player_decay_delta_max = 10;
inline void PlayerParam::clear_player_decay_delta_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_decay_delta_max_ = 0;
}
inline float PlayerParam::player_decay_delta_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.player_decay_delta_max)
  return _internal_player_decay_delta_max();
}
inline void PlayerParam::set_player_decay_delta_max(float value) {
  _internal_set_player_decay_delta_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.player_decay_delta_max)
}
inline float PlayerParam::_internal_player_decay_delta_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_decay_delta_max_;
}
inline void PlayerParam::_internal_set_player_decay_delta_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_decay_delta_max_ = value;
}

// float inertia_moment_delta_factor = 11;
inline void PlayerParam::clear_inertia_moment_delta_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inertia_moment_delta_factor_ = 0;
}
inline float PlayerParam::inertia_moment_delta_factor() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.inertia_moment_delta_factor)
  return _internal_inertia_moment_delta_factor();
}
inline void PlayerParam::set_inertia_moment_delta_factor(float value) {
  _internal_set_inertia_moment_delta_factor(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.inertia_moment_delta_factor)
}
inline float PlayerParam::_internal_inertia_moment_delta_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inertia_moment_delta_factor_;
}
inline void PlayerParam::_internal_set_inertia_moment_delta_factor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.inertia_moment_delta_factor_ = value;
}

// float dash_power_rate_delta_min = 12;
inline void PlayerParam::clear_dash_power_rate_delta_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_power_rate_delta_min_ = 0;
}
inline float PlayerParam::dash_power_rate_delta_min() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.dash_power_rate_delta_min)
  return _internal_dash_power_rate_delta_min();
}
inline void PlayerParam::set_dash_power_rate_delta_min(float value) {
  _internal_set_dash_power_rate_delta_min(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.dash_power_rate_delta_min)
}
inline float PlayerParam::_internal_dash_power_rate_delta_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_power_rate_delta_min_;
}
inline void PlayerParam::_internal_set_dash_power_rate_delta_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dash_power_rate_delta_min_ = value;
}

// float dash_power_rate_delta_max = 13;
inline void PlayerParam::clear_dash_power_rate_delta_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_power_rate_delta_max_ = 0;
}
inline float PlayerParam::dash_power_rate_delta_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.dash_power_rate_delta_max)
  return _internal_dash_power_rate_delta_max();
}
inline void PlayerParam::set_dash_power_rate_delta_max(float value) {
  _internal_set_dash_power_rate_delta_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.dash_power_rate_delta_max)
}
inline float PlayerParam::_internal_dash_power_rate_delta_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_power_rate_delta_max_;
}
inline void PlayerParam::_internal_set_dash_power_rate_delta_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dash_power_rate_delta_max_ = value;
}

// float player_size_delta_factor = 14;
inline void PlayerParam::clear_player_size_delta_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_size_delta_factor_ = 0;
}
inline float PlayerParam::player_size_delta_factor() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.player_size_delta_factor)
  return _internal_player_size_delta_factor();
}
inline void PlayerParam::set_player_size_delta_factor(float value) {
  _internal_set_player_size_delta_factor(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.player_size_delta_factor)
}
inline float PlayerParam::_internal_player_size_delta_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_size_delta_factor_;
}
inline void PlayerParam::_internal_set_player_size_delta_factor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_size_delta_factor_ = value;
}

// float kickable_margin_delta_min = 15;
inline void PlayerParam::clear_kickable_margin_delta_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kickable_margin_delta_min_ = 0;
}
inline float PlayerParam::kickable_margin_delta_min() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.kickable_margin_delta_min)
  return _internal_kickable_margin_delta_min();
}
inline void PlayerParam::set_kickable_margin_delta_min(float value) {
  _internal_set_kickable_margin_delta_min(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.kickable_margin_delta_min)
}
inline float PlayerParam::_internal_kickable_margin_delta_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kickable_margin_delta_min_;
}
inline void PlayerParam::_internal_set_kickable_margin_delta_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kickable_margin_delta_min_ = value;
}

// float kickable_margin_delta_max = 16;
inline void PlayerParam::clear_kickable_margin_delta_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kickable_margin_delta_max_ = 0;
}
inline float PlayerParam::kickable_margin_delta_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.kickable_margin_delta_max)
  return _internal_kickable_margin_delta_max();
}
inline void PlayerParam::set_kickable_margin_delta_max(float value) {
  _internal_set_kickable_margin_delta_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.kickable_margin_delta_max)
}
inline float PlayerParam::_internal_kickable_margin_delta_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kickable_margin_delta_max_;
}
inline void PlayerParam::_internal_set_kickable_margin_delta_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kickable_margin_delta_max_ = value;
}

// float kick_rand_delta_factor = 17;
inline void PlayerParam::clear_kick_rand_delta_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kick_rand_delta_factor_ = 0;
}
inline float PlayerParam::kick_rand_delta_factor() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.kick_rand_delta_factor)
  return _internal_kick_rand_delta_factor();
}
inline void PlayerParam::set_kick_rand_delta_factor(float value) {
  _internal_set_kick_rand_delta_factor(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.kick_rand_delta_factor)
}
inline float PlayerParam::_internal_kick_rand_delta_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kick_rand_delta_factor_;
}
inline void PlayerParam::_internal_set_kick_rand_delta_factor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kick_rand_delta_factor_ = value;
}

// float extra_stamina_delta_min = 18;
inline void PlayerParam::clear_extra_stamina_delta_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extra_stamina_delta_min_ = 0;
}
inline float PlayerParam::extra_stamina_delta_min() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.extra_stamina_delta_min)
  return _internal_extra_stamina_delta_min();
}
inline void PlayerParam::set_extra_stamina_delta_min(float value) {
  _internal_set_extra_stamina_delta_min(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.extra_stamina_delta_min)
}
inline float PlayerParam::_internal_extra_stamina_delta_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extra_stamina_delta_min_;
}
inline void PlayerParam::_internal_set_extra_stamina_delta_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.extra_stamina_delta_min_ = value;
}

// float extra_stamina_delta_max = 19;
inline void PlayerParam::clear_extra_stamina_delta_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extra_stamina_delta_max_ = 0;
}
inline float PlayerParam::extra_stamina_delta_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.extra_stamina_delta_max)
  return _internal_extra_stamina_delta_max();
}
inline void PlayerParam::set_extra_stamina_delta_max(float value) {
  _internal_set_extra_stamina_delta_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.extra_stamina_delta_max)
}
inline float PlayerParam::_internal_extra_stamina_delta_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extra_stamina_delta_max_;
}
inline void PlayerParam::_internal_set_extra_stamina_delta_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.extra_stamina_delta_max_ = value;
}

// float effort_max_delta_factor = 20;
inline void PlayerParam::clear_effort_max_delta_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effort_max_delta_factor_ = 0;
}
inline float PlayerParam::effort_max_delta_factor() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.effort_max_delta_factor)
  return _internal_effort_max_delta_factor();
}
inline void PlayerParam::set_effort_max_delta_factor(float value) {
  _internal_set_effort_max_delta_factor(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.effort_max_delta_factor)
}
inline float PlayerParam::_internal_effort_max_delta_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effort_max_delta_factor_;
}
inline void PlayerParam::_internal_set_effort_max_delta_factor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effort_max_delta_factor_ = value;
}

// float effort_min_delta_factor = 21;
inline void PlayerParam::clear_effort_min_delta_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effort_min_delta_factor_ = 0;
}
inline float PlayerParam::effort_min_delta_factor() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.effort_min_delta_factor)
  return _internal_effort_min_delta_factor();
}
inline void PlayerParam::set_effort_min_delta_factor(float value) {
  _internal_set_effort_min_delta_factor(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.effort_min_delta_factor)
}
inline float PlayerParam::_internal_effort_min_delta_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effort_min_delta_factor_;
}
inline void PlayerParam::_internal_set_effort_min_delta_factor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effort_min_delta_factor_ = value;
}

// int32 random_seed = 22;
inline void PlayerParam::clear_random_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.random_seed_ = 0;
}
inline ::int32_t PlayerParam::random_seed() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.random_seed)
  return _internal_random_seed();
}
inline void PlayerParam::set_random_seed(::int32_t value) {
  _internal_set_random_seed(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.random_seed)
}
inline ::int32_t PlayerParam::_internal_random_seed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.random_seed_;
}
inline void PlayerParam::_internal_set_random_seed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.random_seed_ = value;
}

// float new_dash_power_rate_delta_min = 23;
inline void PlayerParam::clear_new_dash_power_rate_delta_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_dash_power_rate_delta_min_ = 0;
}
inline float PlayerParam::new_dash_power_rate_delta_min() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.new_dash_power_rate_delta_min)
  return _internal_new_dash_power_rate_delta_min();
}
inline void PlayerParam::set_new_dash_power_rate_delta_min(float value) {
  _internal_set_new_dash_power_rate_delta_min(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.new_dash_power_rate_delta_min)
}
inline float PlayerParam::_internal_new_dash_power_rate_delta_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_dash_power_rate_delta_min_;
}
inline void PlayerParam::_internal_set_new_dash_power_rate_delta_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_dash_power_rate_delta_min_ = value;
}

// float new_dash_power_rate_delta_max = 24;
inline void PlayerParam::clear_new_dash_power_rate_delta_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_dash_power_rate_delta_max_ = 0;
}
inline float PlayerParam::new_dash_power_rate_delta_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.new_dash_power_rate_delta_max)
  return _internal_new_dash_power_rate_delta_max();
}
inline void PlayerParam::set_new_dash_power_rate_delta_max(float value) {
  _internal_set_new_dash_power_rate_delta_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.new_dash_power_rate_delta_max)
}
inline float PlayerParam::_internal_new_dash_power_rate_delta_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_dash_power_rate_delta_max_;
}
inline void PlayerParam::_internal_set_new_dash_power_rate_delta_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_dash_power_rate_delta_max_ = value;
}

// float new_stamina_inc_max_delta_factor = 25;
inline void PlayerParam::clear_new_stamina_inc_max_delta_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_stamina_inc_max_delta_factor_ = 0;
}
inline float PlayerParam::new_stamina_inc_max_delta_factor() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.new_stamina_inc_max_delta_factor)
  return _internal_new_stamina_inc_max_delta_factor();
}
inline void PlayerParam::set_new_stamina_inc_max_delta_factor(float value) {
  _internal_set_new_stamina_inc_max_delta_factor(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.new_stamina_inc_max_delta_factor)
}
inline float PlayerParam::_internal_new_stamina_inc_max_delta_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_stamina_inc_max_delta_factor_;
}
inline void PlayerParam::_internal_set_new_stamina_inc_max_delta_factor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_stamina_inc_max_delta_factor_ = value;
}

// float kick_power_rate_delta_min = 26;
inline void PlayerParam::clear_kick_power_rate_delta_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kick_power_rate_delta_min_ = 0;
}
inline float PlayerParam::kick_power_rate_delta_min() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.kick_power_rate_delta_min)
  return _internal_kick_power_rate_delta_min();
}
inline void PlayerParam::set_kick_power_rate_delta_min(float value) {
  _internal_set_kick_power_rate_delta_min(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.kick_power_rate_delta_min)
}
inline float PlayerParam::_internal_kick_power_rate_delta_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kick_power_rate_delta_min_;
}
inline void PlayerParam::_internal_set_kick_power_rate_delta_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kick_power_rate_delta_min_ = value;
}

// float kick_power_rate_delta_max = 27;
inline void PlayerParam::clear_kick_power_rate_delta_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kick_power_rate_delta_max_ = 0;
}
inline float PlayerParam::kick_power_rate_delta_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.kick_power_rate_delta_max)
  return _internal_kick_power_rate_delta_max();
}
inline void PlayerParam::set_kick_power_rate_delta_max(float value) {
  _internal_set_kick_power_rate_delta_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.kick_power_rate_delta_max)
}
inline float PlayerParam::_internal_kick_power_rate_delta_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kick_power_rate_delta_max_;
}
inline void PlayerParam::_internal_set_kick_power_rate_delta_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kick_power_rate_delta_max_ = value;
}

// float foul_detect_probability_delta_factor = 28;
inline void PlayerParam::clear_foul_detect_probability_delta_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.foul_detect_probability_delta_factor_ = 0;
}
inline float PlayerParam::foul_detect_probability_delta_factor() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.foul_detect_probability_delta_factor)
  return _internal_foul_detect_probability_delta_factor();
}
inline void PlayerParam::set_foul_detect_probability_delta_factor(float value) {
  _internal_set_foul_detect_probability_delta_factor(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.foul_detect_probability_delta_factor)
}
inline float PlayerParam::_internal_foul_detect_probability_delta_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.foul_detect_probability_delta_factor_;
}
inline void PlayerParam::_internal_set_foul_detect_probability_delta_factor(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.foul_detect_probability_delta_factor_ = value;
}

// float catchable_area_l_stretch_min = 29;
inline void PlayerParam::clear_catchable_area_l_stretch_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catchable_area_l_stretch_min_ = 0;
}
inline float PlayerParam::catchable_area_l_stretch_min() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.catchable_area_l_stretch_min)
  return _internal_catchable_area_l_stretch_min();
}
inline void PlayerParam::set_catchable_area_l_stretch_min(float value) {
  _internal_set_catchable_area_l_stretch_min(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.catchable_area_l_stretch_min)
}
inline float PlayerParam::_internal_catchable_area_l_stretch_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.catchable_area_l_stretch_min_;
}
inline void PlayerParam::_internal_set_catchable_area_l_stretch_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.catchable_area_l_stretch_min_ = value;
}

// float catchable_area_l_stretch_max = 30;
inline void PlayerParam::clear_catchable_area_l_stretch_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catchable_area_l_stretch_max_ = 0;
}
inline float PlayerParam::catchable_area_l_stretch_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerParam.catchable_area_l_stretch_max)
  return _internal_catchable_area_l_stretch_max();
}
inline void PlayerParam::set_catchable_area_l_stretch_max(float value) {
  _internal_set_catchable_area_l_stretch_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerParam.catchable_area_l_stretch_max)
}
inline float PlayerParam::_internal_catchable_area_l_stretch_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.catchable_area_l_stretch_max_;
}
inline void PlayerParam::_internal_set_catchable_area_l_stretch_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.catchable_area_l_stretch_max_ = value;
}

// -------------------------------------------------------------------

// PlayerType

// .protos.AgentType agent_type = 1;
inline void PlayerType::clear_agent_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.agent_type_ = 0;
}
inline ::protos::AgentType PlayerType::agent_type() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.agent_type)
  return _internal_agent_type();
}
inline void PlayerType::set_agent_type(::protos::AgentType value) {
  _internal_set_agent_type(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.agent_type)
}
inline ::protos::AgentType PlayerType::_internal_agent_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::protos::AgentType>(_impl_.agent_type_);
}
inline void PlayerType::_internal_set_agent_type(::protos::AgentType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.agent_type_ = value;
}

// int32 id = 2;
inline void PlayerType::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t PlayerType::id() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.id)
  return _internal_id();
}
inline void PlayerType::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.id)
}
inline ::int32_t PlayerType::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void PlayerType::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// float stamina_inc_max = 3;
inline void PlayerType::clear_stamina_inc_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stamina_inc_max_ = 0;
}
inline float PlayerType::stamina_inc_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.stamina_inc_max)
  return _internal_stamina_inc_max();
}
inline void PlayerType::set_stamina_inc_max(float value) {
  _internal_set_stamina_inc_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.stamina_inc_max)
}
inline float PlayerType::_internal_stamina_inc_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stamina_inc_max_;
}
inline void PlayerType::_internal_set_stamina_inc_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stamina_inc_max_ = value;
}

// float player_decay = 4;
inline void PlayerType::clear_player_decay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_decay_ = 0;
}
inline float PlayerType::player_decay() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.player_decay)
  return _internal_player_decay();
}
inline void PlayerType::set_player_decay(float value) {
  _internal_set_player_decay(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.player_decay)
}
inline float PlayerType::_internal_player_decay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_decay_;
}
inline void PlayerType::_internal_set_player_decay(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_decay_ = value;
}

// float inertia_moment = 5;
inline void PlayerType::clear_inertia_moment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inertia_moment_ = 0;
}
inline float PlayerType::inertia_moment() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.inertia_moment)
  return _internal_inertia_moment();
}
inline void PlayerType::set_inertia_moment(float value) {
  _internal_set_inertia_moment(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.inertia_moment)
}
inline float PlayerType::_internal_inertia_moment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inertia_moment_;
}
inline void PlayerType::_internal_set_inertia_moment(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.inertia_moment_ = value;
}

// float dash_power_rate = 6;
inline void PlayerType::clear_dash_power_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dash_power_rate_ = 0;
}
inline float PlayerType::dash_power_rate() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.dash_power_rate)
  return _internal_dash_power_rate();
}
inline void PlayerType::set_dash_power_rate(float value) {
  _internal_set_dash_power_rate(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.dash_power_rate)
}
inline float PlayerType::_internal_dash_power_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dash_power_rate_;
}
inline void PlayerType::_internal_set_dash_power_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dash_power_rate_ = value;
}

// float player_size = 7;
inline void PlayerType::clear_player_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_size_ = 0;
}
inline float PlayerType::player_size() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.player_size)
  return _internal_player_size();
}
inline void PlayerType::set_player_size(float value) {
  _internal_set_player_size(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.player_size)
}
inline float PlayerType::_internal_player_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_size_;
}
inline void PlayerType::_internal_set_player_size(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_size_ = value;
}

// float kickable_margin = 8;
inline void PlayerType::clear_kickable_margin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kickable_margin_ = 0;
}
inline float PlayerType::kickable_margin() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.kickable_margin)
  return _internal_kickable_margin();
}
inline void PlayerType::set_kickable_margin(float value) {
  _internal_set_kickable_margin(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.kickable_margin)
}
inline float PlayerType::_internal_kickable_margin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kickable_margin_;
}
inline void PlayerType::_internal_set_kickable_margin(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kickable_margin_ = value;
}

// float kick_rand = 9;
inline void PlayerType::clear_kick_rand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kick_rand_ = 0;
}
inline float PlayerType::kick_rand() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.kick_rand)
  return _internal_kick_rand();
}
inline void PlayerType::set_kick_rand(float value) {
  _internal_set_kick_rand(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.kick_rand)
}
inline float PlayerType::_internal_kick_rand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kick_rand_;
}
inline void PlayerType::_internal_set_kick_rand(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kick_rand_ = value;
}

// float extra_stamina = 10;
inline void PlayerType::clear_extra_stamina() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extra_stamina_ = 0;
}
inline float PlayerType::extra_stamina() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.extra_stamina)
  return _internal_extra_stamina();
}
inline void PlayerType::set_extra_stamina(float value) {
  _internal_set_extra_stamina(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.extra_stamina)
}
inline float PlayerType::_internal_extra_stamina() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extra_stamina_;
}
inline void PlayerType::_internal_set_extra_stamina(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.extra_stamina_ = value;
}

// float effort_max = 11;
inline void PlayerType::clear_effort_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effort_max_ = 0;
}
inline float PlayerType::effort_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.effort_max)
  return _internal_effort_max();
}
inline void PlayerType::set_effort_max(float value) {
  _internal_set_effort_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.effort_max)
}
inline float PlayerType::_internal_effort_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effort_max_;
}
inline void PlayerType::_internal_set_effort_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effort_max_ = value;
}

// float effort_min = 12;
inline void PlayerType::clear_effort_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effort_min_ = 0;
}
inline float PlayerType::effort_min() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.effort_min)
  return _internal_effort_min();
}
inline void PlayerType::set_effort_min(float value) {
  _internal_set_effort_min(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.effort_min)
}
inline float PlayerType::_internal_effort_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effort_min_;
}
inline void PlayerType::_internal_set_effort_min(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effort_min_ = value;
}

// float kick_power_rate = 13;
inline void PlayerType::clear_kick_power_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kick_power_rate_ = 0;
}
inline float PlayerType::kick_power_rate() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.kick_power_rate)
  return _internal_kick_power_rate();
}
inline void PlayerType::set_kick_power_rate(float value) {
  _internal_set_kick_power_rate(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.kick_power_rate)
}
inline float PlayerType::_internal_kick_power_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kick_power_rate_;
}
inline void PlayerType::_internal_set_kick_power_rate(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kick_power_rate_ = value;
}

// float foul_detect_probability = 14;
inline void PlayerType::clear_foul_detect_probability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.foul_detect_probability_ = 0;
}
inline float PlayerType::foul_detect_probability() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.foul_detect_probability)
  return _internal_foul_detect_probability();
}
inline void PlayerType::set_foul_detect_probability(float value) {
  _internal_set_foul_detect_probability(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.foul_detect_probability)
}
inline float PlayerType::_internal_foul_detect_probability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.foul_detect_probability_;
}
inline void PlayerType::_internal_set_foul_detect_probability(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.foul_detect_probability_ = value;
}

// float catchable_area_l_stretch = 15;
inline void PlayerType::clear_catchable_area_l_stretch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catchable_area_l_stretch_ = 0;
}
inline float PlayerType::catchable_area_l_stretch() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.catchable_area_l_stretch)
  return _internal_catchable_area_l_stretch();
}
inline void PlayerType::set_catchable_area_l_stretch(float value) {
  _internal_set_catchable_area_l_stretch(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.catchable_area_l_stretch)
}
inline float PlayerType::_internal_catchable_area_l_stretch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.catchable_area_l_stretch_;
}
inline void PlayerType::_internal_set_catchable_area_l_stretch(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.catchable_area_l_stretch_ = value;
}

// float unum_far_length = 16;
inline void PlayerType::clear_unum_far_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unum_far_length_ = 0;
}
inline float PlayerType::unum_far_length() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.unum_far_length)
  return _internal_unum_far_length();
}
inline void PlayerType::set_unum_far_length(float value) {
  _internal_set_unum_far_length(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.unum_far_length)
}
inline float PlayerType::_internal_unum_far_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unum_far_length_;
}
inline void PlayerType::_internal_set_unum_far_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unum_far_length_ = value;
}

// float unum_too_far_length = 17;
inline void PlayerType::clear_unum_too_far_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unum_too_far_length_ = 0;
}
inline float PlayerType::unum_too_far_length() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.unum_too_far_length)
  return _internal_unum_too_far_length();
}
inline void PlayerType::set_unum_too_far_length(float value) {
  _internal_set_unum_too_far_length(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.unum_too_far_length)
}
inline float PlayerType::_internal_unum_too_far_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unum_too_far_length_;
}
inline void PlayerType::_internal_set_unum_too_far_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unum_too_far_length_ = value;
}

// float team_far_length = 18;
inline void PlayerType::clear_team_far_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.team_far_length_ = 0;
}
inline float PlayerType::team_far_length() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.team_far_length)
  return _internal_team_far_length();
}
inline void PlayerType::set_team_far_length(float value) {
  _internal_set_team_far_length(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.team_far_length)
}
inline float PlayerType::_internal_team_far_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.team_far_length_;
}
inline void PlayerType::_internal_set_team_far_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.team_far_length_ = value;
}

// float team_too_far_length = 19;
inline void PlayerType::clear_team_too_far_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.team_too_far_length_ = 0;
}
inline float PlayerType::team_too_far_length() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.team_too_far_length)
  return _internal_team_too_far_length();
}
inline void PlayerType::set_team_too_far_length(float value) {
  _internal_set_team_too_far_length(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.team_too_far_length)
}
inline float PlayerType::_internal_team_too_far_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.team_too_far_length_;
}
inline void PlayerType::_internal_set_team_too_far_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.team_too_far_length_ = value;
}

// float player_max_observation_length = 20;
inline void PlayerType::clear_player_max_observation_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_max_observation_length_ = 0;
}
inline float PlayerType::player_max_observation_length() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.player_max_observation_length)
  return _internal_player_max_observation_length();
}
inline void PlayerType::set_player_max_observation_length(float value) {
  _internal_set_player_max_observation_length(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.player_max_observation_length)
}
inline float PlayerType::_internal_player_max_observation_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_max_observation_length_;
}
inline void PlayerType::_internal_set_player_max_observation_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_max_observation_length_ = value;
}

// float ball_vel_far_length = 21;
inline void PlayerType::clear_ball_vel_far_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ball_vel_far_length_ = 0;
}
inline float PlayerType::ball_vel_far_length() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.ball_vel_far_length)
  return _internal_ball_vel_far_length();
}
inline void PlayerType::set_ball_vel_far_length(float value) {
  _internal_set_ball_vel_far_length(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.ball_vel_far_length)
}
inline float PlayerType::_internal_ball_vel_far_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ball_vel_far_length_;
}
inline void PlayerType::_internal_set_ball_vel_far_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ball_vel_far_length_ = value;
}

// float ball_vel_too_far_length = 22;
inline void PlayerType::clear_ball_vel_too_far_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ball_vel_too_far_length_ = 0;
}
inline float PlayerType::ball_vel_too_far_length() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.ball_vel_too_far_length)
  return _internal_ball_vel_too_far_length();
}
inline void PlayerType::set_ball_vel_too_far_length(float value) {
  _internal_set_ball_vel_too_far_length(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.ball_vel_too_far_length)
}
inline float PlayerType::_internal_ball_vel_too_far_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ball_vel_too_far_length_;
}
inline void PlayerType::_internal_set_ball_vel_too_far_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ball_vel_too_far_length_ = value;
}

// float ball_max_observation_length = 23;
inline void PlayerType::clear_ball_max_observation_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ball_max_observation_length_ = 0;
}
inline float PlayerType::ball_max_observation_length() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.ball_max_observation_length)
  return _internal_ball_max_observation_length();
}
inline void PlayerType::set_ball_max_observation_length(float value) {
  _internal_set_ball_max_observation_length(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.ball_max_observation_length)
}
inline float PlayerType::_internal_ball_max_observation_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ball_max_observation_length_;
}
inline void PlayerType::_internal_set_ball_max_observation_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ball_max_observation_length_ = value;
}

// float flag_chg_far_length = 24;
inline void PlayerType::clear_flag_chg_far_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flag_chg_far_length_ = 0;
}
inline float PlayerType::flag_chg_far_length() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.flag_chg_far_length)
  return _internal_flag_chg_far_length();
}
inline void PlayerType::set_flag_chg_far_length(float value) {
  _internal_set_flag_chg_far_length(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.flag_chg_far_length)
}
inline float PlayerType::_internal_flag_chg_far_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flag_chg_far_length_;
}
inline void PlayerType::_internal_set_flag_chg_far_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flag_chg_far_length_ = value;
}

// float flag_chg_too_far_length = 25;
inline void PlayerType::clear_flag_chg_too_far_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flag_chg_too_far_length_ = 0;
}
inline float PlayerType::flag_chg_too_far_length() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.flag_chg_too_far_length)
  return _internal_flag_chg_too_far_length();
}
inline void PlayerType::set_flag_chg_too_far_length(float value) {
  _internal_set_flag_chg_too_far_length(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.flag_chg_too_far_length)
}
inline float PlayerType::_internal_flag_chg_too_far_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flag_chg_too_far_length_;
}
inline void PlayerType::_internal_set_flag_chg_too_far_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flag_chg_too_far_length_ = value;
}

// float flag_max_observation_length = 26;
inline void PlayerType::clear_flag_max_observation_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flag_max_observation_length_ = 0;
}
inline float PlayerType::flag_max_observation_length() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.flag_max_observation_length)
  return _internal_flag_max_observation_length();
}
inline void PlayerType::set_flag_max_observation_length(float value) {
  _internal_set_flag_max_observation_length(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.flag_max_observation_length)
}
inline float PlayerType::_internal_flag_max_observation_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flag_max_observation_length_;
}
inline void PlayerType::_internal_set_flag_max_observation_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flag_max_observation_length_ = value;
}

// float kickable_area = 27;
inline void PlayerType::clear_kickable_area() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kickable_area_ = 0;
}
inline float PlayerType::kickable_area() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.kickable_area)
  return _internal_kickable_area();
}
inline void PlayerType::set_kickable_area(float value) {
  _internal_set_kickable_area(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.kickable_area)
}
inline float PlayerType::_internal_kickable_area() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kickable_area_;
}
inline void PlayerType::_internal_set_kickable_area(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.kickable_area_ = value;
}

// float reliable_catchable_dist = 28;
inline void PlayerType::clear_reliable_catchable_dist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reliable_catchable_dist_ = 0;
}
inline float PlayerType::reliable_catchable_dist() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.reliable_catchable_dist)
  return _internal_reliable_catchable_dist();
}
inline void PlayerType::set_reliable_catchable_dist(float value) {
  _internal_set_reliable_catchable_dist(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.reliable_catchable_dist)
}
inline float PlayerType::_internal_reliable_catchable_dist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reliable_catchable_dist_;
}
inline void PlayerType::_internal_set_reliable_catchable_dist(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reliable_catchable_dist_ = value;
}

// float max_catchable_dist = 29;
inline void PlayerType::clear_max_catchable_dist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_catchable_dist_ = 0;
}
inline float PlayerType::max_catchable_dist() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.max_catchable_dist)
  return _internal_max_catchable_dist();
}
inline void PlayerType::set_max_catchable_dist(float value) {
  _internal_set_max_catchable_dist(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.max_catchable_dist)
}
inline float PlayerType::_internal_max_catchable_dist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_catchable_dist_;
}
inline void PlayerType::_internal_set_max_catchable_dist(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_catchable_dist_ = value;
}

// float real_speed_max = 30;
inline void PlayerType::clear_real_speed_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.real_speed_max_ = 0;
}
inline float PlayerType::real_speed_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.real_speed_max)
  return _internal_real_speed_max();
}
inline void PlayerType::set_real_speed_max(float value) {
  _internal_set_real_speed_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.real_speed_max)
}
inline float PlayerType::_internal_real_speed_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.real_speed_max_;
}
inline void PlayerType::_internal_set_real_speed_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.real_speed_max_ = value;
}

// float player_speed_max2 = 31;
inline void PlayerType::clear_player_speed_max2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_speed_max2_ = 0;
}
inline float PlayerType::player_speed_max2() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.player_speed_max2)
  return _internal_player_speed_max2();
}
inline void PlayerType::set_player_speed_max2(float value) {
  _internal_set_player_speed_max2(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.player_speed_max2)
}
inline float PlayerType::_internal_player_speed_max2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_speed_max2_;
}
inline void PlayerType::_internal_set_player_speed_max2(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_speed_max2_ = value;
}

// float real_speed_max2 = 32;
inline void PlayerType::clear_real_speed_max2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.real_speed_max2_ = 0;
}
inline float PlayerType::real_speed_max2() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.real_speed_max2)
  return _internal_real_speed_max2();
}
inline void PlayerType::set_real_speed_max2(float value) {
  _internal_set_real_speed_max2(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.real_speed_max2)
}
inline float PlayerType::_internal_real_speed_max2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.real_speed_max2_;
}
inline void PlayerType::_internal_set_real_speed_max2(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.real_speed_max2_ = value;
}

// int32 cycles_to_reach_max_speed = 33;
inline void PlayerType::clear_cycles_to_reach_max_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cycles_to_reach_max_speed_ = 0;
}
inline ::int32_t PlayerType::cycles_to_reach_max_speed() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.cycles_to_reach_max_speed)
  return _internal_cycles_to_reach_max_speed();
}
inline void PlayerType::set_cycles_to_reach_max_speed(::int32_t value) {
  _internal_set_cycles_to_reach_max_speed(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.cycles_to_reach_max_speed)
}
inline ::int32_t PlayerType::_internal_cycles_to_reach_max_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cycles_to_reach_max_speed_;
}
inline void PlayerType::_internal_set_cycles_to_reach_max_speed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cycles_to_reach_max_speed_ = value;
}

// float player_speed_max = 34;
inline void PlayerType::clear_player_speed_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_speed_max_ = 0;
}
inline float PlayerType::player_speed_max() const {
  // @@protoc_insertion_point(field_get:protos.PlayerType.player_speed_max)
  return _internal_player_speed_max();
}
inline void PlayerType::set_player_speed_max(float value) {
  _internal_set_player_speed_max(value);
  // @@protoc_insertion_point(field_set:protos.PlayerType.player_speed_max)
}
inline float PlayerType::_internal_player_speed_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_speed_max_;
}
inline void PlayerType::_internal_set_player_speed_max(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_speed_max_ = value;
}

// -------------------------------------------------------------------

// Empty

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protos


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::protos::ViewWidth> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::ViewWidth>() {
  return ::protos::ViewWidth_descriptor();
}
template <>
struct is_proto_enum<::protos::Side> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::Side>() {
  return ::protos::Side_descriptor();
}
template <>
struct is_proto_enum<::protos::LoggerLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::LoggerLevel>() {
  return ::protos::LoggerLevel_descriptor();
}
template <>
struct is_proto_enum<::protos::InterceptActionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::InterceptActionType>() {
  return ::protos::InterceptActionType_descriptor();
}
template <>
struct is_proto_enum<::protos::GameModeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::GameModeType>() {
  return ::protos::GameModeType_descriptor();
}
template <>
struct is_proto_enum<::protos::AgentType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::protos::AgentType>() {
  return ::protos::AgentType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_service_2eproto_2epb_2eh
